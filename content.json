{"meta":{"title":"whks-blog","subtitle":"","description":"你好呀，我是一条酸菜鱼，谢谢你的观看","author":"whk","url":"https://www.whkblog.work","root":"/"},"pages":[{"title":"categories","date":"2021-01-05T13:39:14.000Z","updated":"2021-01-05T13:41:42.554Z","comments":true,"path":"categories/index.html","permalink":"https://www.whkblog.work/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2021-01-05T13:39:27.000Z","updated":"2021-01-05T13:41:43.139Z","comments":true,"path":"tages/index.html","permalink":"https://www.whkblog.work/tages/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-30T09:54:48.933Z","updated":"2021-01-05T11:38:49.011Z","comments":true,"path":"links/index.html","permalink":"https://www.whkblog.work/links/index.html","excerpt":"","text":""}],"posts":[{"title":"jxnu","slug":"jxnu","date":"2022-01-16T04:44:41.000Z","updated":"2022-01-16T04:56:56.598Z","comments":true,"path":"2022/01/16/jxnu/","link":"","permalink":"https://www.whkblog.work/2022/01/16/jxnu/","excerpt":"","text":"前言去年国庆的时候乘着放假学完了vue,然后10月份跟11月份又自己看B站视频学完了django、DRF，之后又跟着一个大佬的博客做了一个vue-django前后端分离的项目，具体连接为：https://www.dusaiphoto.com/article/103/，然后寒假在家有点无聊，我就没事自己开了一个项目来试着自己做一个前后端分离的项目。 项目的主要目标就将我院的官网重构一下，实在是太丑了。虽然我做了我也不会给学院就是。这些都是后话。、 前端部分开始项目环境准备项目环境的话 Vue 3 vue/cli 4.5.14 npm 7.23.0 开始项目部分我就不说了 直接进入主题 先安装一下axios ,vue-router element-ui 123npm install axiosnpm install vue-routernpm install element-ui 也可以通过vue控制面板安装，读者自行尝试 一、首页搭建","categories":[{"name":"前端","slug":"前端","permalink":"https://www.whkblog.work/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/tags/python/"},{"name":"vue","slug":"vue","permalink":"https://www.whkblog.work/tags/vue/"},{"name":"django","slug":"django","permalink":"https://www.whkblog.work/tags/django/"},{"name":"后端","slug":"后端","permalink":"https://www.whkblog.work/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"python_multi","slug":"python-multi","date":"2021-12-24T02:44:16.000Z","updated":"2021-12-26T07:52:19.075Z","comments":true,"path":"2021/12/24/python-multi/","link":"","permalink":"https://www.whkblog.work/2021/12/24/python-multi/","excerpt":"","text":"这两天学习了下多线程相关知识，观看的是b站上一个up主的视频，这里做一个总结，方便以后回忆一下。 视频链接https://www.bilibili.com/video/BV1bK411A7tV 以下文章中出现的图片出自视频截图 前置知识CPU-BOUND &amp; I/O-BOUNDcpu-bound计算密集型、☞I/O在很短时间内可以完成，CPU需要大量的计算和处理，特点是CPU占用率相当高 例如：解压缩，加密压缩、正则表达式搜索 i/o-boundIO密集型☞系统运作大部分状况是CPU在登I/O（内存硬盘）的读/写操作，CPU占用率仍然较低 例如：文件处理程序、网络爬虫程序 多线程、多进程、多协程相关概念多进程进程是操作系统进行资源分配与调度的基本单位，是具有一定独立功能的程序关于某个数据集合上的一次运行活动，而程序是指令、数据及其组织形式的描述。简言之，进程是程序的实体，一个进程就是一个独立的程序，程序一旦运行就是进程。 多线程线程是操作系统程序执行流的最小单元，即进程中的最小运行单元，也是处理器调度和分派的基本单位。进程由一个或多个线程组成，同一进程中的多个线程将共享该进程中的全部系统资源，一个进程（程序）执行过程中，可能有多个线程在运行。 多协程协程，又称微线程，纤程，英文名为Coroutine，是一种用户态的轻量级线程，其本质上是一个单线程。协程可以看作是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 多线程、多进程、多协程的对比关系：一个进程可以启动N个线程、一个线程可以启动N个协程 多线程优点：可以利用多核CUP并行运算 缺点：占用资源最多、可启动数目比线程少 适用于： CPU密集型计算 多进程优点：相比进程更轻量级、占用资源少 缺点： ​ 相比进程：多线程只能并发执行，不能利用多CPU（由于python 有GIL锁的缘故） ​ 相比协程：启动数目有限制、占用内存资源，有多线程切换开销 适用于： IO密集型计算、同时运行任务数要求不多 多协程优点：内存开销最少、启动协程数量最多 缺点：支持库有限制（aiohttp &amp; requests）、代码实现复杂 适用于：IO密集型计算、需要超多任务运行、但有现成库支持的场景 三种方式的用法及案例技术选择根据任务特点进行数据选择 如果是CPU密集型，选择多进程multiprocessing。 如果是IO密集型，任务量多少？是否有协程库支持？协程实现复杂度？ 前缀知识GIL锁基础概念全局解释器锁（Global Interpreter Lock,简写：GIL） 是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核心处理器上，使用GIL的解释器也只允许同一时间执行一个线程 用于解决多线程之间数据完整性和状态同步问题 具体可看https://www.bilibili.com/video/BV1bK411A7tV?p=3&amp;spm_id_from=pageDriver 第7分钟左右的解释 好处：简化python对共享资源的管理 如何规避1、多线程threading机制，用于IO密集型计算 2、使用multiprocessing的多线程机制是实现并行计算、利用多核CPU优势 ​ python 提供了multiprocessing模块 多线程多线程数据通讯queue.Queue可用于多线程之间的、线程安全的数据通信 生产者消费者模型 线程安全概念线程安全指某个函数、函数库在多线程环境中被调用时，能够正确处理多个线程之间的共享变量，使程序功能正确完成 由于线程的执行会随时发生切换，就造成了不可预料的结果，出现线程不安全 解决方式Lock用于解决线程安全问题 线程池原理线程周期 新建线程系统需要分配资源、终止线程系统需要回收资源，如果可以重用线程，则可以减去新建/终止的开销 优点1、提升性能：减去了大量新建、终止线程的开销，重用了线程资源 2、使用场景：适合处理突发性大量请求或需要大量线程完成任务，但实际任务处理时间较短 3、防御功能：能有效避免系统因为创建县城过多，而导致系统负荷过大相应变慢等问题（线程池线程数目 可以固定） 4：代码优势：使用线程池的语法比自己新建线程执行线程更加简洁 使用语法 多进程引入缘故 多线程虽然可以加速运行，但遇到CPU密集型计算依然会速度变慢，multirocessing模块可以解决多线程中GIL缺陷。 用法实际上与多线程的用法差不多 这里需要注意到一点是线程安全锁即LOCK使用缘由：一个是安全锁防止冲突的（if） 一个是生产者消费者模式的 多协程协程：在单线程内实现并发核心原理：利用一个超级循环（既while true）循环 核心原理：配合IO多路复用原理（IO时CPU可以干其他的事） 实现：异步IO库——asyncio使用前提：要用在IO异步编程中，依赖的库必须支持异步IO特性，在爬虫中的requests不支持异步需使用aiohttp","categories":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/tags/python/"},{"name":"多线程","slug":"多线程","permalink":"https://www.whkblog.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"webcrawle","slug":"webcrawle_douban","date":"2021-11-30T02:30:57.000Z","updated":"2021-12-26T07:47:00.281Z","comments":true,"path":"2021/11/30/webcrawle_douban/","link":"","permalink":"https://www.whkblog.work/2021/11/30/webcrawle_douban/","excerpt":"","text":"爬取豆瓣评论数据此教程时教如何爬取豆瓣网页数据，是笔者上爬虫课的一个实验作业；这里写下个人实现过程 一、查看网页结构进入随机一个电影的评论区，摁F12查看网页数据 可以看到豆瓣评论区评论内容就是直接的html格式返回的数据； 数据的接口就是： https://movie.douban.com/subject/26897885/comments?status=P 然后我们分析一下这个链接的结构 http://movie.douban.com/subject/ 这一段可以看懂，那26892885这一数据是代表什么？先放下不表。 /comments?status=P这里不用讲，就是评论，？好后面只要学过的网页的应该能知道是参数 再随便进入另外一个电影的评论区 https://movie.douban.com/subject/30382416/comments?status=P 与上面电影的链接对比 https://movie.douban.com/subject/26897885/comments?status=P 我们可以发现，这中间这串数字代表的应该就是电影的id 二、爬取评论数据首先，我们将要用到的库引入 12345import urllib.requestfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSoupfrom random import randintimport time urllib.request是用来向服务器发送请求获取网页数据的 bs4 用于解析网页结构 randint、time 主要使用其中的sleep函数，防止电脑爬取的过快，被服务器识别出，被封IP，用于反扒 123456789101112131415class get_comments: def __init__(self, save_name): self.save_name = save_name self.url_pre = &#x27;https://movie.douban.com/subject/26897885/comments?status=P&#x27; self.headers = &#123; &#x27;Host&#x27;: &#x27;movie.douban.com&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;Cookie&#x27;: &#x27;个人cookie数据&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,&#x27; &#x27;likeGecko)Chrome/96.0.4664.45Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://www.douban.com/&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9&#x27;, &#125; 这里先初始化后面会使用到的参数，save_name 顾名思义，就是保存的名字， url_pre则是前面的评论数据的请求网址；headers 则是我们伪装成流浪器，除cookie外，大同小异，cookie则是每台机器都不同 现在来定义数据获取函数 12345def get_data(self): req = urllib.request.Request(self.url_pre, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) 先向服务器请求数据，并将其编码成utf-8的格式 数据拿到后如何获取我要的数据呢？ 我们先print获取到的数据 可以看到，返回的就是html数据。 1comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) 这里我们直接获取到所有评论内容，find_all(‘div’,’comment-item’)返回的是一个列表 先打印一下，看看内容 可以看到，列表元素还是一段一段的html的数据，这肯定不是我们所需要的数据 前面我们不是查看了网页结构嘛 这些标注出来的就是我们需要的，对于每一评论的数据 于是，我们遍历列表，对每条数据进行处理,并对数据进行储存 12345678910if len(comments_list) != 0: for i in comments_list: evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot;else: print(&quot;爬取失败!&quot;) 这里我先做一个处理，先判断一下comment_list 是否为空，别面出现一些不可预知的问题，导致了为爬取到，再进行遍历 这样，就对每调评论的信息提取出来了，具体代码我就解释了。 但是，这样不行，这样数据只是在内存中，而我们需要保存下来我们要的数据，添加写数据的步骤 这里我们将前面的代码整合 123456789101112131415161718192021222324252627def get_data(self): f = open(self.save_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) f.truncate() # 清空文件 f.write(&quot;id 时间 点赞 星级 评论\\n&quot;) print(&quot;正在获取评论...&quot;) # 先爬取第一页内容 url = self.url_pre req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) print(soupComment) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) print(comments_list) if len(comments_list) != 0: for i in comments_list: evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; f.write(strings) f.close() #打开文件后还要关闭文件 else: print(&quot;爬取失败!&quot;) 到这里，我们就完成了对一个网页的内容爬取，但是光爬一页数据一般来讲是没有用的 三、翻页爬取——爬取更多页怎么爬取下一页呢？ 我们点击下一页 可以看到网页连接多了一段 第一页：https://movie.douban.com/subject/26897885/comments?status=P 第二页：https://movie.douban.com/subject/26897885/comments?start=20&amp;limit=20&amp;status=P&amp;sort=new_score 第三页：https://movie.douban.com/subject/26897885/comments?start=40&amp;limit=20&amp;status=P&amp;sort=new_score 。。。。。。 可以发现就是连接改变了 这时候，是不是我们可以考虑更改请求url的不同来进行处理，一种方式是，把pre_url 改掉，然后使用后面的，每次请求时调整start这个参数，以获取不同页的评论内容。 不过这里我们不这么做，我们怎么做呢？ 我们再查看下一页按钮的网页结构 可以发现，a标签内的href 链接不就是第二页第三页等等改变的数据嘛？ 于是乎，我们可以这样处理 对__init__进行修改 12345def __init__(self, save_name): self.save_name = save_name self.url_pre = &#x27;https://movie.douban.com/subject/26897885/comments?status=P&#x27; self.next = &quot;&quot; .... 将请求代码也改为 12url = self.url_pre + self.nextreq = urllib.request.Request(url, headers=self.headers) 在遍历完comment_list后，获取一下self.next 123456def get_data(self): .... f.close() #打开文件后还要关闭文件 self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) 接着，我们再进行翻页处理 当有next的时候，就继续获取继续写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def get_data(self): f = open(self.save_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) f.truncate() # 清空文件 f.write(&quot;id 时间 点赞 星级 评论\\n&quot;) print(&quot;正在获取评论...&quot;) # 先爬取第一页内容 url = self.url_pre + self.next req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) print(soupComment) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) print(comments_list) if len(comments_list) != 0: for i in comments_list: evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; f.write(strings) # print(id,time,vote,evaluation,content) # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) # 如果有下一页 while self.next is not None: time.sleep(randint(1, 10)) print(&quot;翻页&quot;) url = self.url_pre + self.next req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) if len(comments_list) != 0: for i in comments_list: evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; f.write(strings) else: print(&quot;爬取失败!&quot;) f.close() 这时候，爬完了，我们运行测试一下（笔者这里测试的url 是 https://movie.douban.com/subject/26588308/comments） 结果一发现，诶，怎么回事啊，都还没有翻页，就开始报错 不对啊，怎么评价星级这一条怎么会为空呢？ 检查一下代码，再运行一下，还是不行，于是 我们从头开始，再查看网页结构 诶，发现 怎么有一条评论没有星级评价，于是乎，我们再次修改，以处理这个bug 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def get_data(self): f = open(self.save_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) f.truncate() # 清空文件 f.write(&quot;id 时间 点赞 星级 评论\\n&quot;) print(&quot;正在获取评论...&quot;) # 先爬取第一页内容 url = self.url_pre + self.next req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) # print(soupComment) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) # print(comments_list) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) # print(id,time,vote,evaluation,content) # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) # 如果有下一页 while self.next is not None: time.sleep(randint(1, 10)) print(&quot;翻页&quot;) url = self.url_pre + self.next try: req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: # 找不到 evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; f.write(strings) # print(id,time,vote,evaluation,content)d # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) f.close() 我们再次测试： 会发现，当爬取到20页时，会出现一个错误： httperror 这不是我们的问题，这个是豆瓣设置的，如果要看20页以后的评论数据就需要登录了，这里笔者并没有对这个进行处理 我们可以对其稍微处理一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def get_data(self): f = open(self.save_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) f.truncate() # 清空文件 f.write(&quot;id 时间 点赞 星级 评论\\n&quot;) print(&quot;正在获取评论...&quot;) # 先爬取第一页内容 url = self.url_pre + self.next req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) # print(id,time,vote,evaluation,content) # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) # 如果有下一页 while self.next is not None: time.sleep(randint(1, 10)) print(&quot;翻页&quot;) url = self.url_pre + self.next try: req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: # 找不到 evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; f.write(strings) # print(id,time,vote,evaluation,content)d # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) except HTTPError: print(&quot;网络连接错误！！！ 或者当前已爬取20页评论数据，更多需要登录爬取&quot;) break f.close() 四、进阶——根据用户输入的电影名搜索对应的电影评论数据前面在查看网页结构的的时候我们已经知道，对于不同的电影，我们只需要修改一下电影id就可以获取到不同电影的评论数据 那怎么获取电影id呢？ 根据爬虫的逻辑，我们先找到搜索链接， 搜索芬奇 对应网址：https://search.douban.com/movie/subject_search?search_text=%E8%8A%AC%E5%A5%87&amp;cat=1002 搜索毒液2 对应网址 https://search.douban.com/movie/subject_search?search_text=%E6%AF%92%E6%B6%B22&amp;cat=1002 这里可以知道搜索参数的就是text= 到 &amp;之间的数据，其实就是对应中文的urlencode。 再查看网页结构： 可以发现这个搜索出来的结果对应的第一个电影里的subject_id就是我们需要的； 于是我们按照步骤走，不难发现明明浏览器中显示有这些数据，为什么我爬取出来的就没找到这些数据呢？ 这里是由于搜索结构式动态返回的，是动态的，直接向服务器请求，我们无法获得此数据。 这里我们做另一种可行方式，也有其他方式，读者可自行实现。 我们引入selenium库（一个模拟浏览器的库） 模拟浏览器请求数据，并获取我们需要的数据,并且修改一下默认的 self.url_pre 123456789101112131415def getMovieID(self): &quot;&quot;&quot;:arg 运行此函数需要，检查电脑是否有浏览器的对应chromedrive， 运行的时候会打开一个浏览器页面，不能关闭！！！ &quot;&quot;&quot; self.movie_name = input(&quot;请输入你要爬取的电影名：&quot;) # 绿皮书 url = self.search_url + urlencode(&#123;&quot;q&quot;: self.movie_name&#125;) driver = webdriver.Chrome() # 模拟浏览器行为，以获得动态数据 driver.get(url) content = BeautifulSoup(driver.page_source, &#x27;html.parser&#x27;) temp = content.find(&#x27;a&#x27;, &#x27;nbg&#x27;).get(&quot;onclick&quot;).split(&quot;,&quot;) self.moveID = temp[-2].split(&#x27;:&#x27;)[1].strip(&quot; &quot;) self.url_pre = &#x27;https://movie.douban.com/subject/%s/comments&#x27; % str(self.moveID) self.save_name = self.movie_name + self.save_name 五、补充这次的爬虫，我认为并不完美，譬如：搜索出来的电影第一个就一定是我们输入的需要的电影嘛，这里可以进一步处理，通过打印出来我们搜索的电影列表信息（电影名，电影导演，主演，电影类型，这些都可通过爬虫获取到，不用到详情页面），再让用户进行选择；又譬如如果我要获取超过20页评论数据，我要怎么做，是否可以也向爬取电影id那样，模拟流浪器登录，然后再继续数据的爬取？ 六、全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# -*- coding: utf-8 -*-# @Author : w# @Time : 2021/11/23 8:14# @environment:PyCharmimport urllib.requestfrom urllib.error import HTTPErrorfrom urllib.parse import urlencodefrom selenium import webdriver # 获取电影id,搜索内容为动态数据from bs4 import BeautifulSoupfrom random import randintimport timeclass get_comments: def __init__(self, save_name): self.moveID = None self.movie_name = None self.save_name = save_name self.search_url = &#x27;https://www.douban.com/search?cat=1002&amp;&#x27; self.url_pre = &#x27;https://movie.douban.com/subject/26588308/comments&#x27; self.next = &#x27;&#x27; self.headers = &#123; &#x27;Host&#x27;: &#x27;movie.douban.com&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;Cookie&#x27;: &#x27;cookeis&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,&#x27; &#x27;likeGecko)Chrome/96.0.4664.45Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://www.douban.com/&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9&#x27;, &#125; def getMovieID(self): &quot;&quot;&quot;:arg 运行此函数需要，检查电脑是否有浏览器的对应chromedrive， 运行的时候会打开一个浏览器页面，不能关闭！！！ &quot;&quot;&quot; self.movie_name = input(&quot;请输入你要爬取的电影名：&quot;) # 绿皮书 url = self.search_url + urlencode(&#123;&quot;q&quot;: self.movie_name&#125;) driver = webdriver.Chrome() # 模拟浏览器行为，以获得动态数据 driver.get(url) content = BeautifulSoup(driver.page_source, &#x27;html.parser&#x27;) temp = content.find(&#x27;a&#x27;, &#x27;nbg&#x27;).get(&quot;onclick&quot;).split(&quot;,&quot;) self.moveID = temp[-2].split(&#x27;:&#x27;)[1].strip(&quot; &quot;) self.url_pre = &#x27;https://movie.douban.com/subject/%s/comments&#x27; % str(self.moveID) self.save_name = self.movie_name + self.save_name def get_data(self): f = open(self.save_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) f.truncate() # 清空文件 f.write(&quot;id 时间 点赞 评论\\n&quot;) print(&quot;正在获取评论...&quot;) # 先爬取第一页内容 url = self.url_pre + self.next req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) # print(soupComment) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) # print(comments_list) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; # print(strings) f.write(strings) # print(id,time,vote,evaluation,content) # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) # 如果有下一页 while self.next is not None: time.sleep(randint(1, 10)) print(&quot;翻页&quot;) url = self.url_pre + self.next try: req = urllib.request.Request(url, headers=self.headers) req = urllib.request.urlopen(req) content = req.read().decode(&#x27;utf-8&#x27;) soupComment = BeautifulSoup(content, &#x27;html.parser&#x27;) comments_list = soupComment.find_all(&#x27;div&#x27;, &#x27;comment-item&#x27;) if len(comments_list) != 0: for i in comments_list: try: # 用于防止出现有的评论有评论内容但是没有对电影进行星级评分 evaluation = i.find(&#x27;span&#x27;, &#x27;rating&#x27;).get(&#x27;title&#x27;) # 推荐 还行 较差 评价等级 except AttributeError: # 找不到 evaluation = &quot;&quot; ids = i.find(&#x27;input&#x27;, attrs=&#123;&#x27;type&#x27;: &#x27;hidden&#x27;&#125;).get(&#x27;value&#x27;) # 评论id times = i.find(&#x27;span&#x27;, &#x27;comment-time&#x27;).get(&#x27;title&#x27;) # 评论时间 vote = i.find(&#x27;span&#x27;, &#x27;votes&#x27;).getText() # 点赞数 content = i.find(&#x27;span&#x27;, &#x27;short&#x27;).getText().strip(&quot;\\n&quot;) # 评论内容 if len(evaluation) != 0: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; &quot; + evaluation + &quot; &quot; + content + &quot;\\n&quot; f.write(strings) else: strings = ids + &quot; &quot; + times + &quot; &quot; + vote + &quot; 该用户没有进行评价 &quot; + content + &quot;\\n&quot; f.write(strings) # print(id,time,vote,evaluation,content)d # 获取下一页对应的url self.next = soupComment.find(&#x27;a&#x27;, attrs=&#123;&quot;data-page&quot;: &quot;next&quot;&#125;).get(&#x27;href&#x27;) else: print(&quot;爬取失败!&quot;) except HTTPError: print(&quot;网络连接错误！或者 当前已经爬取了20页，后续爬取需要登录后才能继续。!&quot;) break f.close()if __name__ == &#x27;__main__&#x27;: a = get_comments(&#x27;test.txt&#x27;) a.getMovieID() a.get_data() le","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.whkblog.work/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.whkblog.work/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"wifi","slug":"wifi","date":"2021-11-27T03:27:21.000Z","updated":"2021-12-26T07:47:51.097Z","comments":true,"path":"2021/11/27/wifi/","link":"","permalink":"https://www.whkblog.work/2021/11/27/wifi/","excerpt":"","text":"概况前几天被同学问怎么抓包校园网，他想做一个自动登录校园网的脚本，然后昨天上linux我实验提前做完了，就没事干写两个python自动连接wifi并且登录校园网的脚本 实现想法开始想法一开始我的想法是，直接向服务器发送一个数据包，是关于登hahha录的，也就是在点击登录后，浏览器发送的数据包；这个同时也是我那个同学的想法 这个实现，能力不足，计网没学到家（嗯~ o(￣▽￣)o）；我那个同学抓了好几次包，都不知道发送的数据是啥，这里是指可以抓到数据包， 我也可以，就是我看不懂数据包内容，一串16进制的数据，我分不清那些数据段是自己设置的数据段 实现想法我的想法是模拟人的操作，打开浏览器，然后输入内容，再点击登录，这一步我是使用python selenium库实现的； 再要考虑的一个问题是，电脑自动连接wifi,这个可以使用pywifi来通过控制电脑wifi的连接来确保一定会连接上校园网 最后再将写好的代码打包成exe文件，并且将文件设置为开机自启动，在学校期间，全都是使用校园网，并且我校校园网是全校覆盖 实现现在python环境下创建一个py文件 初始化新建一个class 类,并初始化一些变量 123456789101112class test: def __init__(self, userID, pwd): self.login = &#x27;url&#x27; #校园网登录网址 self.id = userID # 校园网登录ID self.password = pwd # 校园网登录pwd self.headers = &#123; #请求头定义 &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,&#x27; &#x27;likeGecko)Chrome/96.0.4664.45Safari/537.36&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9&#x27;, &#125; wifi控制函数1234567891011121314151617181920212223242526272829def get_wifi(self): wifi = pywifi.PyWiFi() # 扫描wifi驱动，并会输出 ifaces = wifi.interfaces()[0] print(ifaces.name()) # 不一定是必要，可以不输出 ifaces.disconnect() # 断开网卡连接 sleep(1) profile = pywifi.Profile() # 创建wifi连接文件 profile.ssid = &#x27;wifi_name&#x27; # 校园网的wifi密码 &quot;&quot;&quot; 我校校园网是开放的，登录的 有需要的话，也可以改为自己想自动连接的wifi; 不过要是在家的话，这个脚本又鸡肋了，毕竟家里wifi一般来讲不会断，而不是像校园网会断网orz # 网卡的开放状态 | auth - AP的认证算法 profile.auth = const.AUTH_ALG_OPEN # wifi的加密算法，一般wifi 加密算法时wps #选择wifi加密方式 akm - AP的密钥管理类型 profile.akm.append(const.AKM_TYPE_WPA2PSK) # 加密单元 /cipher - AP的密码类型 profile.cipher = const.CIPHER_TYPE_CCMP # 调用密码 /wifi密钥 如果无密码，则应该设置此项CIPHER_TYPE_NONE profile.key = pwd &quot;&quot;&quot; ifaces.remove_all_network_profiles() # 删除所有AP配置文件（为了下一次新的连接）： tmp_profile = ifaces.add_network_profile(profile) # 加载新的连接文件 ifaces.connect(tmp_profile) sleep(2) if not self.isConnected(ifaces): sleep(5) # 若未成功，等待5秒后再看下是否成功连接了 self.isConnected(ifaces) 这里面还有一个isConnected函数，是用来判断wifi是否连接成功 如果连接成功，将会调用自动登录模块，连接不成功会输出连接失败 下面是isConnected函数 12345678def isConnected(self, ifaces=None): if ifaces.status() == pywifi.const.IFACE_CONNECTED: print(&quot;成功连接&quot;) self.test_login() return True else: print(&quot;失败&quot;) return False 自动登录自动登录模块用到的selenium库，使用了webdriver()，如果你也使用这个的话，需要注意一点的就是，需要下载一个驱动这里我就不写， 我是chorme浏览器，也可改成fox,edge等，估计都得安装这个chromedriver.exe类似的东西，我没有测试 可以参考这个连接https://blog.csdn.net/weixin_42403127/article/details/85255891 这里有三个find_elemet 是针对我校校园网的的,不同的公开网络登录需要特殊设置 12345678910def test_login(self): driver = webdriver.Chrome() driver.get(self.login) # 驱动浏览器到这个网页 username = driver.find_element(By.ID, &quot;username&quot;) #找到登录表单 pwd = driver.find_element(By.ID, &quot;password&quot;) username.send_keys(self.id) # 向表单中填入数据 pwd.send_keys(self.password) elem = driver.find_element(By.ID, &quot;login&quot;) # 找到登录按钮 elem.click() #点击登录 sleep(2) # 停止两秒，等待返回状态 运行12345if __name__ == &#x27;__main__&#x27;: l = test(&#x27;username&#x27;, &#x27;pwd&#x27;) sleep(3) l.get_wifi() 现在编辑器运行一下，测试一下是否成功，出错的话好再改 打包成exe文件前面的代码都没包含引入库的内容，写在这里；为了方便打包，应该把用了的函数引入，而不是把所有的包内容都引入，那样容易导致打包的内容多，exe打 1234import pywififrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom time import sleep 打开命令行，进入到当前py文件所在文件夹，输入 1pyinstaller -F xx.py 这里xx.py是指你的py文件 使用的是-F命令，这样只会生成一个独立文件，不然会带好多东西3 出现上面这个就代表成功。 同时在py文件下会出现两个文件夹，一个build一个dist文件，exe文件在dist文件当中 设置为开机自启键盘win+r，输入shell:startup,会打开一个文件夹 将dist文件内exe文件创建一个快捷方式，然后将快捷方式剪切到刚打开的文件夹中，即完成了开机自动这个exe 其他这个脚本还有挺多问题的 譬如，要是wifi没有连接成功怎么办，以及登录失败怎么处理这些都没有处理，不过就目前而言，凑合用吧。 就这样。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.whkblog.work/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/tags/python/"},{"name":"没事做的","slug":"没事做的","permalink":"https://www.whkblog.work/tags/%E6%B2%A1%E4%BA%8B%E5%81%9A%E7%9A%84/"}]},{"title":"OS算法","slug":"OS算法","date":"2021-05-09T12:42:49.000Z","updated":"2021-11-30T02:37:36.938Z","comments":true,"path":"2021/05/09/OS算法/","link":"","permalink":"https://www.whkblog.work/2021/05/09/OS%E7%AE%97%E6%B3%95/","excerpt":"","text":"此文写的是操作系统的算法（java版） 读前须知1、文中算法，都是为了完成作业而写的，存在较多BUG, 算法最后带一个测试数据，就是实验要求的测试数据，并不全，算法本身问题较多，很多可能边界数据不能运行，会出现bug,例如进程调度里面，一个进程结束了，新的进程还未到达这一类情况就并没有写解决方法。、 2、由于我不会java,但是实验老师说用java加分，所有边学边写的，代码有些不规范敬请谅解。 3、由于java不太会，许多算法，都是在前任的基础之上写的；当然了，也有我完全我自己写的，不是所有的代码都符合老师的要求。在此感谢哪些人(≧∇≦)ﾉ 进程调度算法（单道）FCFS主要思想​ 先来先服务的调度算法：最简单的调度算法，既可以用于作业调度 ，也可以用于程序调度，当作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，优先从后备队列中，选择一个或多个位于队列头部的作业，把他们调入内存，分配所需资源、创建进程，然后放入“就绪队列”,直到该进程运行到完成或发生某事件堵塞后，进程调度程序才将处理机分配给其他进程。 Java具体实现数据结构1234567891011121314151617public class Shuru &#123; int id; String name; //进程名 time arrve; //到达就绪时间 int zx;//执行时间 int grad; time start;//开始时间 time end;//完成时间 int zz; //周转时间=完成时间-到达时间 double zzxs; //周转系数 =周转时间/执行时间&#125;public class time &#123; int hour; int mintes;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.util.Scanner;public class FCFS &#123; public void SortByTime(Shuru shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrve.hour*60+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*60+shuru[i].arrve.mintes) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void SortBygrade(Shuru shuru[])&#123; for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i + 1; j &lt; shuru.length; j++) &#123; if (shuru[j].grad &lt; shuru[i].grad) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void fcfs(int n) &#123;// Scanner scan = new Scanner(System.in); Shuru shuru[] = new Shuru[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); shuru[i].id = Integer.parseInt(sa[0]); shuru[i].name = sa[1]; shuru[i].grad = Integer.parseInt(sa[2]); String[] time = sa[3].split(&quot;:&quot;); shuru[i].arrve.hour = Integer.parseInt(time[0]); shuru[i].arrve.mintes = Integer.parseInt(time[1]); shuru[i].zx = Integer.parseInt(sa[4]); shuru[i].start.hour = shuru[i].start.mintes = 0; shuru[i].end.hour = shuru[i].end.mintes = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; &#125; System.out.println(&quot;**********************************************************&quot;); SortByTime(shuru); calculate(shuru,n); SortBygrade(shuru); calculate(shuru,n); &#125; public void calculate(Shuru shuru[],int n)&#123; /*第一个执行的程序*/ shuru[0].start.hour = shuru[0].arrve.hour; shuru[0].start.mintes = shuru[0].arrve.mintes; //计算结束时间 if ((shuru[0].start.mintes + shuru[0].zx) &gt;= 60) &#123; shuru[0].end.hour = shuru[0].start.hour + 1; shuru[0].end.mintes = (shuru[0].start.mintes + shuru[0].zx - 60); &#125; else &#123; shuru[0].end.hour = shuru[0].start.hour; shuru[0].end.mintes = (shuru[0].start.mintes + shuru[0].zx); &#125; //计算周转时间 if (shuru[0].end.hour == shuru[0].start.hour) &#123; shuru[0].zz = (shuru[0].end.mintes - shuru[0].arrve.mintes); &#125; else &#123; shuru[0].zz = ((shuru[0].end.hour - shuru[0].arrve.hour)*60 + shuru[0].end.mintes - shuru[0].arrve.mintes); &#125; //计算周转系数 shuru[0].zzxs = (float)shuru[0].zz/shuru[0].zx; /*计算除去第一个进程外的其他进程*/ for (int i = 1; i &lt; n; i++) &#123; shuru[i].start.hour = shuru[i - 1].end.hour; shuru[i].start.mintes = shuru[i - 1].end.mintes; //计算结束时间 if ((shuru[i].start.mintes + shuru[i].zx) &gt;= 60) &#123; shuru[i].end.hour = (shuru[i].start.hour + 1); shuru[i].end.mintes = (shuru[i].zx + shuru[i].start.mintes - 60); &#125;else &#123; shuru[i].end.hour = shuru[i].start.hour; shuru[i].end.mintes = shuru[i].start.mintes + shuru[i].zx; &#125; //计算周转时间 if (shuru[i].end.hour == shuru[i].arrve.hour) &#123; shuru[i].zz = shuru[i].end.mintes - shuru[i].arrve.mintes; &#125;else&#123; shuru[i].zz = (shuru[i].end.hour - shuru[i].arrve.hour) * 60 + shuru[i].end.mintes - shuru[i].arrve.mintes; &#125; shuru[i].zzxs = (float)shuru[i].zz / shuru[i].zx; &#125; System.out.println(&quot;进程id\\t进程名\\t优先级\\t执行时间\\t\\t到达时间\\t\\t开始时间\\t\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); int sumzz=0; float sumzzxs=0; for(int i=0;i&lt;n;i++)&#123; show(shuru[i]); sumzz += shuru[i].zz; sumzzxs += shuru[i].zzxs; &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n);// &#125; public void show (Shuru shuru)&#123; System.out.printf(&quot;%d\\t%s\\t\\t%d\\t\\t%d（分钟）\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs); &#125; public static void main(String[]args)&#123; FCFS j = new FCFS(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); j.fcfs(n); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*实验数据5001 p1 1 9:40 205004 p4 4 10:10 105005 p5 3 10:05 305002 p2 3 9:55 155003 p3 2 9:45 25 */ SJF主要思想同先来先服务算法一样的功能，与之不同的是，短作业优先算法，是以作业运行时间长短排序； 1、在已到达的作业中，选择作业时间最短的进程 2、当前进程结束后，再在已到达的进程中选择运行时间最短的进程进入CPU进行执行 具体实现数据结构与FCFS数结构一样 Java具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200import java.util.Scanner;public class SJF &#123; public void SortByTime(Shuru shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrve.hour*60+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*60+shuru[i].arrve.mintes) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void SortBygrade(Shuru shuru[])&#123; for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i + 1; j &lt; shuru.length; j++) &#123; if(shuru[j].grad &gt; shuru[i].grad)&#123; Shuru temp = shuru[i]; shuru[i] = shuru[j]; shuru[j] = temp; &#125; &#125; &#125; &#125; public void init(Shuru shuru[])&#123; for(int i=0;i&lt;shuru.length;i++)&#123; shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); shuru[i].id = 0; shuru[i].name = &quot;nothing&quot;; shuru[i].grad = 0; shuru[i].zx = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; shuru[i].start.hour = 0; shuru[i].start.mintes = 0; shuru[i].end.hour = 0; shuru[i].end.mintes = 0; shuru[i].arrve.hour = 0; shuru[i].arrve.mintes = 0; &#125; &#125; public boolean find(Shuru shuru[],Shuru shuru1)&#123; for(int i=0;i&lt;shuru.length;i++)&#123; if(shuru[i].id == shuru1.id)&#123; return true; &#125; &#125; return false; &#125; public void sjf(int n)&#123; Scanner scan = new Scanner(System.in); Shuru shuru[] = new Shuru[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间:\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); shuru[i].id = Integer.parseInt(sa[0]); shuru[i].name = sa[1]; shuru[i].grad = Integer.parseInt(sa[2]); String[] time = sa[3].split(&quot;:&quot;); shuru[i].arrve.hour = Integer.parseInt(time[0]); shuru[i].arrve.mintes = Integer.parseInt(time[1]); shuru[i].zx = Integer.parseInt(sa[4]); shuru[i].start.hour = shuru[i].start.mintes = 0; shuru[i].end.hour = shuru[i].end.mintes = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; &#125; System.out.println(&quot;**********************************************************&quot;); Shuru shuruans[] = new Shuru[n]; init(shuruans); Shuru shurutemp[] = new Shuru[n]; init(shurutemp); //先时间排序 SortByTime(shuru); //按优先级进行执行 System.out.println(&quot;进程id\\t进程名\\t优先级\\t执行时间\\t\\t到达时间\\t\\t开始时间\\t\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); calculate(shuru[0],shuru[0].arrve.hour,shuru[0].arrve.mintes); //执行第一个到达的进程 int count=0; shuruans[count] = shuru[0]; for(int k=0;k&lt;n-1;k++) &#123; /* 从第一次执行完成后，每次执行时， 先从已经到达的进程中选择优先级最高的进程进行执行； 执行完后再次选择，直到所有进程都执行完毕。 */ init(shurutemp);//作为中间变量，储存筛选出来的进程 for (int i = 0; i &lt; shuru.length; i++) &#123; if (shuru[i].arrve.hour*60+shuru[i].arrve.mintes &lt;= shuruans[count].end.hour*60+shuruans[count].end.mintes &amp;&amp; !find(shuruans,shuru[i]) ) &#123; shurutemp[i] = shuru[i]; &#125; if(i==shuru.length-1 &amp;&amp; shurutemp[0].id==0)&#123; shurutemp[0] = shuru[count+1]; &#125; &#125; SortBygrade(shurutemp);//按优先级排序 if(count&lt;n)&#123; if(shurutemp[0].arrve.hour*60+shurutemp[0].arrve.mintes &lt;= shuruans[count].end.hour*60+shuruans[count].end.mintes) &#123; calculate(shurutemp[0], shuruans[count].end.hour, shuruans[count].end.mintes); &#125; else&#123; calculate(shurutemp[0],shurutemp[0].arrve.hour,shurutemp[0].arrve.mintes); &#125; count+=1; shuruans[count] = shurutemp[0]; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; show(shuru[i]); &#125; System.out.printf(&quot;------------------------------------------------\\n&quot;); //计算带权平均与输出 for(int i=0;i&lt;n;i++)&#123; show(shuruans[i]); &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n); &#125; public void calculate(Shuru shuru,int TimeHour,int TimeMinte)&#123; shuru.start.hour = TimeHour; shuru.start.mintes = TimeMinte; //计算结束时间 if ((shuru.start.mintes + shuru.zx) &gt;= 60) &#123; shuru.end.hour = (shuru.start.hour + 1); shuru.end.mintes = (shuru.zx + shuru.start.mintes - 60); &#125;else &#123; shuru.end.hour = shuru.start.hour; shuru.end.mintes = shuru.start.mintes + shuru.zx; &#125; //计算周转时间 if (shuru.end.hour == shuru.arrve.hour) &#123; shuru.zz = shuru.end.mintes - shuru.arrve.mintes; &#125;else&#123; shuru.zz = (shuru.end.hour - shuru.arrve.hour) * 60 + shuru.end.mintes - shuru.arrve.mintes; &#125; shuru.zzxs = (float)shuru.zz / shuru.zx; &#125; public void show (Shuru shuru)&#123; System.out.printf(&quot;%d\\t%s\\t\\t%d\\t\\t%d（分钟）\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs); &#125; public static void main(String[]args)&#123; SJF j = new SJF(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); j.sjf(n); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*5001 p1 1 9:40 205004 p4 4 10:10 105005 p5 3 10:05 305002 p2 3 9:55 155003 p3 2 9:45 25 *//*1001 p1 1 10:00 201002 p2 2 9:20 651003 p3 2 10:25 501004 p4 3 8:10 101005 p5 2 7:40 201006 p6 1 11:20 1001007 p7 1 10:30 120 */ 时间片轮转算法主要思想设置时间片段，每次进入CPU的进程，只允许运行时间片段长度的时间，时间片用完后，解除CPU占用，进入当前就绪队列的最后； CPU再选入就绪队列中最前面的进程调入CPU运行；如此反复，直到所有进程都运行完毕。 Java具体实现数据结构123456789101112131415161718192021222324252627//数据结构定义class Time &#123; int hour; int mintes; public static void timePlus(Time begin, int time) &#123; begin.hour = (begin.hour + (int) (begin.mintes + time) / 60); begin.mintes = ((begin.mintes + time) % 60); &#125; public static int timesub(Time begin,Time end)&#123; return (end.hour*60+end.mintes - begin.hour*60+begin.mintes); &#125;&#125;class Process&#123; int id; String name; //进程名 int zx;//执行时间 Time arrive; //到达就绪时间 Time start;//每轮开始开始时间 Time first;//首次执行时间 int have_finished;//已完成时间 Time arr;//每轮到达时间 Time end;//完成时间 int zz; //周转时间=完成时间-到达时间 double zzxs; //周转系数 =周转时间/执行时间 int flag;&#125; 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273public class RoundRobin &#123; public void SortByTime(Process shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrive.hour*60+shuru[j].arrive.mintes &lt; shuru[i].arrive.hour*60+shuru[i].arrive.mintes) &#123; Process t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void insert(Process a[],Process b)&#123; int n = a.length; Process temp; temp = b; if(find(b,a)) remove(a,b); for (int j = 0; j &lt; n; j++) &#123; if (a[j].name == &quot;nothing&quot; || j==n-1)&#123; a[j] = temp;//新增 a[j].start.hour = 0; a[j].start.mintes = 0; break; &#125; &#125; &#125; public void remove(Process A[],Process a)&#123; int len = A.length; for (int i=0;i&lt;len;i++)&#123; if (A[i].id==a.id)&#123; for (int j=i;j&lt;len-1;j++)&#123; A[j] = A[j+1]; &#125; &#125; break; &#125;// if (A[len-1].id==A[len-2].id)&#123;// A[len - 1].id = 0;// A[len - 1].name = &quot;nothing&quot;;// A[len - 1].zx = 0;// A[len - 1].arrive.hour = 0;// A[len - 1].arrive.mintes = 0;// A[len - 1].start.hour = 0;// A[len - 1].start.mintes = 0;// A[len - 1].have_finished = 0;// A[len - 1].arr.hour = 0;// A[len - 1].arr.mintes = 0;// A[len - 1].end.hour = 0;// A[len - 1].end.mintes = 0;// A[len - 1].zz = 0;// A[len - 1].zzxs = 0;// A[len - 1].flag = -1;// &#125; &#125; public void init(Process input[])&#123; for(int i=0;i&lt;input.length;i++)&#123; input[i] = new Process(); input[i].id = 0; input[i].name = &quot;nothing&quot;; input[i].zx = 0; input[i].arrive = new Time(); input[i].arrive.hour = 0; input[i].arrive.mintes = 0; input[i].start = new Time(); input[i].start.hour = 0; input[i].start.mintes = 0; input[i].first = new Time(); input[i].have_finished = 0; input[i].arr = new Time(); input[i].arr.hour = 0; input[i].arr.mintes = 0; input[i].end = new Time(); input[i].end.hour = 0; input[i].end.mintes = 0; input[i].zz = 0; input[i].zzxs = 0; input[i].flag = -1; &#125; &#125; public void show (Process process[]) &#123; int sumzz=0; double sumzzxs=0; int n = process.length; System.out.println(&quot;进程id\\t进程名\\t到达时间\\t执行时间\\t\\t首次开始时间\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); for (int i = 0; i &lt; n; i++) &#123; process[i].zz = ((process[i].end.hour*60+process[i].end.mintes)-(process[i].arrive.hour*60+process[i].arrive.mintes)); process[i].zzxs = (float)process[i].zz/process[i].zx; sumzz += process[i].zz; sumzzxs += process[i].zzxs; System.out.printf(&quot;%d\\t%s\\t\\t%02d:%02d\\t%d(分钟)\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;, process[i].id, process[i].name, process[i].arrive.hour, process[i].arrive.mintes, process[i].zx, process[i].first.hour, process[i].first.mintes, process[i].end.hour, process[i].end.mintes, process[i].zz, process[i].zzxs); &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n); &#125; public void showRun(Process process[], int n, Time now) &#123; System.out.println(&quot;第&quot;+n+&quot;执行和就绪队列&quot;); System.out.printf(&quot;当前时间: %02d :%02d\\n&quot;,now.hour,now.mintes); System.out.println(&quot;ID号\\t名字\\t到达时间\\t总执行时间(分钟)\\t当前开始时间\\t已完成时间\\t剩余时间(分钟)&quot;); for(int i=0;i&lt;process.length;i++)&#123; if (process[i].id!=0 &amp;&amp; process[i].name!=&quot;nothing&quot;) &#123; System.out.printf(&quot;%d\\t%s\\t%02d:%02d\\t%d（分钟）\\t\\t\\t%02d:%02d\\t%d(分钟)\\t\\t%d（分钟）\\n&quot;, process[i].id, process[i].name, process[i].arrive.hour, process[i].arrive.mintes, process[i].zx, process[i].start.hour, process[i].start.mintes, process[i].have_finished, (process[i].zx - process[i].have_finished)); &#125; &#125; &#125; public boolean sure(Process input[])&#123; int n=input.length; for(int j=0;j&lt;n;j++)&#123; if (input[j].flag!=1) &#123; return true; &#125; &#125; return false; &#125; public boolean find(Process process,Process A[])&#123; for(int i=0;i&lt;A.length;i++)&#123; if (process.id==A[i].id)&#123; return true; &#125; &#125; return false; &#125; public void calculate(Process A[],Time now,int time,Process B[])&#123; if (time&lt;=0)&#123; return; &#125; else &#123; int less; A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; /* 不可直接A.start = now,这只是建立索引，start与now会一同变化 */ less = A[0].zx - A[0].have_finished; //第一次执行进程 if (A[0].have_finished == 0) &#123; A[0].first.hour = now.hour; A[0].first.mintes = now.mintes; if (less &gt; time) &#123; //剩余未做完&gt;大于时间片 A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; A[0].have_finished += time; Time.timePlus(now, time); time = 0; &#125; else &#123; A[0].have_finished = A[0].zx; A[0].flag = 1; //表示做完了 A[0].end.hour = (now.hour + (int) (now.mintes + less) / 60); A[0].end.mintes = ((now.mintes + less) % 60); Time.timePlus(now, (time - less)); &#125; &#125; else &#123; if (less &gt; time) &#123; A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; A[0].have_finished += time; Time.timePlus(now, time); time = 0; &#125; else &#123; A[0].have_finished = A[0].zx; A[0].flag = 1; //表示做完了 A[0].end.hour = (now.hour + (int) (now.mintes + less) / 60); A[0].end.mintes = ((now.mintes + less) % 60); Time.timePlus(now, (time - less));// calculate(A, now, time,B); &#125; &#125; &#125; &#125; public void rr(int n,int Timeslice) &#123; Scanner scan = new Scanner(System.in); Process input[] = new Process[n]; Process temp[] = new Process[n]; Process ans[] = new Process[5]; //初始化 init(input); init(ans); init(temp); //输入进程 for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间:\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); input[i].id = Integer.parseInt(sa[0]); input[i].name = sa[1]; String[] time = sa[2].split(&quot;:&quot;); input[i].arrive.hour = Integer.parseInt(time[0]); input[i].arrive.mintes = Integer.parseInt(time[1]); input[i].zx = Integer.parseInt(sa[3]); &#125; SortByTime(input); int count=0,count_num=0,timeset; /* count用于计算已经完成了多少个进程 count_num 第几轮执行 */ Time now = new Time(); now.hour = input[0].arrive.hour; now.mintes = input[0].arrive.mintes; insert(temp,input[0]); while(sure(ans))&#123;// while(count_num&lt;20)&#123; count_num++; calculate(temp, now, Timeslice,ans); showRun(temp, count_num, now); for (int j=0;j&lt;n;j++)&#123; if (temp[j].flag==1 &amp;&amp; count&lt;5 &amp;&amp; !find(temp[j],ans))&#123; ans[count++] = temp[j]; remove(temp,temp[j]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123;//查找已经到达的程序 if (now.hour * 60 + now.mintes &gt; input[i].arrive.hour * 60 + input[i].arrive.mintes) &#123; if (!find(input[i], temp) &amp;&amp; !find(input[i],ans)) &#123; insert(temp, input[i]); &#125; &#125; &#125; insert(temp, temp[0]); &#125; show(ans); &#125; public static void main(String[]args)&#123; RoundRobin j = new RoundRobin(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); System.out.print(&quot;请输入时间片时间：\\n&quot;); int TimeSlice = s.nextInt(); j.rr(n, TimeSlice); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*5001 p1 9:40 205004 p4 10:10 105005 p5 10:05 305002 p2 9:55 155003 p3 9:45 25 */ 2021/5/9 21:00 今天就写到这，下次补充 HRRF主要思想主要思想就不写了，太麻烦了。。。这次是为了补充。。。具体自己可查吧 具体实现数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163mport java.util.Collections;import java.util.Scanner;import java.util.LinkedList;class Time&#123; int minute; int hour; public int getHour() &#123; return hour; &#125; public void setHour(int hour) &#123; this.hour = hour; &#125; public int getMinute() &#123; return minute; &#125; public void setMinute(int minute) &#123; this.minute = minute; &#125; public static Time timePlus(Time begin, int time) &#123; Time ans = new Time(); ans.hour = (begin.hour + (int) (begin.minute + time) / 60); ans.minute = ((begin.minute + time) % 60); return ans; &#125; public static int timesub(Time begin,Time end)&#123; return ((end.hour*60+end.minute) - (begin.hour*60+begin.minute)); &#125; public static boolean timecompare(Time a, Time b)&#123; if((a.hour*60+a.minute-b.hour*60+b.minute)&lt;=0)&#123; return true; &#125; return false; &#125;&#125;class Process implements Comparable&lt;Process&gt;&#123; String name;//名字 Time arrive;//入井时间 int zx;//执行时间 Time jobTime;//作业调度时间 int jobWait;//作业调度等待时间 Time processTime ;//进程调度时间 int processWait;//进程调度等待时间 Time finish;//完成时间 int zz;//周转时间 float zzxs;//带权周转系数 int finished;//标记作业完成 float response;//响应比 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getArrive() &#123; String s = String.format(&quot;%02d&quot;, arrive.hour) + &quot;:&quot;+String.format(&quot;%02d&quot;, arrive.minute); return s; &#125; public void setArrive(Time arrive) &#123; this.arrive = arrive; &#125; public int getZx() &#123; return zx; &#125; public void setZx(int zx) &#123; this.zx = zx; &#125; public String getJobTime() &#123; String s = String.format(&quot;%02d&quot;, jobTime.hour) + &quot;:&quot;+String.format(&quot;%02d&quot;, jobTime.minute); return s; &#125; public void setJobTime(Time jobTime) &#123; this.jobTime = jobTime; &#125; public String getJobWait() &#123; String s = String.format(&quot;%02d（分钟）&quot;, jobWait); return s; &#125; public void setJobWait(int jobWait) &#123; this.jobWait = jobWait; &#125; public String getProcessTime() &#123; String s = String.format(&quot;%02d&quot;, processTime.hour) + &quot;:&quot;+String.format(&quot;%02d&quot;, processTime.minute); return s; &#125; public void setProcessTime(Time processTime) &#123; this.processTime = processTime; &#125; public String getProcessWait() &#123; String s = String.format(&quot;%02d（分钟）&quot;, processWait); return s; &#125; public void setProcessWait(int processWait) &#123; this.processWait = processWait; &#125; public String getFinish() &#123; String s = String.format(&quot;%02d&quot;, finish.hour) + &quot;:&quot;+String.format(&quot;%02d&quot;, finish.minute); return s; &#125; public void setFinish(Time finish) &#123; this.finish = finish; &#125; public int getZz() &#123; return zz; &#125; public void setZz(int zz) &#123; this.zz = zz; &#125; public String getZzxs() &#123; String s = String.format(&quot;%.4f&quot;,zzxs); return s; &#125; public void setZzxs(float zzxs) &#123; this.zzxs = zzxs; &#125; public int getFinished() &#123; return finished; &#125; public void setFinished(int finished) &#123; this.finished = finished; &#125; public float getResponse() &#123; return response; &#125; public void setResponse(float response) &#123; this.response = response; &#125; @Override public int compareTo(Process a) &#123; return (this.arrive.getHour()*60+this.arrive.getMinute())-(a.arrive.getHour()*60+a.arrive.getMinute()); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class HRRF &#123; Scanner scan = new Scanner(System.in); private int processNums;//作业数 private LinkedList&lt;Process&gt; ProcessList,Finished; private void init()&#123; ProcessList = new LinkedList&lt;Process&gt;(); System.out.print(&quot;请输入你要创建的作业数：&quot;); processNums = scan.nextInt(); scan.nextLine(); System.out.println(&quot;请依次输入&quot;); System.out.println(&quot;作业名\\t入井时间\\t运行时间&quot;); for(int i=0;i&lt;processNums;i++)&#123; Process p = new Process(); String input = scan.nextLine(); String[] inputlist = input.split(&quot; &quot;); p.setName(inputlist[0]); Time time = new Time(); String[] timelist = inputlist[1].split(&quot;:&quot;); time.setHour(Integer.parseInt(timelist[0])); time.setMinute(Integer.parseInt(timelist[1])); p.setArrive(time); p.setZx(Integer.parseInt(inputlist[2])); Time sx = new Time(); p.setJobTime(sx); p.setProcessTime(sx); p.setFinish(sx); ProcessList.add(p); &#125; Collections.sort(ProcessList); &#125; private void showProcess()&#123; double zzsum=0,zzxssum=0; System.out.println(&quot;名字\\t\\t入井时间\\t运行时间\\t作业调度时间\\t作业调度等待时间\\t进程调度时间\\t进程调度等待时间\\t完成时间\\t周转时间\\t带权周转时间&quot;); for(int i=0;i&lt;Finished.size();i++)&#123; Process show = new Process(); show = Finished.get(i); System.out.println(show.getName()+&quot;\\t&quot;+show.getArrive()+&quot;\\t&quot;+show.getZx()+&quot;\\t\\t&quot;+ show.getJobTime()+&quot;\\t\\t\\t&quot;+show.getJobWait()+&quot;\\t&quot;+show.getProcessTime()+&quot;\\t\\t&quot;+show.getProcessWait()+&quot;\\t\\t&quot;+ show.getFinish()+&quot;\\t\\t&quot;+show.getZz()+&quot;\\t\\t&quot;+show.getZzxs()); zzsum += show.getZz(); zzxssum += show.zzxs; &#125; System.out.println(&quot;系统平均周转时间为：\\t\\t\\t\\t\\t\\t\\t\\t\\t&quot;+String.format(&quot;%.4f&quot;,zzsum/processNums)); System.out.println(&quot;系统带权平均周转时间为：\\t\\t\\t\\t\\t\\t\\t\\t&quot;+String.format(&quot;%.4f&quot;,zzxssum/processNums)); &#125; private Process find(Time now)&#123; LinkedList&lt;Process&gt; FindList; FindList = new LinkedList&lt;Process&gt;(); for(int i=0;i&lt;ProcessList.size();i++)&#123; if((ProcessList.get(i).getFinished()!=1) &amp;&amp; Time.timecompare(ProcessList.get(i).arrive,now))&#123; FindList.add(ProcessList.get(i)); &#125; &#125; for(int i=0;i&lt;FindList.size();i++)&#123; FindList.get(i).setResponse((1+Time.timesub(FindList.get(i).arrive,now)/FindList.get(i).getZx())); &#125; Process max = new Process(); float maxX= 0; for(int i=0;i&lt;FindList.size();i++)&#123; if(maxX &lt; FindList.get(i).getResponse())&#123; maxX = FindList.get(i).getResponse(); max = FindList.get(i); &#125; &#125; return max; &#125; private void calculate() &#123; Finished = new LinkedList&lt;Process&gt;(); Time now = new Time(); now.setHour(ProcessList.get(0).arrive.getHour()); now.setMinute(ProcessList.get(0).arrive.getMinute()); for (int i=0;i&lt;ProcessList.size();i++)&#123; Process need = find(now); need.setJobTime(now); need.setJobWait(Time.timesub(need.arrive,now)); need.setProcessTime(need.jobTime); need.setProcessWait(Time.timesub(need.jobTime,need.processTime)); now = Time.timePlus(now,need.getZx()); need.setFinish(now); need.setZz(Time.timesub(need.arrive,need.finish)); need.setZzxs((float)need.getZz()/need.getZx()); Finished.add(need); for (int j=0;j&lt;ProcessList.size();j++)&#123; if(ProcessList.get(j).getName().equals(need.getName()))&#123; ProcessList.get(j).setFinished(1); break; &#125; &#125; &#125; &#125; public void hrrf()&#123; init(); calculate(); showProcess(); &#125; public static void main(String[] args) &#123; HRRF h = new HRRF(); h.hrrf(); &#125;&#125; 2021/5/13 9:23 补充,银行家算法 银行家算法这个算法好像是不强制要求完成的，故此算法存在大问题的可能性较大（我不记得了o(￣▽￣)o） 主要思想我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 为保证资金的安全，银行家规定： (1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客； (2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量； (3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款； (4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金. Java具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285import jdk.management.resource.internal.inst.FileOutputStreamRMHooks;import javax.lang.model.element.NestingKind;import javax.print.attribute.standard.Finishings;import java.util.Scanner;public class Banker&#123;//BankerOfAlgorithm 银行家算法 int Max[][]; int Allocation[][]; int Need[][]; int Available[]; int Work[]; String name[]; int temp[]; int S = 100, P = 100; int safequeue[]; int Flag[]; int Request[]; Scanner sc; public Banker() &#123; int maxsize = 100; int Max[][] = new int[maxsize][maxsize]; int Allocation[][] = new int[maxsize][maxsize]; int Need[][] = new int[maxsize][maxsize]; int Available[] = new int[maxsize]; int Work[] = new int[maxsize]; String name[] = new String[maxsize]; int temp[] = new int[maxsize]; int S = 100, P = 100; int Flag[] = new int[maxsize]; int safequeue[] = new int[maxsize]; int Request[] = new int[maxsize]; &#125; public boolean iffinish()&#123; for (int i=0;i&lt;P;i++)&#123; for (int j=0;j&lt;S;j++)&#123; if (Need[i][j]!=0)&#123; return false; &#125; &#125; &#125; return true; &#125; public void Showdata() &#123; int i, j, k, l,temp=0;; System.out.println(&quot;进程名\\t\\t最大需求量\\t尚需求量\\t\\t已分配量\\t\\t执行是否结束&quot;); System.out.print(&quot;\\t\\t\\t&quot;); for (j = 0; j &lt; 3; j++) &#123; for (i = 0; i &lt; S; i++) &#123; System.out.print(name[i] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); &#125; System.out.println(); for (i = 0; i &lt; P; i++) &#123; temp = 0; System.out.print(&quot;进程P[&quot;+(i+1)+&quot;]&quot; + &quot;\\t\\t&quot;); for (j = 0; j &lt; S; j++) &#123; System.out.print(Max[i][j] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); for (l = 0; l &lt; S; l++) &#123; System.out.print(Need[i][l] + &quot; &quot;); temp += Need[i][j]; &#125; System.out.print(&quot;\\t\\t&quot;); for (k = 0; k &lt; S; k++) &#123; System.out.print(Allocation[i][k] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); if(Flag[i]==1)&#123; System.out.printf(&quot;finish\\n&quot;); &#125;else&#123; System.out.printf(&quot;working\\n&quot;); &#125; &#125; System.out.println(&quot;\\n当前可用资源：&quot;); for (i = 0; i &lt; S; i++) &#123; System.out.print(Available[i] + &quot; &quot;); &#125; System.out.println(); &#125; public int Judgesafe() &#123; int[][] tempwork = new int[100][100]; int i, x, k = 0, m, apply; int[] Finish = new int[100]; int[] temp = new int[100]; int j; int flag = 0; Work = new int[100]; for (i = 0; i &lt; S; i++) &#123; Work[i] = Available[i]; &#125; for (i = 0; i &lt; P; i++) &#123; apply = 0; for (j = 0; j &lt; S; j++) &#123; if (Finish[i] == 0 &amp;&amp; Need[i][j] &lt;= Work[j]) &#123; apply++; if (apply == S) &#123; for (m = 0; m &lt; S; m++) &#123; tempwork[i][m] = Work[m]; Work[m] = Work[m] + Allocation[i][m]; &#125; Finish[i] = 1; temp[k] = i; i = -1; k++; flag++; &#125; &#125; &#125; &#125; for (i = 0; i &lt; P; i++) &#123; if (Finish[i] == 0) &#123; System.out.println(&quot;申请不成功&quot;); return -1; &#125; &#125; System.out.println(&quot;申请成功&quot;); System.out.print(&quot;分配的序列:&quot;); for (i = 0; i &lt; P; i++) &#123; System.out.print(&quot;P[&quot;+(temp[i]+1)+&quot;]&quot;); if (i &lt; P - 1) &#123; System.out.print(&quot;--&gt;&quot;); &#125; &#125; System.out.println(); return 0; &#125; public void Changedata(int flag) &#123; for (int i = 0; i &lt; S; i++) &#123; Available[i] = Available[i] - Request[i]; Allocation[flag][i] = Allocation[flag][i] + Request[i]; Need[flag][i] = Need[flag][i] - Request[i]; &#125; &#125; public void Share() &#123; sc = new Scanner(System.in); int i, flag; char ch = &#x27;Y&#x27;; System.out.println(&quot;输入请求资源的进程：&quot;); flag = sc.nextInt()-1; Request = new int[100]; if (flag &gt;= P) &#123; System.out.println(&quot;此进程不存在!&quot;); &#125; else &#123; System.out.println(&quot;输入此进程对各个资源的请求数量：&quot;); for (i = 0; i &lt; S; i++) &#123; Request[i] = sc.nextInt(); &#125; for (i = 0; i &lt; S; i++) &#123; if (Request[i] &gt; Need[flag][i]) &#123; System.out.println(&quot;进程P[&quot; + (flag+1)+&quot;]&quot; + &quot;申请的资源大于可用资源需要的资源!&quot;); System.out.println(&quot;分配不合理不予分配!&quot;); ch = &#x27;N&#x27;; break; &#125; else if (Request[i] &gt; Available[i]) &#123; System.out.println(&quot;进程&quot; + (flag +1)+ &quot;申请的资源大于可利用的资源。&quot;); System.out.println(&quot;分配不合理，不予分配!&quot;); ch = &#x27;N&#x27;; break; &#125; &#125; if (ch == &#x27;Y&#x27;) &#123; if (Judgesafe() == -1) &#123; System.out.println(&quot;进程&quot; + flag + &quot;申请资源后，系统进入死锁状态，分配失败!&quot;); for (int j = 0; j &lt; S; j++) &#123; Available[j] = Available[j] + Request[j]; Allocation[flag][j] = Allocation[flag][j] - Request[j]; Need[flag][j] = Need[flag][j] + Request[j]; &#125; &#125; Changedata(flag); &#125; if(iffinish())&#123; Flag[i]=1; &#125; &#125; &#125; public static void main(String[] args) &#123; Banker mytext = new Banker(); Scanner sc = new Scanner(System.in); int i, j, M, N, number; String choice, tempstring; System.out.println(&quot;输入资源种类：&quot;); N = sc.nextInt(); mytext.S = N; System.out.println(&quot;输入进程的数量：&quot;); M = sc.nextInt(); mytext.P = M; System.out.println(&quot;输入资源的名称和数量：&quot;); mytext.name = new String[100]; mytext.Available = new int[100]; for (i = 0; i &lt; N; i++) &#123; mytext.name[i] = sc.next(); mytext.Available[i] = sc.nextInt(); &#125; System.out.println(&quot;输入各进程资源最大需求量：&quot;); System.out.print(&quot;进程名\\t\\t&quot;); for (i = 0; i &lt; mytext.S; i++) &#123; System.out.print(mytext.name[i] + &quot; &quot;); &#125; System.out.printf(&quot;\\n&quot;); sc.nextLine(); mytext.Max = new int[100][100]; mytext.Flag = new int[100]; for (i = 0; i &lt; M; i++) &#123; mytext.Flag[i] = 0; String ss = sc.nextLine(); String[] sslist = ss.split(&quot; &quot;); for (j = 0; j &lt; N; j++) &#123; mytext.Max[i][j] = Integer.parseInt(sslist[j+1]); &#125; &#125; System.out.println(&quot;输入各进程资源已分配量：&quot;); System.out.print(&quot;进程名\\t\\t&quot;); for (i = 0; i &lt; mytext.S; i++) &#123; System.out.print(mytext.name[i] + &quot; &quot;); &#125; System.out.printf(&quot;\\n&quot;); mytext.Allocation = new int[100][100]; mytext.Need = new int[100][100]; for (i = 0; i &lt; M; i++) &#123; String as = sc.nextLine(); String[] aslist = as.split(&quot; &quot;); for (j = 0; j &lt; N; j++) &#123; mytext.Allocation[i][j] = Integer.parseInt(aslist[j+1]); mytext.Available[j] = mytext.Available[j] - mytext.Allocation[i][j]; mytext.Need[i][j] = mytext.Max[i][j] - mytext.Allocation[i][j]; &#125; mytext.Judgesafe(); &#125; mytext.Showdata(); while (true) &#123; System.out.println(&quot;是否分配资源? Y/N：&quot;); choice = sc.next(); char choice_char = choice.charAt(0); switch (choice_char) &#123; case &#x27;N&#x27;: System.exit(0); default: mytext.Share(); break; &#125; mytext.Showdata(); &#125; &#125;&#125; /*A 10B 5C 7进程P[1] 7 5 3进程P[2] 3 2 2进程P[3] 9 0 2进程P[4] 2 2 2进程P[5] 4 3 3进程P[1] 0 1 1进程P[2] 2 0 0进程P[3] 3 0 2进程P[4] 2 1 1进程P[5] 0 0 2 */ 以下是储存管理算法 储存管算法固定分区储存管理主要思想固定式分区是在处理作业之前存储器就已经被划分成若干个分区，每个分区的大小可以相同，也可以不同。但是，一旦划分好分区后，主存储器中的分区的个数就固定了，且每个分区的大小固定不变。 Java具体实现数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Collections;import java.util.LinkedList;import java.util.Scanner;class Node implements Comparable&lt;Node&gt; &#123; private int id; //id号 private int size; //分区长度 private int address; //分区地址 String s; //分区状态 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getS() &#123; return s; &#125; public void setS(String ss) &#123; this.s = ss; &#125; @Override public String toString() &#123; return &quot;Node[ id=&quot; + id + &quot;size=&quot; + size + &quot;address=&quot; + address + &quot;s=&quot; + s + &quot;]&quot;; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class FPSM &#123; private int nums; private LinkedList&lt;Node&gt; NodeList; public void show() &#123; System.out.println(&quot;*************打印区块信息**************&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (int i = 0; i &lt; nums; i++) &#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,node.getId(),node.getSize(),node.getAddress(),node.getS()); &#125; &#125; public boolean find() &#123; for (int i = 0; i &lt; nums; i++) &#123; if (NodeList.get(i).getS() != &quot;0&quot;) &#123; return true; &#125; &#125; return false; &#125; public void allocate() &#123; Collections.sort(NodeList); //按分区大小排序 Scanner scan = new Scanner(System.in); show(); System.out.println(&quot;请输入作业数:&quot;); int n = scan.nextInt(); System.out.println(&quot;请输入这&quot; + (n) + &quot;作业的信息:&quot;); int[] list = new int[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;请输入作业&quot; + (i + 1) + &quot;的大小:&quot;); list[i] = scan.nextInt(); for (int j = 0; j &lt; nums; j++) &#123; if (NodeList.get(j).getSize() &gt; list[i]) &#123; String ss = Integer.toString((i + 1)); String s = &quot;JOB&quot; + ss; NodeList.get(j).setS(s); break; &#125; if(j==(nums-1))&#123; System.out.println(&quot;JOB&quot; + (i + 1) + &quot;大小超过最大分区大小，分配失败&quot;); &#125; &#125; &#125; System.out.println(&quot;各作业信息:&quot;); System.out.println(&quot;作业名\\t\\t作业大小&quot;); for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;JOB&quot; + (i + 1) + &quot;\\t\\t&quot; + list[i] + &quot;KB&quot;); &#125; &#125; public void free() &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入要回收的作业名:&quot;); String name = scan.next(); for (int i = 0; i &lt; nums; i++)&#123; if (NodeList.get(i).getS().equalsIgnoreCase(name)) &#123; //字符串比较需要调用函数，不然会出错 NodeList.get(i).setS(&quot;0&quot;); System.out.println(&quot;回收成功&quot;); break; &#125; if (i==nums-1)&#123; System.out.println(&quot;回收失败，分配区中未找到该作业，请从新输入！&quot;); &#125; &#125; &#125; private void init() &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入系统的分区块数：&quot;); nums = scan.nextInt(); System.out.println(&quot;请依次输入：&quot;); System.out.println(&quot;分区号\\t大小\\t起始&quot;); NodeList = new LinkedList&lt;Node&gt;(); for (int i = 0; i &lt; nums; i++) &#123; NodeList.add(new Node()); &#125; scan.nextLine(); Node[] node = new Node[nums]; for (int i = 0; i &lt; nums; i++) &#123; String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); NodeList.get(i).setId(Integer.parseInt(slist[0])); NodeList.get(i).setSize(Integer.parseInt(slist[1])); NodeList.get(i).setAddress(Integer.parseInt(slist[2])); NodeList.get(i).setS(&quot;0&quot;); &#125; &#125; private void fpsm() &#123; Scanner scan = new Scanner(System.in); init(); allocate(); show(); while (find()) &#123; System.out.println(&quot;是否还需要回收(y/n):&quot;); char c = scan.next().charAt(0); if (c == &#x27;Y&#x27; || c == &#x27;y&#x27;) &#123; free(); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; FPSM f = new FPSM(); f.fpsm(); &#125;&#125;/*1 12 202 32 323 64 644 128 1285 100 256 */ 可变分区储存管理主要思想在作业要求装入内存时，若当时内存中有足够的存储空间满足该作业的需求，那就划分出一个与作业相对地址空间同样大小的分区分配给它使用。 前后相邻接分区的四种关系 释放分区的前、后邻接分区都是已分配区，没有合并的问题存在。 释放分区的前邻接分区是空闲区，后邻接分区是已分配区。释放区应该和前邻接的空闲区合并成一个新的空闲区。 释放区的前邻接分区是已分配区，后邻接分区是空闲区。因此，释放分区应该和后邻接的空闲区合并成一个新的空闲区。 释放区的前、后邻接分区都是空闲区。因此，释放区应该和前、后两个邻接的空闲区合并成一个新的空闲区。 空闲分区合并的时机 一是调度到某作业时，若系统的每个空闲区尺寸都小于它的需要，但空闲区总存储量大于它的存储请求，于是进行空闲区合并，得到一个大的空闲区，满足该作业的需要。 一是只要有作业运行完归还所占用的存储区，系统就进行空闲区的合并。 Java具体实现数据结构123456789101112131415161718192021222324252627282930313233class Node implements Comparable&lt;Node&gt; &#123; private int size; //分区长度 private int address; //分区地址 String flag; //分区状态 public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getFlag() &#123; return flag; &#125; public void setFlag(String ss) &#123; this.flag = ss; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264public class VPSM &#123; private int length; private int totalsize; private int startaddress; private LinkedList&lt;Node&gt; NodeList; private LinkedList&lt;Node&gt; FreeList; public void show() &#123; System.out.println(&quot;**********可变分区管理**********&quot;); System.out.println(&quot;* [1] 内存分配 *&quot;); System.out.println(&quot;* [2] 内存去配 *&quot;); System.out.println(&quot;* [0] 退出管理 *&quot;); System.out.println(&quot;***********分配算法************&quot;); System.out.println(&quot;* [1] 最先分配算法 *&quot;); System.out.println(&quot;* [2] 最优分配算法 *&quot;); System.out.println(&quot;* [0] 最坏分配算法 *&quot;); System.out.println(&quot;*************主存分配情况**************&quot;); System.out.println(&quot;已分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); int i,j; for (i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(i+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; System.out.println(&quot;未分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (j=0;j&lt; FreeList.size();j++)&#123; Node node = FreeList.get(j); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(j+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; &#125; //分配 private void FirstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小&quot;); int size; for (int i=0;i&lt;length;i++)&#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=0;j&lt; FreeList.size();j++) &#123; if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if(j == FreeList.size()-1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress()-o2.getAddress(); &#125; &#125;); System.out.println(&quot;分配成功&quot;); &#125; private void BestAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小大小&quot;); int size; for (int i=1;i&lt;length;i++) &#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=0;j&lt; FreeList.size();j++) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; &#125; private void WorstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小大小&quot;); int size; for (int i=1;i&lt;length;i++) &#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=FreeList.size()-1;j&gt;=0;j--) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; &#125; public void free()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入你要删除的作业名：&quot;); String s = scan.next(); System.out.println(s); Node recycle = new Node(); int neighborup = -1;//记录上面相邻接块的位置，-1代表不邻接 int neighbordown = -1;//记录上面相邻接块的位置，-1代表不邻接 for (int i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); String flag = node.getFlag(); if(flag.equalsIgnoreCase(s))&#123; recycle.setSize(node.getSize()); recycle.setAddress(node.getAddress()); recycle.setFlag(node.getFlag()); //先找到要回收的内存,保留信息 NodeList.remove(node); //移除作业 &#125;// else if(!(flag.equalsIgnoreCase(s)) &amp;&amp; (i==(NodeList.size()-1)))&#123;// System.out.println(&quot;未找到该作业!分配失败!&quot;);// return ;// &#125; &#125; for (int i = 0; i &lt;FreeList.size(); i++) &#123; Node free = FreeList.get(i); //上邻 if(recycle.getAddress()==(free.getAddress()+free.getSize()))&#123; neighborup = FreeList.indexOf(free); free.setSize(free.getSize()+recycle.getSize());//更新区间长度 FreeList.set(neighborup,free); &#125; //下邻 if((recycle.getAddress()+recycle.getSize())==free.getAddress())&#123; neighbordown = FreeList.indexOf(free);//更新两块合并后的长度 free.setAddress(recycle.getAddress());//更新该空闲区间首地址 free.setSize(free.getSize()+recycle.getSize());//更新该空闲区间长度 FreeList.set(neighbordown,free); &#125; //上下邻 if (neighbordown!=-1 &amp;&amp; neighborup!=-1)&#123; Node up = FreeList.get(neighborup); Node down = FreeList.get(neighbordown); up.setSize(down.getSize()-up.getSize()); FreeList.set(neighbordown,up);//修改链表中三块合一后的最终空闲块 FreeList.remove(down);//下面这块已经被上面那块合并 &#125; &#125; if (neighbordown==-1 &amp;&amp; neighborup==-1)&#123; Node addFree = new Node(); addFree.setSize(recycle.getSize()); addFree.setAddress(recycle.getAddress()); addFree.setFlag(&quot;空闲&quot;); FreeList.addLast(addFree); &#125; Collections.sort(FreeList); &#125; private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入内存大小：&quot;); totalsize = scan.nextInt(); System.out.println(&quot;请输入起始地址大小：&quot;); startaddress = scan.nextInt(); //初始空闲化分区 NodeList = new LinkedList&lt;Node&gt;(); FreeList = new LinkedList&lt;Node&gt;(); Node start = new Node(); start.setSize(totalsize); start.setAddress(startaddress); start.setFlag(&quot;空闲&quot;); FreeList.add(start); &#125; private void vpsm() &#123; Scanner scan = new Scanner(System.in); init(); show(); while (true) &#123; System.out.println(&quot;请输入要进行的管理选项：&quot;); int FuncChoic = scan.nextInt(); if (FuncChoic == 1) &#123; System.out.println(&quot;请输入分配方式选项：&quot;); int AllocWay = scan.nextInt(); System.out.println(&quot;请输入你要分配的个数：&quot;); int nums = scan.nextInt(); length = nums; switch (AllocWay) &#123; case 1: FirstAllotment(); break; case 2: BestAllotment(); break; case 3: WorstAllotment(); break; default: System.out.println(&quot;选择的分配方式有误&quot;); &#125; &#125; else if (FuncChoic == 2) &#123; free(); &#125; else if (FuncChoic == 0) &#123; System.exit(0); &#125; else &#123; System.out.println(&quot;输入有误！！请从新输入&quot;); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; VPSM f = new VPSM(); f.vpsm(); &#125;&#125;/*25640JOB_A 15JOB_B 50JOB_C 10JOB_D 25JOB_E 14JOB_F 32done */ 实验老师要求是页式、段式、段页式储存管理选一个，我选了短时储存管理，故只有一个啦 段式储存管理主要思想了进行段式管理，每道程序在系统中都有一个段（映象）表来存放该道程序各段装入主存的状况信息。段表中的每一项（对应表中的每一行）描述该道程序一个段的基本状况，由若干个字段提供。段名字段用于存放段的名称，段名一般是有其逻辑意义的，也可以转换成用段号指明。由于段号从0开始顺序编号，正好与段表中的行号对应，如2段必是段表中的第3行，这样，段表中就可不设段号（名）字段。装入位字段用来指示该段是否已经调入主存，“1”表示已装入，“0”表示未装入。在程序的执行过程中，各段的装入位随该段是否活跃而动态变化。当装入位为“1”时，地址字段用于表示该段装入主存中起始（绝对）地址，当装入位为“0”时，则无效（有时机器用它表示该段在辅存中的起始地址）。段长字段指明该段的大小，一般以字数或字节数为单位，取决于所用的编址方式。段长字段是用来判断所访问的地址是否越出段界的界限保护检查用的。访问方式字段用来标记该段允许的访问方式，如只读、可写、只能执行等，以提供段的访问方式保护。除此之外，段表中还可以根据需要设置其它的字段。段表本身也是一个段，一般常驻在主存中，也可以存在辅存中，需要时再调入主存。假设系统在主存中最多可同时有N道程序，可设N个段表基址寄存器。对应于每道程序，由基号（程序号）指明使用哪个段表基址寄存器。段表基址寄存器中的段表基址字段指向该道程序的段表在主存中的起始地址。段表长度字段指明该道程序所用段表的行数，即程序的段数。 Java具体实现数据结构123456789101112131415161718192021222324252627282930313233343536import java.util.Collections;import java.util.Comparator;import java.util.LinkedList;import java.util.Scanner;class Node implements Comparable&lt;Node&gt; &#123; private int size; //分区长度 private int address; //分区地址 String flag; //分区状态 public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getFlag() &#123; return flag; &#125; public void setFlag(String ss) &#123; this.flag = ss; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322public class SSM &#123; private int totalsize; private int startaddress; private LinkedList&lt;Node&gt; NodeList; private LinkedList&lt;Node&gt; FreeList; public void show() &#123; System.out.println(&quot;**********段式储存管理**********&quot;); System.out.println(&quot;* [1] 内存分配 *&quot;); System.out.println(&quot;* [2] 内存去配 *&quot;); System.out.println(&quot;* [0] 退出管理 *&quot;); System.out.println(&quot;***********分配算法************&quot;); System.out.println(&quot;* [1] 最先分配算法 *&quot;); System.out.println(&quot;* [2] 最优分配算法 *&quot;); System.out.println(&quot;* [0] 最坏分配算法 *&quot;); System.out.println(&quot;*************主存分配情况**************&quot;); System.out.println(&quot;已分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); int i,j; for (i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(i+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; System.out.println(&quot;未分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (j=0;j&lt; FreeList.size();j++)&#123; Node node = FreeList.get(j); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(j+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; &#125; public void ShowSegmentTable(String n)&#123; System.out.println(&quot;******打印&quot;+n+&quot;段表*****&quot;); System.out.println(&quot;段号\\t段长（KB）\\t基址（KB）&quot;); for (int i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0,5); String ID = line.substring(6,7); if(ns.equals(n))&#123; System.out.println(ID+&quot;\\t&quot;+node.getSize()+&quot;\\t\\t\\t&quot;+node.getAddress()); &#125; &#125; &#125; //分配 private void FirstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++)&#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=0;j&lt; FreeList.size();j++) &#123; if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if(j == FreeList.size()-1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress()-o2.getAddress(); &#125; &#125;); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; private void BestAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++) &#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=0;j&lt; FreeList.size();j++) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; private void WorstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++) &#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=FreeList.size()-1;j&gt;=0;j--) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; //去配 public boolean sure(String name)&#123; for(int i=0;i&lt; NodeList.size();i++)&#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0, 5); if (ns.equals(name))&#123; return true; &#125; &#125; return false; &#125; public void free()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入你要删除的作业名：&quot;); String name = scan.next(); Node recycle = new Node(); while(sure(name)) &#123; //每次free前要初始化邻接状态 int neighborup = -1;//记录上面相邻接块的位置，-1代表不邻接 int neighbordown = -1;//记录上面相邻接块的位置，-1代表不邻接 //查找要释放的作业 for (int i = 0; i &lt; NodeList.size(); i++) &#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0, 5); if (ns.equals(name)) &#123; recycle.setSize(node.getSize()); recycle.setAddress(node.getAddress()); recycle.setFlag(node.getFlag()); //先找到要回收的内存,保留信息 NodeList.remove(node); //移除作业 break; &#125; else if (!(ns.equals(name)) &amp;&amp; (i == (NodeList.size() - 1))) &#123; System.out.println(&quot;未找到该作业!去配失败!&quot;); return; &#125; &#125; //去配作业 for (int i = 0; i &lt; FreeList.size(); i++) &#123; Node free = FreeList.get(i); //上邻 if (recycle.getAddress() == (free.getAddress() + free.getSize())) &#123; neighborup = FreeList.indexOf(free); free.setSize(free.getSize() + recycle.getSize());//更新区间长度 FreeList.set(neighborup, free); &#125; //下邻 if ((recycle.getAddress() + recycle.getSize()) == free.getAddress()) &#123; neighbordown = FreeList.indexOf(free);//更新两块合并后的长度 free.setAddress(recycle.getAddress());//更新该空闲区间首地址 free.setSize(free.getSize() + recycle.getSize());//更新该空闲区间长度 FreeList.set(neighbordown, free); &#125; //上下邻 if (neighbordown != -1 &amp;&amp; neighborup != -1) &#123; Node up = FreeList.get(neighborup); Node down = FreeList.get(neighbordown); up.setSize(down.getSize() + up.getSize()-recycle.getSize()); FreeList.set(neighborup, up);//修改链表中三块合一后的最终空闲块 FreeList.remove(down);//下面这块已经被上面那块合并 &#125; &#125; if (neighbordown == -1 &amp;&amp; neighborup == -1) &#123; Node addFree = new Node(); addFree.setSize(recycle.getSize()); addFree.setAddress(recycle.getAddress()); addFree.setFlag(&quot;空闲&quot;); FreeList.addLast(addFree); &#125; Collections.sort(FreeList); System.out.println(&quot;回收&quot;+name+&quot;的段&quot;+recycle.getFlag()+&quot;成功！&quot;); &#125; &#125; //初始化 private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入初始内存大小：&quot;); totalsize = scan.nextInt(); System.out.println(&quot;请输入起始地址大小：&quot;); startaddress = scan.nextInt(); //初始空闲化分区 NodeList = new LinkedList&lt;Node&gt;(); FreeList = new LinkedList&lt;Node&gt;(); Node start = new Node(); start.setSize(totalsize); start.setAddress(startaddress); start.setFlag(&quot;空闲&quot;); FreeList.add(start); &#125; private void ssm() &#123; Scanner scan = new Scanner(System.in); init(); show(); while (true) &#123; System.out.println(&quot;请输入要进行的管理选项：&quot;); int FuncChoic = scan.nextInt(); if (FuncChoic == 1) &#123; System.out.println(&quot;请输入分配方式选项：&quot;); int AllocWay = scan.nextInt(); switch (AllocWay) &#123; case 1: FirstAllotment(); break; case 2: BestAllotment(); break; case 3: WorstAllotment(); break; default: System.out.println(&quot;选择的分配方式有误&quot;); &#125; &#125; else if (FuncChoic == 2) &#123; free(); &#125; else if (FuncChoic == 0) &#123; System.exit(0); &#125; else &#123; System.out.println(&quot;输入有误！！请从新输入&quot;); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; SSM f = new SSM(); f.ssm(); &#125;&#125;/*25640JOB_A5022030JOB_C100303535 */ 页面置换算法主要思想这个较难，一两句话讲不清 参考链接 https://www.jianshu.com/p/18285ecffbfb Java具体实现算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231import java.util.*;public class PRA &#123; private int n;//物理块数 private int F;//未能找到的次数 缺页率=F/length private String name; //作业名 private int length; //作业长度 private List&lt;Integer&gt;list = null; //作业页面顺序 private Map&lt;Integer,Integer&gt;map = null; private int[][] showlist; public void ShowProcess()&#123; System.out.println(&quot;作业名：&quot;+name); System.out.println(&quot;作业调度过程&quot;); System.out.print(&quot; \\t&quot;); for (int i = 0; i &lt; length; i++) &#123; System.out.print((i+1)+&quot;\\t&quot;); &#125; System.out.println(); System.out.print(&quot; \\t&quot;); for (int i=0;i&lt;length;i++)&#123; System.out.print(list.get(i)+&quot;\\t&quot;); &#125; System.out.println(); for (int j=0;j&lt;n;j++) &#123; System.out.printf(&quot;块%d\\t&quot;,(j+1)); for (int i = 0; i &lt; length; i++) &#123; if(showlist[j][i]==-1)&#123; System.out.print(&quot; &quot;+&quot;\\t&quot;); &#125; else &#123; System.out.print(showlist[j][i] + &quot;\\t&quot;); &#125; &#125; System.out.println(); &#125; &#125; public void menu()&#123; System.out.println(&quot;**********请求分页式储存管理**********&quot;); System.out.println(&quot;* [1] FIFO分配 *&quot;); System.out.println(&quot;* [2] LRU(LFU)分配 *&quot;);// System.out.println(&quot;* [3] OPT分配 *&quot;); System.out.println(&quot;* [0] 退出 *&quot;); &#125; public void FIFO()&#123; map.clear(); F = 0; Queue&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsValue(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(temp, k); q.offer(temp); &#125; else &#123; int temp=q.poll();//排除的元素位置 map.remove(temp); map.put(temp,k); q.offer(temp); &#125; &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; else&#123; showlist[s][i] = -1; &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void LRU()&#123; map.clear(); F = 0; List&lt;Integer&gt; linkedlist = new LinkedList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsKey(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(k,temp); linkedlist.add(k);//添加位置 &#125; else &#123; int temp=linkedlist.get(0); int c=map.get(temp);//位置 map.remove(temp); map.put(k,c); linkedlist.remove(0); linkedlist.add(k); &#125; &#125; else//如果包含这个值，把这个值拿走并在后面压入 &#123; int d=linkedlist.indexOf(k);//查找存在位置 linkedlist.remove(d); linkedlist.add(k); &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; else&#123; showlist[s][i] = -1; &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void OPT()&#123; int j; for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsValue(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(temp, k); &#125; else&#123;//如果装满了 int index=0;//把哪个位置的淘汰出去 int min=0;//初始最长长度 for (int t=0;t&lt;n;t++) &#123; for (j=i+1;j&lt;length;j++)&#123;//看后面哪一个出现的最晚 if (list.get(j)==map.get(t))&#123;//第一次找到 if (j-i&gt;min)&#123; index=t;//更新值 min=j-i; &#125; break; &#125; &#125; if (j==length)&#123;//如果到最后 index=t; min=j-i; &#125; &#125; map.remove(index); map.put(index,k);//修改表内元素 &#125; &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void pra()&#123; map=new HashMap&lt;Integer,Integer&gt;();//存储每一个内储页框所存的内容 map.clear(); Scanner scan = new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入物理块数：&quot;); n = scan.nextInt(); menu(); System.out.println(&quot;请输入选项：&quot;); int choice = scan.nextInt(); scan.nextLine();//读走回车 System.out.println(&quot;请输入作业名：&quot;); name = scan.nextLine(); System.out.println(&quot;请输入作业的页面长度&quot;); length = scan.nextInt(); scan.nextLine();//读走回车 System.out.println(&quot;请输入作业的页面顺序&quot;); String str = scan.nextLine(); String[] sList = str.split(&quot; &quot;); list = new ArrayList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++)&#123; list.add(Integer.parseInt(sList[i])); &#125; //showlist初始化 showlist = new int[n][length]; for (int j=0;j&lt;n;j++) &#123; for (int i = 0; i &lt; length; i++) &#123; showlist[j][i] = -1; &#125; &#125; switch (choice) &#123; case 1: FIFO(); break; case 2: LRU(); break;// case 3:// OPT();// break; case 0: System.exit(0); default: System.out.println(&quot;输入的选项有误请从新输入&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; PRA pra = new PRA(); pra.pra(); &#125;&#125;/*JOB_1207 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1JOB_2207 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 */ 补充这个算法中，showProcess函数存在错误，并非正确显示，可以忽略，如需输出，可自行再修改 磁盘臂调度算法主要思想思想太长了，我好懒不想写；参见别人的说法，连接如下 https://blog.csdn.net/Zhxin606a/article/details/89577836 Java具体实现数据结构 没有特殊的数据结构，用数组即可算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234import java.util.ArrayList;import java.util.Scanner;import java.util.Collections;import java.awt.*;import javax.swing.*;import java.awt.geom.*;public class DSASA extends JFrame&#123; private int length; //访问序列长度 private ArrayList&lt;Integer&gt; acessSque = null; //访问顺序 private int now; //正在访问页面 /** 调用画图函数 */ public void drawGraphics(int[] x) &#123; int[] y = new int[x.length]; for (int i = 0; i &lt; x.length; i++) &#123; y[i] = (i + 1) * 60; &#125; Draw d = new Draw(); d.setX(x); d.setY(y); d.setVisible(true); &#125; private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入访问序列长度：&quot;); length = scan.nextInt(); scan.nextLine(); System.out.println(&quot;请输入访问柱面顺序：&quot;); acessSque = new ArrayList&lt;Integer&gt;();; acessSque.clear(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); for(int i=0; i&lt;length;i++)&#123; acessSque.add(Integer.parseInt(slist[i])); &#125; System.out.println(&quot;请输入正在访问的页面：&quot;); now = scan.nextInt(); scan.nextLine(); &#125; private void FCFS()&#123; System.out.println(&quot;***********FCFS磁盘臂调度过程***********&quot;); init(); int[] moveSque = new int[length+1]; int movesum = 0; moveSque[0] = now; for(int i=0; i&lt;length;i++)&#123; if(i==0) &#123; movesum += Math.abs(acessSque.get(i) - now); &#125; else &#123; movesum += Math.abs(acessSque.get(i)-acessSque.get(i-1)); &#125; moveSque[i+1] = acessSque.get(i); &#125; System.out.println(&quot;移动顺序为：&quot;); for(int i=0;i&lt; moveSque.length;i++)&#123; System.out.print(moveSque[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum); drawGraphics(moveSque); &#125; private void SSTF()&#123; System.out.println(&quot;***********SSTF磁盘臂调度过程***********&quot;); init(); int[] moveSque = new int[length+1]; int movesum = 0; int min; int x; moveSque[0] = now; Collections.sort(acessSque); for(int i=0; i&lt;length;i++)&#123; min = Math.abs((acessSque.get(0)-moveSque[i])); x = i; for (int j=0;j&lt; acessSque.size();j++)&#123; if(Math.abs((acessSque.get(j)-moveSque[i]))&lt;= min)&#123; min = Math.abs(acessSque.get(j)-moveSque[i]); x = acessSque.get(j); &#125; &#125; moveSque[i+1] = x; acessSque.remove(acessSque.indexOf(x)); movesum += Math.abs(moveSque[i]-moveSque[i+1]); &#125; System.out.println(&quot;最短优先的顺序为：&quot;); for(int i=0;i&lt; moveSque.length;i++)&#123; System.out.print(moveSque[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum); drawGraphics(moveSque); &#125; private void SCAN()&#123; System.out.println(&quot;***********电梯调度***********&quot;); init(); int[] moveSque_out_to_in = new int[length+1]; //由外向里 int[] moveSque_in_to_out = new int[length+1]; //由里向外 int movesum_out = 0; int movesum_in = 0; moveSque_out_to_in[0] = now; moveSque_in_to_out[0] = now; Collections.sort(acessSque); int locats=0; int count = 1; for(int i=0;i&lt;length-1;i++)&#123; if(acessSque.get(i)&lt;=now &amp;&amp; acessSque.get(i+1)&gt;now)&#123; locats = i; break; &#125; &#125; if(locats!=0) &#123; //开始位置在中间 count = 1; for (int k = locats; k &gt;= 0; k--) &#123; moveSque_in_to_out[count++] = acessSque.get(k); movesum_in += Math.abs(moveSque_in_to_out[count-1]-moveSque_in_to_out[count-2]); &#125; for (int k = locats+1; k &lt; length; k++) &#123; moveSque_in_to_out[count++] = acessSque.get(k); movesum_in += Math.abs(moveSque_in_to_out[count-1]-moveSque_in_to_out[count-2]); &#125; count = 1; for (int k=locats+1;k&lt;length;k++)&#123; moveSque_out_to_in[count++] = acessSque.get(k); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; for (int k=locats;k &gt;= 0; k--)&#123; moveSque_out_to_in[count++] = acessSque.get(k); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; else&#123; if (acessSque.get(length-1) &lt;= now)&#123; count = 1; for (int i=0;i&lt;length;i++)&#123; moveSque_out_to_in[count++] = acessSque.get(i); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; else&#123; count = 1; for (int i=length-1;i&gt;=0;i--)&#123; moveSque_in_to_out[count++] = acessSque.get(i); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; &#125; System.out.println(&quot;由里向外移动顺序为：&quot;); for(int i=0;i&lt; moveSque_in_to_out.length;i++)&#123; System.out.print(moveSque_in_to_out[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum_in); drawGraphics(moveSque_in_to_out); System.out.println(&quot;由外向里移动顺序为：&quot;); for(int i=0;i&lt; moveSque_out_to_in.length;i++)&#123; System.out.print(moveSque_out_to_in[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum_out); drawGraphics(moveSque_out_to_in); &#125; public void dsasa() &#123; FCFS();SSTF();SCAN(); &#125; public static void main(String[] args) &#123; DSASA dsasa = new DSASA(); dsasa.dsasa(); &#125;&#125;class Draw extends JFrame &#123; private int[] x; private int[] y; public int[] getx() &#123; return x; &#125; public void setX(int[] x) &#123; this.x = x; &#125; public int[] gety() &#123; return y; &#125; public void setY(int[] y) &#123; this.y = y; &#125; public Draw() &#123; setSize(1000,800); setDefaultCloseOperation(DISPOSE_ON_CLOSE); setLocationRelativeTo(null); &#125; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D)g; //g是Graphics对象 g2.setStroke(new BasicStroke(3.0f)); g2.setColor(Color.blue); g2.drawLine(50, y[0], 950, y[0]); for (int i = 0; i &lt; x.length-1; i++) &#123;// g.setColor(Color.RED); g2.drawString(&quot;&quot; + x[i], x[i]*5, y[i]);// g.setColor(Color.BLUE); g2.drawLine(x[i]*5, y[i], x[i+1]*5, y[i+1]); &#125;// g.setColor(Color.RED); g.drawString(&quot;&quot; + x[x.length-1], x[x.length-1]*5, y[y.length-1]); &#125;&#125;/*898 183 37 122 14 124 65 6753 */ 磁盘空间管理 位视图法主要思想Java具体实现数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.LinkedList;import java.util.Random;import java.util.Scanner;class Node&#123; /** * @description: * @param null * @return: * @author: whk * @time: 2021/5/22 17:35 */ int size;//需要分配空间的大小 int[] a; //块号// int[] zihao;//字号// int[] weihao;//位号 int[] Cylinder; //柱面号 int[] headers;//磁头号 int[] Sector;//扇区号 String name;//作业名 public int getSize()&#123; return size; &#125; public void setSize(int newSize)&#123; this.size=newSize; &#125; public int getA(int i)&#123; return a[i]; &#125; public void setA(int newA,int i)&#123; this.a[i] = newA; &#125;// public int getZihao(int i)&#123;// return zihao[i];// &#125;// public void setZihao(int newZihao,int i)&#123;// this.zihao[i] = newZihao;// &#125;//// public int getWeihao(int i)&#123;// return weihao[i];// &#125;// public void setWeihao(int newWeihao,int i)&#123;// this.weihao[i] = newWeihao;// &#125; public int getCylinder(int i)&#123; return Cylinder[i]; &#125; public void setCylinder(int newCylinder,int i)&#123; this.Cylinder[i] = newCylinder; &#125; public int getHeaders(int i)&#123; return headers[i]; &#125; public void setHeaders(int newheaders,int i)&#123; this.headers[i] = newheaders; &#125; public int getSector(int i)&#123; return Sector[i]; &#125; public void setSector(int newSector,int i)&#123; this.Sector[i] = newSector; &#125; public String getName() &#123; return name; &#125; public void setName(String newName)&#123; this.name = newName; &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272public class DSMA &#123; private int fucun;//辅存空间大小 private int zichang;//字长 private int kuaichang;//块长 private int Headnums;//磁道数 private int SectorsNums; //扇区数 private int[][] fucunspace;//辅存空间 //辅助变量 private int x; int count = 0; private LinkedList&lt;Node&gt; Nodelist; Scanner scan = new Scanner(System.in); public void init()&#123; Nodelist = new LinkedList&lt;&gt;(); System.out.println(&quot;请输入辅存空间大小（单位：K）和字长（32 or 64）和块长（单位：K）：&quot;); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); fucun = Integer.parseInt(slist[0]); zichang = Integer.parseInt(slist[1]); kuaichang = Integer.parseInt(slist[2]); System.out.println(&quot;请输入该辅存硬盘的的磁道数（磁头数）、每磁道扇区数: &quot;); String s2 = scan.nextLine(); String[] s2list = s2.split(&quot; &quot;); Headnums = Integer.parseInt(s2list[0]); SectorsNums = Integer.parseInt(s2list[1]); //初始化辅存空间表,随机初始化 x= (int) Math.ceil(fucun/zichang); fucunspace = new int[x+1][zichang]; Random r = new Random(); for (int i=0;i&lt;=x;i++)&#123; for (int j=0;j&lt;zichang;j++)&#123; fucunspace[i][j] = r.nextInt(2); &#125; &#125; &#125; public void ShowMemorySpace()&#123; /** * @description: * @param * @return: void * @author: whk * @time: 2021/5/22 17:35 */ count = 0; System.out.println(&quot;********************************************打印内存空间分配情况*****************************************&quot;); System.out.print(&quot;\\t&quot;); for (int i=0;i&lt;zichang;i++)&#123; System.out.print((i+1) + &quot;\\t&quot;); &#125; System.out.println(); x= (int) Math.ceil(fucun/zichang); for (int i=0;i&lt;=x;i++)&#123; System.out.print((i+1)+&quot;\\t&quot;); for (int j=0;j&lt;zichang;j++)&#123; System.out.print(fucunspace[i][j]+&quot;\\t&quot;); if(fucunspace[i][j]!=0)&#123; count++; &#125; &#125; System.out.println(); &#125; System.out.println(&quot;系统剩余空块数：&quot;+(fucun-count)); &#125; public void ShowMemoryInfo(String names)&#123; /** * @description: * @param names * @return: void * @author: whk * @time: 2021/5/22 17:33 */ Node temp = new Node(); for(int i=0;i&lt; Nodelist.size();i++)&#123; if(Nodelist.get(i).getName().equals(names))&#123; temp = Nodelist.get(i); break; &#125; if(!Nodelist.get(i).getName().equals(names) &amp;&amp; (i+1)== Nodelist.size())&#123; System.out.println(&quot;该作业无储存信息&quot;); &#125; &#125; System.out.println(&quot;**********打印&quot;+temp.getName()+&quot;作业在辅助中的信息************&quot;); System.out.println(&quot;记录\\t\\t块号\\t\\t柱面号\\t磁头号\\t扇区号&quot;); for (int i=0;i&lt;temp.getSize();i++)&#123; System.out.println((i+1)+&quot;\\t\\t&quot;+temp.getA(i)+&quot;\\t\\t&quot;+temp.getCylinder(i)+&quot;\\t\\t&quot;+temp.getHeaders(i)+&quot;\\t\\t&quot;+temp.getSector(i)); &#125; &#125; public void menu()&#123; /** * @description: * @param * @return: void * @author: whk * @time: 2021/5/22 17:34 */ System.out.println(); System.out.println(&quot;***********辅存空间管理************&quot;); System.out.println(&quot;* [1] 空间分配 *&quot;); System.out.println(&quot;* [2] 空间去配 *&quot;); System.out.println(&quot;* [0] 退出管理 *&quot;); &#125; public int[] find() &#123; /** * @description: * @param * @return: int[] * @author: whk * @time: 2021/5/22 17:34 */ int[] loac = new int[2]; for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt; zichang; j++) &#123; if (fucunspace[i][j]==0)&#123; fucunspace[i][j] = 1; loac[0] = i; loac[1] = j; return loac; &#125; &#125; &#125; return null; &#125; public String Allocat()&#123; /** * @description: * @param * @return: java.lang.String * @author: whk * @time: 2021/5/22 17:34 */ System.out.println(&quot;请输入申请空间的作业名字和需要分配的辅存空间的大小：&quot;); String s3 = scan.nextLine(); String[] s3list = s3.split(&quot; &quot;); if(Integer.parseInt(s3list[1])&lt;fucun &amp;&amp; Integer.parseInt(s3list[1])&lt;count) &#123; //保证不会越界 Node node = new Node(); node.setName(s3list[0]); node.setSize(Integer.parseInt(s3list[1])); node.a = new int[node.getSize()];// node.zihao = new int[node.getSize()]; node.Cylinder = new int[node.getSize()]; node.headers = new int[node.getSize()]; node.Sector = new int[node.getSize()]; x = (int) Math.ceil(fucun / zichang); int temp = 0; for (int k = 0; k &lt; node.getSize(); k++) &#123; int[] list = find();// System.out.println(list[0]+&quot; &quot;+list[1]); if (list[0] == 0) &#123; temp = list[1]; &#125; else if (list[0] &gt; 0) &#123; temp = list[0] * zichang + list[1]; &#125; int d = SectorsNums*Headnums; node.setA(temp, k); node.setCylinder(temp/d, k); node.setHeaders((temp%d)/SectorsNums, k); node.setSector(temp % d % SectorsNums, k); &#125; Nodelist.add(node); System.out.println(&quot;内存分配成功！&quot;); return node.getName(); &#125;else &#123; System.out.println(&quot;申请内存空间大于当前可用内存空间&quot;); &#125; return s3; &#125; public String Free()&#123; /** * @description: * @param * @return: java.lang.String * @author: whk * @time: 2021/5/22 17:34 */ System.out.print(&quot;当前分配的作业：&quot;); for (Node node : Nodelist) &#123; if (Nodelist.indexOf(node)==Nodelist.size()-1)&#123; System.out.println(node.getName()); &#125;else &#123; System.out.print(node.getName() + &quot;-&gt;&quot;); &#125; &#125; System.out.println(&quot;请输入你要回收的作业名：&quot;); String names = scan.nextLine(); Node freenode = new Node(); for (int i=0;i&lt;Nodelist.size();i++)&#123; if (Nodelist.get(i).getName().equals(names))&#123;// System.out.println(&quot;查找成功。。。。。&quot;); freenode = Nodelist.get(i); Nodelist.remove(i); break; &#125; &#125; for (int k=0;k&lt; freenode.getSize();k++) &#123; int s = freenode.getA(k); int i,j; if (s &lt;zichang)&#123; i = 0; j = s; &#125;else &#123; i = s/zichang; j = s- i*zichang; &#125;// System.out.println(i+&quot; &quot;+j); fucunspace[i][j] = 0; &#125; System.out.println(&quot;回收成功&quot;); return freenode.getName(); &#125; public void dsma()&#123; /** * @description: * @param * @return: void * @author: whk * @time: 2021/5/22 17:34 */ init(); System.out.println(&quot;初始化储存空间.....&quot;); ShowMemorySpace(); while(true) &#123; menu(); ShowMemorySpace(); System.out.println(&quot;请输入选项&quot;); int choice = scan.nextInt(); scan.nextLine(); switch (choice) &#123; case 1: String name = Allocat(); ShowMemorySpace(); ShowMemoryInfo(name); break; case 2: ShowMemoryInfo(Free()); ShowMemorySpace(); break; case 0: System.exit(1); default: System.out.println(&quot;输入的选项有误,请重新输入&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; DSMA d = new DSMA(); d.dsma(); &#125;&#125;/*1000 64 18 961JOB_1 501JOB_5 302 */ 这个算法应该是最后一个算法了，不知道后面的操作系统会不会有算法了，按照实验指南来说的话，前面是还有几个算法直接跳过了，如果还有的话我就再补充吧 2021年5月22日17:46","categories":[{"name":"OS","slug":"OS","permalink":"https://www.whkblog.work/categories/OS/"}],"tags":[{"name":"操作系统算法","slug":"操作系统算法","permalink":"https://www.whkblog.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2021-04-17T08:38:33.000Z","updated":"2021-06-27T07:14:19.444Z","comments":true,"path":"2021/04/17/计算机网络/","link":"","permalink":"https://www.whkblog.work/2021/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"写在最前，这个只是个人的计网知识总结，内容不是全面，可供参考 第一章 概述1、单工、半双工、全双工基本概念，串行和并行通信的概念单工：只有一个信道，传输方向只能单向； 半双工：只有一个信道，传输方向为双向，但同一时刻，只能单向传输； 全双工：双信道，同时可以双向数据传输； 串行通信：一组数据在一条线路上一位一位的传送； 并行通信：一组数据在多条线路上同时传送。 2、协议的三要素 网络协议规定了通信双方具体的通信规则，协议三要素：语法、语义、同步。 3、比较电路交换和分组交换（分组交换的核心思想）报文交换交换即按照某种方式动态的分配传输线路的资源。 交换方式 优点（本质/ 核心思想） 缺点 电路交换 （1）资源独占 （2）提供面向连接的服务 （3）通信相对可靠 （1）成本高 （2）资源利用率低 分组交换* （1）分组 （2）存储转发 （3）资源共享 （4）灵活性高，适合计算机之间的通信 （1）可靠性不高 （2）可能出现延迟和拥塞 报文交换 不分组的分组交换 4、比较面向连接和无连接服务 服务方式 面向连接 无连接 数据传输 建立连接、数据通信、释放连接 无需连接，直接通信 可靠性 可靠 不可靠，但速度快（尽最大努力服务） 传输层相应协议 TCP，电路交换，虚电路 UDP，IP，Ethernet 5、比较带宽、吞吐量和传播速度带宽：分成物理带宽和网络带宽，物理带宽是一段链路所能传输的频率的范围，单位是hz，网络带宽是指网络可通过的最高数据传输速率（bit/s、bps）； 1Mbps=1000Kbps=10^6b/s 吞吐量：网络实际通过的数据传输速率； 传播速度：信号在介质上的传播速率（m/s）； 6、详细说明分组交换网的延迟有哪些，分别是由什么原因造成的。（参考书和课件） 延迟类型 定义 原因 传输延迟（发送延迟） 数据从结点发送到链路上所消耗的时间 （1）网络带宽；（2）数据大小； （3）链路特性；（4）网络特性 传播延迟 信号从一个结点发送到另一个结点在链路上传播所消耗的时间 （1）传播介质；（2）链路长度 结点处理延迟 （排队延迟和处理延迟） 路由器上排队等待、数据处理和转发至输出链路等所消耗的时间 （1）网络拥塞程度；（2）转发表规模； （3）路由器性能 7、ping、tracert、ipconfig、nslookup、netstat的作用ping和tracert均用以验证简单TCP/IP网络的连通性。 ping：默认测试3次，发送ICMP请求数据包，并等待接收方的ICMP应答包，显示RTT（Round-trip time，往返时延）和TTL（Time to live，生存时间）； tracert：通过TTL的递增对路由进行跟踪，测试并显示每个结点的往返时延3次。 8、什么是因特网 因特网是网络的网络，它是将全球异构的网络互联起来的网络。因特网由许多终端设备、通信介质和中间设备组成，在TCP/IP协议簇的基础上通过各种应用程序进行通信。 9双绞线的制作方法（T568B和T568A）T568B：半橙橙半绿蓝半蓝绿半棕棕 T568A：在T568B基础上，橙色和绿色线对（半色和全色）交换位置。半绿绿半橙蓝半蓝橙半棕棕 10、直通线和交叉线的应用直通线：两端均为T568B，一般用于不同设备之间； 交叉线：一端为T568B、一端为T568A，一般用于相同或相近设备之间。 11、比较双绞线和光纤 类型 双绞线 光纤 传输距离 理论上不超过100m（衰减） 传输距离长 抗干扰性 （1）线对之间会产生干扰（串扰） （2）线遇到不连续阻抗（线弯曲）时信号会反射（回波损耗） 抗干扰性强，衰减小 价格 便宜 日益下降 12、比较单模光纤和多模光纤 类型 多模光纤 单模光纤 核心直径 大 小 传输模式 多路径或多模式 单一无散射模式 光源 LED 激光 带宽 低 高 传输距离 短（一般小于100m） 长（可达50km） 13、网络为什么要分层，如何分层，分层之后如何发送和接收数据，分层的理解。（参考书）分层的原因：简单、容易学习、便于讨论。模块化的设计（参考模型）便于讨论，同时也简化了维护和升级，具体表现在某个层次的服务对系统的其他层次透明，且某个层次的改变只需改变与其相邻层次的接口。 OSI体系结构（官方标准） TCP/IP体系结构（因特网标准） 各分层作用 PDU（协议数据单元） 应用层 应用层 负责各种网络应用、进程与进程之间的通信 消息（message） 表示层 会话层 传输层 传输层 负责端到端数据的传输控制 报文段（segment） 网络层 网络层（网际层） 负责选路和不同网段数据的转发 分组（packet） 数据链路层 网络接口层 数据链路层 数据在一段链路上相邻结点间的传输 帧（frame） 物理层 物理层 负责信号物理通信的规则 比特流（bit torrent） 数据的发送与接收：发送端将数据进行层层封装（应用层、传输层、网络层和数据链路层均在上一层的基础上加一首部，同时数据链路层在分组最后加一CRC冗余校验码尾部），接收端则按层次结构由下向上层层解封，获得原始数据。 协议分层：协议是两个对等实体进行通信的规则的集合，其下层为上层提供服务且对上层透明，对某层协议而言，收发双方使用的协议是相同的，即协议是水平的；而各层协议间下层对上层提供的服务的接口（服务访问点，SAP），服务是垂直的。 14、计算机网络通信的分层模型中包含哪些地址信息，分别在哪一层上？ 地址 作用 所在分层 端口（port） 源端口 传输层向应用层提供的地址，以区分不同应用程序的数据 传输层 目的端口 IP地址 源IP地址 网络层提供的地址，以区分不同网络间的收发双方 网络层 目的IP地址 MAC地址 源MAC地址 数据链路层的地址，以区分同一网络内的收发双方 数据链路层 目的MAC地址 第二章 应用层1、网络应用的两种模式（C/S，P2P）C/S：客户——服务器模式，客户向服务器发送请求，服务器响应并提供服务，双方IP地址不能随意改变； P2P：对等模式，任意的主机既是客户端，又是服务器。 2、套接字的概念套接字=IP地址+端口号，用以唯一确定某台主机的某个进程。 IP地址：IPv4为32位、IPv6为128位，用以唯一确定某台主机在因特网上的位置； 端口号：16位，用以唯一确定某台主机的某个通信进程。 3、常见网络应用的端口号端口号为两个字节（16位），范围为0——65535，其中0——1023为公认的保留使用的端口，具有固定的服务进程，1024——65535为用户可以使用的端口号。 以下是常用端口号（参见C:\\Windows\\System32\\drivers\\etc\\services）： 协议 端口号 传输层 定义 ftp-data 20 Tcp FTP，data ftp 21 Tcp FTP，control ssh 22 Tcp SSH Remote Login Protocol telnet 23 Tcp smtp 25 Tcp Simple Mail Transfer Dns 53 Tcp Domain Name Server Udp http 80 tcp World Wide Web pop3 110 tcp Post Office Protocol Version 3 Imap 143 tcp Internet Message Access Protocol https 443 tcp HTTP over TLS/SSL udp 4、DNS 的查询方式-递归查询，迭代查询，反向查询 查询方式 递归查询 迭代查询 反向查询 查询模式 正向查询 反向查询 区别 当根域名服务器不能解析时，其会直接向目标域名的授权域名服务器查询，并将结果返回给发送请求的本地域名服务器。 当根域名服务器不能解析时，其会直接返回目标域名的授权域名服务器地址给发送请求的本地域名服务器，让请求方自行查询。 通过IP地址获得相应的域名地址 5、URL的概念 URL（uniform resource locator），统一资源定位符，用以在整个因特网内唯一标识网上的各种文档和对象，格式为：&lt;URL的访问方式&gt;://&lt;主机地址&gt;:&lt;端口号&gt;/&lt;路径&gt;。 6、HTTP协议的概述，比较http1.0和http1.1HTTP（hyper-text transfer protocol），超文本传送协议，应用层协议之一，也是因特网中最重要的协议之一，通常用于进行web页面的传输，采用C/S模式工作，使用TCP作为传输层协议，默认使用80端口，具体包括HTTP1.0和HTTP1.1两类。 http1.0：非持续连接，使用多条TCP连接获取对象，在完整收到每个对象后才发送下一个对象的请求； http1.1：持续连接，在同一条TCP连接上同时发送多个页面链接的请求，并依次接收。 7、FTP的基本概念 FTP（file transfer protocol），文件传输协议，应用层协议之一，采用C/S模式工作，使用TCP作为传输层协议，FTP属于维护状态的协议，默认使用数据端口为20，控制端口为21。使用两条连接的好处在于使FTP的控制更容易，编程更方便，且使整个传输过程中连接都不断开，更有助于状态的维护。同时，当FTP传输一个文件结束后，控制连接并不断开，如果要下载一个新的文件，仅需控制连接重新协商建立新的数据连接。 8、了解电子邮件相关的协议，smtp，pop，mime，imapsmtp（simple mail transfer protocol），简单邮件传输协议，应用层协议之一，使用TCP作为传输层协议，默认端口为25，使用命令/响应代码（命令：7位ASCII码、响应：状态码和短语）完成邮件传输的控制交互，使用持续连接完成邮件发送，且只能发送文本文件（只能使用ASCII码的限制），另外，SMTP下发送邮件不需要认证（导致垃圾邮件泛滥）； pop（post office protocol），邮局协议，使用TCP作为传输层协议，默认端口为110，用于从邮件服务器接收邮件，现主流使用pop3； mime（multipurpose internet email extension），多功能internet邮件扩展，为了突破smtp只能发送文本文件的限制，smtp使用扩展mime将非文本文件采用base64或quoted printable编码（适用于当所传输的数据中只有少量的非ASCII码，例如：汉字）成文本文件； imap（internet message access protocol），internet邮件访问协议，使用TCP作为传输层协议，默认端口为143，向客户提供在线（邮件保留在服务器并管理）、离线（邮件保留在客户本地并管理）、分离（邮件一部分在服务器，一部分在本地）三种操作模式，并允许客户只读取邮件的某一部分（使客户快速了解邮件关键信息），兼具pop3和webmail的优点，现主流使用imap4。 9.DNS中RR的类型 type Value A 域名对应的IP地址 NS 域名对应的权威域名服务器名称 CNAME 域名对应的别名 MX 域名对应的邮件服务器名称 PTR Name对应的名字（反向查询） 10.电子邮件系统的组成用户代理：电子邮件客户端软件 邮件服务器：提供邮件服务的主机 邮件发送和接收协议 11. 常用 cmd 指令nslookup：域名查询，查询internet域名信息 ftp：传送文件 telnet：远程控制，使用方法 ping：可以检查网络是否连通 tracert：用于确定 IP 数据包访问目标所采取的路径 netstat：查看在内核中访问网络及相关信息的程序 ipconfig：可用于显示当前的TCP/IP配置的设置值 arp：可查看局域网内IP与MAC地址的对应，静态配置记录，情况记录等 第三章 传输层1、比较传输层和网络层传输层负责端到端之间的数据传输的控制。传输层依赖于网络层的服务，传输层向应用层提供服务。网络层主要为主机之间如何选路而到达目的端提供服务，而传输层加强了网络层的服务，在数据能到达对方的前提下，对数据传输进行控制，为进程间的通信提供服务。 2、比较UDP和TCP 传输服务 UDP TCP 可靠性 不可靠 可靠 设计理念 尽力而为，可以乱序甚至丢失 必须保证数据正确、按序到达接收端。采用（1）序号机制；（2）确认机制；（3）缓存机制；（4）重传机制；（5）滑动窗口机制 面向连接 否 是 流量控制 否 是 拥塞控制 否 是 “三次握手” 否 是 协议首部 0 15 16 31 源端口 目的端口 长度（包括首部和数据） 校验和 应用层数据 0 15 16 31 源端口 目的端口 序号 确认号 首部长度 保留 U R G A C K P S H R S T S Y N F I N 窗口 检验和 紧急指针 选项（长度可变） 填充 应用层数据 3、可靠传输协议的机制可靠传输协议保证数据正确按序的到达对方。其中包括以下机制： \\1. 查错机制：用于检查数据是否传输出错的校验算法，如校验和,cRC循环冗余检验码等. \\2. 序号确认机制:序号用于重复分组的检查和防止乱序.确认用于反馈是否正确收到. \\3. 重传机制:出错的包重传,使用缓存提高重传效率. \\4. 超时定时器机制:用于判断数据是否丢失,超时就认为丢失,丢失就重传. 可靠传输协议可以分成两大类:停止等待协议和滑动窗口协议. 停止等待协议：SW（stop and wait），发送方每发送一个报文，必须等待接收方确认后才能发送下一个报文。 rdt1.0：在信道完全可靠地前提下（数据不会出错和乱序），无需做其他处理即可实现停等协议； rdt2.0：在信道可能出错的前提下（数据乱序但不会丢失），使用ACK/NAK机制，发送方建有数据缓存，当收到ACK后发送下一分组，收到NAK则重传； rdt2.1： 在信道可能出错的前提下做了进一步的改进，发送方对每个分组0/1循环编号，接收方将对每个收到的分组进行确认，回复数据所编的序号；如遇到重复分组，接收方丢弃并对分组再次确认（仍回复所编序号即可）；如遇到数据错误，则回复上一次正确的确认序号； rdt3.0：在信道中数据可能乱序甚至出错的前提下，发送方在rdt2.1的基础上，进一步通过“超时”机制发现数据丢失（超时不一定数据丢失，此时编号机制仍能控制传输）。 4、滑动窗口协议:GBN和SR \\GBN（go back n-steps）和SR（selected repeat）均属于滑动窗口协议。滑动窗口协议允许发送方在没有收到接收方的ACK的前提下发送多个数据包，因此有以下三点改变：（1）发送方需要使用发送窗口来限制没有收到ACK情况下最多发送的数据量；（2）发送方和接收方均增加缓存；（3）分组序号必须增大。 发送类型 GBN SR 发送方 连续发送至窗口满，然后等待，收到接收方确认后窗口向后移动。某个分组出错或丢失则重传该分组即其后面所以已发送但未收到确认的分组。 某个分组出错或丢失仅重传该分组。 接收方 对按序到达的分组确认，对乱序或错误的分组丢弃，并发送最后一次正确收到的分组的确认。 增加接收缓存（接收窗口），若收到的分组在乱序则缓存该分组，等到按序后再一起提交整个缓存（因此接收缓存一般等于发送窗口大小）。 累积确认 某一分组的确认意味着之前所有分组均正确。 是 否 窗口大小 序号个数-1 序号个数/2 5、掌握TCP的首部字段 0 15 16 31 源端口 目的端口 序号 确认号 首部长度 保留 URG ACK PSH RST SYN FIN 窗口 检验和 紧急指针 选项（长度可变） 填充 应用层数据 源端口号、目的端口号：各占2字节，端口是传输层向应用层提供服务的接口； 序号：占4字节，TCP连接下数据流中的每一个字节都编上一个号，序号字段的值指的是本报文段所发送的数据的第一个字节的编号； 确认号：占4个字节，是期望收到对方的写一个报文段的第一个字节的序号（下一报文段序号字段），当有数据发送给对方时顺便确认，当没有数据发送给对方时单独发一确认报文； 首部长度：占4位，表示TCP首部的字节数，该字段限制了TCP首部最大值为60字节； 保留：占6位，保留为今后扩展使用，目前全部置为0； 特殊标记：各占1位，（1）URG——紧急标记，值为1时，紧急指针字段有效，通知本报文段有紧急数据，应尽快传送，紧急数据的优先级要高；（2）ACK——确认标记，值为1时，确认号字段有效，正常情况下只有第一次握手时ACK=0；（3）PSH——推送字段，值为1时，接收方在收到该报文段的数据就尽快将其交付给应用进程，而不再等到整个缓存填满；（4）RST——复位标记，值为1时，表明TCP连接中出现严重差错（主机崩溃等），必须强行释放连接，属于单方面强行断开连接；（5）SYN——同步标记，值为1时，表示是一个连接请求报文，正常情况下只有第一次握手和第二次握手时SYN=1，其余时SYN=0；（6）FIN——终止标记，值为1时，表示发送方的报文段数据已发送完毕，请求对方释放该连接，当接收方确认后，发送方将释放发送缓存； 窗口：占2字节，窗口字段是流量控制的关键，用来控制对方发送窗口的大小（单位为字节），接收方根据自身的窗口大小确定自己的接收窗口大小，然后通知发送方以确定对方窗口大小的上限； 检验和：占2字节，检验范围包括首部和数据两个部分，在计算检验和时，要在报文段前加12个字节的伪首部（TCP、UDP检验时均需增加伪首部字段）； 紧急指针：占2字节，紧急指针指出本报文段中紧急数据的最后一个字节的序号； 选项：长度可变，4位以内，目前仅规定了最大报文段长度MSS（maximum segment size），用以告知对方自己所能接收的报文段的数据字段的最大长度； 填充：将选项字段填充至4个字节，从而保证首部长度字段的有效性和计算检验和的有效性。 6、掌握TCP的序号和确认机制序号：TCP首部的序号基于字节。建立连接之初，发送方随机生成初始序号，之后收发双方的每个字节都对应一个编号，而TCP首部中的序号是该报文段中第一个字节的编号； 确认：TCP首部的确认号是期望对方发送的下一个数据的第一个字节的编号，即对方下一个报文段的序号。如果某个报文段没有携带任何数据，对方不需要对该报文做确认，即对方确认号不变，但对于特殊报文，如SYN=1的报文（建立连接），FIN=0的报文（断开连接），对方必须做确认，因此确认号将加1。 TCP属于累积确认，乱序到达数据会缓存。 7、掌握TCP三次握手和断开连接的详细过程 过程 （A、B双方） 三次握手 四次挥手断开连接 正常断开 异常断开 A-&gt;B 第1次 A随机初始化自己的序号SN(A)，确认号置0，初始化窗口大小，SYN=1请求建立连接。 第1次 A：确认号为SN。(B)’+1，ACK=1，FIN=1请求断开连接。 A：确认号为SN。(B)’+1，ACK=1，RST=1请求异常中断。 B-&gt;A 第2次 B随机初始化自己的序号SN(B)，确认号为SN(A)+1，初始化窗口大小，ACK=1表示B对A的确认，SYN=1请求建立连接。 第2次 B：确认号为SN(A)’+1，ACK=1。 B：确认号为SN(A)’+1，ACK=1。 第3次 B：序号和序列号均与上一次相同，ACK=1，FIN=1请求断开连接。 A-&gt;B 第3次 确认号为SN(B)+1，ACK=1表示A对B的确认，SYN=0。 第4次 A：确认号为SN(B)’+1，ACK=1。 8、TCP的流量控制方法首部定义了窗口大小：接收方明确通过首部窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值，而发送方保证发送窗口大小不超过对方发送的接收窗口的大小； 9、掌握TCP的拥塞控制思想第一、使用拥塞窗口cwnd控制发送窗口大小，发送窗口上限值=MIN（rwnd，cwnd）；第二、分组超时则认为拥塞，反之收到确认则认为网络未拥塞；第三、拥塞则少发（cwnd减小），未拥塞则多发（cwnd增大）；第四、网络未知的情况下，cwnd从最小开始，收到确认后cwnd逐渐增大；第五、为提高效率，开始增加速度快，到了一定阶段后增速变慢。 慢启动阶段：窗口初始值（假设为1）指数规律增长（2、4、8……），至慢开始门限ssthrest（假设为16），当指数增长结果大于ssthrest时，增长至ssthrest； 拥塞避免阶段：从ssthrest（16）起，以线性规律增长N（17、18、19……），直至发生超时（重回慢启动）； 重回慢启动：重回窗口初始值，慢开始门限ssthrest为N值减半（N/2）。 第四章 网络层1、网络层的作用负责将各种不同的网络互联，负责将数据段封装成数据包，关注于分组从一个节点到另一个节点的选路 2、比较数据报网络和虚电路网络（网络层）数据报网络和虚电路网络均为分组交换网络。 分组交换方式 数据报网络 虚电路网络 路由模式 源端向目的端发送分组，远端仅根据目标端选择下一条路，分组会在下一结点选择最优的下一条路，同一文件的不同分组可能沿不同的路传输 远端与目的端间首先建立一条虚拟链路，结点根据分组标签确定所走的虚电路，同一文件的不同分组沿同一条虚电路传输 可靠性 不强，可能形成环路 较好 路由器工作量 相对较小 较高，需要维护每条虚电路的状态 QoS（服务质量保证） 不易实现 容易实现 使用范围 因特网 ATM、帧中继网络 特点 灵活，简单 复杂 数据报网络（因特网模型） 虚电路网络 是否先建立连接 在网络层无连接建立 发送分组前建立一条虚拟电路 选路 一般分组使用目标IP进行路由选择 每个分组携有标签，由标签决定下一跳 各分组的路径 同一文件的不同分组可能走不同路径 在建立连接阶段确定固定路由，所有数据走同一路径 优点 灵活，适应性强，网络成本低 可靠，容易提供Qos，转发速度快 3、IP地址的发展全分类IP地址→子网掩码→无类别域间路由 4、全分类的IP地址 网络号位数 主机号位数 网络个数 主机个数 地址范围 A类 8 24 27-2 224-2 1.0.0.0-126.255.255.255 B类 16 16 214 216-2 128.0.0.0-191.255.255.255 C类 32 8 221 28-2 192.0.0.0-223.255.255.255 D类 224.0.0.0-239.255.255.255 5、有哪些特殊的IP地址（1）广播地址：主机号全1的地址； （2）网络地址：主机号全0的地址； （3）内网地址（私有地址）：10.0.0.0—10.255.255.255,172.16.0.0—172.31.255.255, 192.168.0.0——192.168.255.255（内部网络使用的地址，不能用于公网）； （4）链路本地地址：169.254.0.0——169.254.255.255（无IP地址时由操作系统临时分配的IP地址）； （5）本地环回地址：127.0.0.0——127.255.255.255 （6）本地链路广播地址：255.255.255.255 6、IP网络和物理网络的概念IP网络：IP地址分为网络部分和主机部分，网络部分相同的地址属于同一个IP网络； 物理网络：不经过路由器就可以直接到达的主机唯一同一个物理网络。位于同一物理网络的主机可以直接根据链路层的物理地址寻址； IP地址和物理网络的关系是多对一的，即多个IP网络可以用于同一物理网络，但一个IP网络不可以用于多个物理网络。路由器用于转发不同IP网络的分组。 7、定长掩码的划分和vlsm的划分子网掩码的作用：划分子网，便于管理，提高IP地址利用率 定长掩码（FLSM，fix length subnet mask）：一连串长度不变的数字，通过子网划分确定一个本地区域网路的边界。 （1）确定子网数； （2）确定每个子网的IP数； （3）确定子网掩码； （4）确定每个子网的IP。 由于子网定长，而子网内主机数较少，造成IP地址的浪费，当子网数过多或者单个子网内所需IP数过多时，甚至无法完成子网的划分。 变长掩码（VLSM，variable length subnet mask）：根据不同网段中不同的主机数使用不同长度的子网掩码，即可在某一子网（如/27）中进一步划分出若干个子网（如/30）来。 注意：子网之间通信需要路由器，子网是主机号中划分的，若出现多条路由同时匹配时采用掩码最长前缀匹配原则选择路径。 8、CIDR地址的表示和路由汇总CIDR（classless inter-domain routing，无类别域间选路）：取消IP地址的分类限制，以改善IP地址的分配方式，缓解IP地址的危机。CIDR利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度。 CIDR地址的IP地址有前缀和掩码决定，如10.12.1.1/12其网络号为255.240.0.0，CIDR地址进行路由匹配时采用最长前缀匹配原则。。 路由汇总：将连续的多个网络地址汇总为一个网络地址，与层次物理网络结合，能极大的减少路由器上路由表的规模。将多个网络（可以使匪类网络）汇总成一个CIDR地址块，形成“超网”，属于不精确汇总（所以属于汇总后的地址块都属于汇总前的地址块称为精确汇总，否则称不精确汇总），不精确汇总可能导致错误的路由。 9、掌握IP**协议的首部（分片的方法）IP协议是无连接、不可靠的协议，包括IPv4和IPv6两个版本。其中，IPv4包括20个字节的固定首部和长度可变的可选首部。 0 15 16 31 版本 首部长度 服务类型 总长度 标识 标志 片偏移 生存时间 协议 首部检验和 源地址 目的地址 可选字段（长度可变） 填充 数据部分 版本：占4位，表示IP协议版本，IPv4版本值为4； 首部长度：占4位，表示首部的单位长度（每单位4字节），故首部最大长度为60字节； 服务类型：占1字节， 0 1 2 3 4 5 6 7 优先级 D T R C 未用 设置数据包的重要性。值越大数据越重要。 延迟。1：期待低延迟。 流量。1：期待高流量。 可靠性。1：期待高可靠性。 成本。1：期待最小成本。 总长度：占2字节，表示首部和数据的总长度（单位为字节），故数据报的最大分组长度为65535字节（含IP首部），最大数据长度为65515字节（假设首部20字节），但总长度不允许超过MTU（maximum transmission unit，最大传送单元），否则将其分片； 标识：占2字节，分组超过MTU时会进行分片，同一分组的不同分片标识相同； 标志：占3位，包括DF、MF两个标志。DF=1表示该分组不允许分片，MF=1表示该分组后面还有分片； 片偏移：占13位，指出该分片在原分组的位置，以8个字节为单位； ​ 生存时间：占1字节，TTL，表示数据报在网络中的寿命，其单位为秒（实际单位为跳），分组没经过一个路由器就TTL就减1，当路由器收到TTL=0的分组时会将其丢弃，TTL能有效的避免该分组在网络上无限循环的转发； 协议：占1字节，指出数据报携带的数据使用上层的何种协议，从而帮助目的主机的网络层将数据部分上交给哪个处理过程； 首部校验和：占2字节，字段只检验数据报的首部，不包括数据部分； 源地址、目的地址：各占4字节，表示发送接收方的IP地址，一般路由器不会改变分组的源IP地址和目的IP地址； 可选字段：小于4字节，主要用于网络测试和调试，实际一般不用； 填充：将可选字段填充至4字节。 10、ICMP的基本工作原理ICMP：internet控制报文协议（internet control message protocol），用于因特网的传输控制和差错报告，主要用于分组传输过程中的异常报告，包括：（1）目标地址不可达，（2）网络拥塞，（3）TTL到期，（4）IP分组检验和失败； ICMP首部： 0 15 16 31 类型（不同差错） 代码 检验和 （取决于类型） 数据部分 ICMP封装： IP首部 ICMP首部 出错分组首部 出错分组数据前8字节 出错分组数据其余字节 出错分组 ICMP差错报告报文 注意：（1）对出错的ICMP差错报告报文不再发送ICMP差错报告报文；（2）对某一分片后的分组，仅发送第一个分片的ICMP差错报告报文，后续分片不再发送；（3）组播地址数据不发送ICMP差错报告报文；（4）对特殊地址（如127.0.0.0或0.0.0.0）的数据不发送ICMP差错报告报文。（4）ping使用了ICMP的回送请求与回送响应报文。（5）tracert使用了ICMP的控制协议与TTL 11、NAT的分类和作用NAT（network address translate），网络地址转换，用于IP地址的转换。 NAT的分类 类型 定义 缺点 比较 静态NAT 将内网数据报的源IP地址一对一的转换成外网的IP地址 无法缓解IP地址危机 静态NAT内网IP与外网IP是一一对应的，而动态NAT的地址转换是临时的。 动态NAT池 将外网合法的IP地址形成可用的NAT池。内网IP需要上网时，从NAT中去一个可用的IP地址 无法所以内网IP同时上网 端口NAT（PAT） 服务器根据TCP/UDP端口号映射 NAT的作用：（1）解决多个用户使用一个公网IP上网的问题，缓解了IP地址危机；（2）实现内部IP地址影藏及服务器负载均衡。 12、DHCP的基本工作原理DHCP（dynamic host configuration protocol），动态主机设置协议，采用C/S模式，使用UDP协议工作，服务器端口号为67，客户端端口为68，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址、租用期的相关信息。 客户端 端口号 工作过程 端口号 服务器 服务器被动打开UDP端口67，等待客户端发来的报文 67 服务器 客户端 68 DHCPDISCOVER 客户通过UDP端口68广播DHCP发现报文 67 服务器 客户端 68 DHCPOFFER 服务器发送广播报文声明可以提供IP地址 67 服务器 客户端 68 DHCPREQUEST 客户广播请求IP地址 67 服务器 客户端 68 DHCPACK 服务器广播发送IP地址、网关等，客户允许租用期内使用IP 67 服务器 客户端 68 DHCPREQUEST 租用期即将到期，发送续约请求。如果服务器同意则继续使用该IP，否则返回第2步重新申请 67 服务器 DHCP中继代理：广播DHCPREQUEST请求，中继代理单播向其他网络的DHCP服务器，获取IP地址。 13、路由的概念及分类概念：根据目标网络选择最“好”路径 分类：从路由获取方式可分为：直连路由、静态路由、动态路由 从路由匹配数量可分为：目标路由、特定主机路由、默认路由 14、比较距离向量路由算法和链路状态路由算法距离向量路由算法和链路状态路由算法均属于动态路由协议（让路由器通过交换信息自动获得路由信息）。 算法 距离向量算法（DV算法）（RIP） 链路状态路由算法（LS算法）（OSPF） 原理 （1）周期性向邻居通告自己的路由信息； （2）根据邻居通告使用加法更新自己的距离向量表； （3）路由表改变时，继续通告邻居； （4）网络中所有路由表没有改变时，算法终止 （1）将自己的链路状态洪泛到网络上的所有路由器； （2）每个路由器最终会知道整个网络的拓扑结构； （3）使用Dijstra算法最短路径算法计算自己与其他路由器最短路径，更新路由表； （4）链路状态变化时，继续洪泛 特点 好消息传的快，坏消息传的慢（形成路由环路） 可能产生路由震荡 范围 邻居之间 整个网络 收敛时间 不稳定 稳定 健壮性 不好 好 例子 RIP、BGP OSPF 15、掌握RIP的工作原理和配置方法RIP使用距离向量路由算法，使用UDP进行传输（端口为520），按固定的时间间隔交换路由信息（30s）。RIP将距离定义为“跳数”，每经过一个路由器跳数加1，规定最大值为15（16即相当于不可达）。使用毒性逆转（即向某条路由对应的出接口通告该路由为无穷大路由）等方法缓解环路影响 RIP包括RIP1和RIP2。RIP1通过广播通告路由信息，不支持验证和CIDR，RIP2通过组播通告路由信息，支持验证和CIDR。 配置方法略。 16、IGP和EGP的分类为解决路由信息过多，更新缓慢的问题，使用自治系统（AS，由一个管理部门管理的具有相同路由策略的网络系统）管理网络系统。同一AS内的路由器使用相同的路由协议称IGP（内部网关协议），如RIP、OSPF；AS之间的路由器使用的路由协议称为EGP（外部网关协议），如BGP。其中网关路由器同时运行IGP和EGP。 17、OSPF路由协议使用链路状态路由算法，无路由自环，支持区域划分适用于大规模网络，支持CIDR、VLSM，支持验证，使用组播方式发送协议报文，基于IP，为停等协议，自身可实现可靠传输，收敛速度快，链路代价为108/网络带宽 OSPF使用路由器标识（32位无符号整数，整个自治系统唯一）唯一确定OSPF路由器 OSPF划分区域来减少洪范范围，其中ABR负责区域之间的信息传递，它使用距离矢量算法 OSPF支持的网络拓扑结构：广播式多点接入网络、点到点网络、点到多点网络等 在全连通网络中，选取DR（村长）和BDR，DR负责通告路由 18、BGP协议防止路由发生的方法路由信息中携带丰富的路由属性，AS-PATH属性记录BGP路由所经过的自治系统号，当某个BGP路由器收到一条包括自己所在自治系统的路由时丢弃 19、组播IP地址范围224.0.0.0 - 239.255.255.255 20、IGMP，RPF转发机制和PIM-SMIGMP：组成员管理协议（Internet Group Management Protocol），主机通过IGMP协议通知本地路由器希望加入并接收某个特定组的信息，路由器通过IGMP周期性查询局域网内某个组是否还存在。 RPF转发机制：逆向路径转发（Reverse Path Forwarding），以防止组播报文在网络转发中形成环路。组播接收到报文后必须根据源和目的地址确定上游（指向组播源或汇集点）和下游（远离组播源或汇集点），RPF转发机制就是讲组播报文从上游向下游转发。 PIM-SM：协议无关稀疏式组播，目前组播的标准协议，适用于组成员分布较广的情况，采用共享式和信源树相结合的方式。PIM-SM使用拉的方式，组播信息发送到被拉入网络中的接收站点。 21、IPv6的基本概念IPv6报文结构： IPv6首部 扩展首部1 …… 扩展首部n 数据部分 选项 有效载荷 IPv6首部： 0 15 16 31 版本 通信量类 流标号 有效载荷长度 下一个首部 跳数限制 源地址（128位） 目的地址（128位） 数据 版本：占4位，指明协议版本号； 通信量类：占1字节，区分不同IPv6数据报或类别； 流标号：占20位，属于同一“流”（从特定源到目的的一系列数据报）的数据报具有同样的流标号，流所经过的路由器保证指明的服务质量； 有效载荷长度：占2字节，除首部外的数据长度（包括扩展首部），故最大长度为64KB； 下一个首部：占1字节，相当于IPv4中的协议字段； 跳数限制：占1字节，远端在数据发出时设置跳数限制，路由器每转发一次跳数减1，跳数为1时将被丢弃； 源地址、目的地址：各占4字节。 22、IPV6针对IPV4改进增加IP地址范围，尽可能减少路由器的额外工作，提高路由器转发分组的速度，更好的实现路由汇总，更好实现Qos提高协议的灵活性，增加了移动性和安全性。 第五章 数据链路层1、比较数据链路层和传输层数据链路层：负责一段链路的两端之间的通信，由网卡负责数据链路层的协议。 服务层 传输层 数据链路层 通信 收发双方主机到主机 一段链路端到端 范围 整个网络（可以跨越局域网） 同一局域网内 服务对象 应用层，端口 物理层，MAC地址 2、网卡的作用（1）数据的封装与解封：发送时将收到的上层分组加上首部和尾部形成以太网的帧并通过物理层发出（封装），接收时则将收到的分组剥去首部和尾部形成分组并送交上层（解封）； （2）链路管理：实现CSMA/CD（Carrier Sense Multiple Access with Collision Detection），带冲突检测的载波监听多路访问； （3）编码与译码：实现曼彻斯特编码与译码。 3、比较IP地址和MAC地址 地址类型 IP地址 MAC地址 定义 因特网上不同网络间能够通信的唯一地址 局域网中固化在硬件上的地址 目的 不同网段间的通信 同一网段内结点间通信 长度 IPv4：32位（4字节），IPv6：128位（16字节） 48位（6字节） 范围 因特网（广域网） 局域网 所在TCP**层** 网络层 数据链路层 获取对方地址方式 DNS ARP 4、CRC冗余检验的计算方法，奇偶校验可以纠错CRC冗余检验：待校验码除以一个约定好的除数，若能除尽（余数为0）则校验正确，反之出错，CRC冗余校验查错率高，能纠错。 CRC冗余检验具体做法：（1）数据比特流看成二进制数据作为被除数D；（2）选择一个n位的二进制数作为除数G（随机生成多项式+1，如x5+x2+1，即100101）；（3）发送方采用异或方式D除以G得到余数R，即为CRC冗余校验码。 奇偶校验：通过在数据后添加1位，保证新的数据中1有奇数个。一维奇偶校验能查错，二维奇偶校验能纠错（1位）。 5、FDMA，TDMA，CDMAFDMA、TDMA、CDMA均属于信道分割技术。 FDMA：frequency division multiple access，频分复用。信道按频率分割成若干频段，每个站点分得固定的频段，该站点不用时相应频段被闲置浪费；频分复用使用不同频率的载波将信号调制到不同频段上。 TDMA：time division multiple access，时分复用。信道根据时间分成多个固定长度的时间片，每个用户允许在不同的时间片上传输信息，某个时间片上无用户传送信息则导致信道浪费。TDMA分成同步时分复用和异步时分复用（统计时分复用） CDMA：code division multiple access，码分复用，大部分用于无线通信场合，用户共享相同频道，每个用户用自己的码片序列对数据编码，允许多用户共存和发送信号，对相互的干扰极小。 6、CSMA/CD的工作原理CSMA/CD（Carrier Sense Multiple Access with Collision Detection），带冲突检测的载波监听多路访问，其核心思想包括： （1）先听后讲：信道空闲则讲，反之等待； （2）边听边讲：发送信号时不断检测是否碰撞； （3）碰撞即停； （4）退避重传：二进制指数退避算法重传； （5）多次碰撞，放弃发送：最多16次。 二进制指数退避算法：（1）确定基本退避时间，一般为争用期2τ（端到端的往返时延）；（2）定义重传次数k（k≤10）；（3）从整数集合{0,1,…,2k-1}中随机取一数记为r，则重传时退避时延为r*2τ；（4）重传16次仍不成功则丢弃该帧，并向高层报告。 最短帧长的概念和计算方法。 7、ARP的工作原理ARP：通过IP地址获得MAC地址。 工作原理：（1）发送方A向接收方B发送数据前，查看本地的ARP缓存表，若没有则广播发送ARP请求包；（2）局域网内主机和网关均将A的Mac地址记入ARP缓存表，但不响应；（3）接收方若在局域网内，B收到广播请求后向A单播发送响应ARP报文；（4）接收方若不在局域网内，则向网关获取B的MAC地址，网关ARP缓存表中有则直接回复响应，若没有则继续发送ARP请求报文。 8、最短帧长的作用和计算方法传统的以太网的最短帧长为64字节，从而确保碰撞帧的检测，小于64字节的帧被认为是碰撞帧，因此，实际发送数据小于64字节时会被自动填充。 最短帧长=带宽×争用期 9、各种网络设备的作用 设备 所在服务层 作用/ 工作方式 碰撞域 广播域 CSMA/CD 解决环路问题 以太网类型 中继器（Repeater） 物理层 用于信号的调整、复制、放大 共享式以太网 集线器（Hub） 物理层 多端口中继器。通过广播实现单播 连接到集线器的主机或集线器的级联都属于一个碰撞域 不隔离广播域 不使用 网桥（Bridge） 数据链路层 根据帧的MAC地址决定转发出口，MAC地址和端口的对应存在缓存中（端口和MAC地址时一对多的关系，有生存时间） 隔离碰撞域 不隔离广播域 使用CSMA/CD 生成树协议（spanning tree）：（1）将环路变为生成树结构；（2）确定根网桥；（3）确定根端口（指向根网桥的最短路径的出口）；（4）每个网段确定一个指定端口（非指定端口阻塞时无法转发帧） 二层交换机（2-layer Switch） 数据链路层 多端口网桥，帧转发基于硬件根据目标MAC地址决定转发出口，可连接不同带宽的以太网，MAC地址和端口的对应存在缓存中。采用源地址学习机制，广播未知帧和广播帧，单播已知帧 隔离碰撞域 不隔离广播域（未划分VLAN） 半双工模式下使用CSMA/CD 交换式以太网 路由器（Router） 网络层 基于软件转发分组（速度较慢），用于连接异构的网络。根据IP地址查找路由表，决定转发路径，未知分组直接丢弃，不会广播 隔离碰撞域 隔离广播域 三层交换机（3-layer Switch） 路由模式/交换模式 路由模式下和路由器一样实现IP层转发，交换模式下与二层交换机相同。与路由器相比，三层交换机交个便宜，转发基于硬件（速度快），但只限于同种局域网段（路由器可以连接异构的网络） 10、网桥和二层交换机的工作原理源地址学习机制，已知帧单播，未知帧广播。 11、碰撞域（冲突域）和广播域的判断一个CSMA/CD网络即是一个碰撞域，基于物理层。网络设备中中继器（Repeater）和集线器（Hub）不能隔离碰撞域，网桥、二层交换机、路由器和三层交换机可以隔离碰撞域。 广播域(Broadcast Domain)是指网段上收听送往所在网段的所有广播的所有设备的集合，基于数据链路层。只有路由器和三层交换机可以隔离广播域。 交换机上有多少个端口连到了网络，就有多少个碰撞域；路由器上有多少个端口连到了网络，就有多少个广播域。 12、T568A和T568B的接线顺序T568A：半绿、绿、半橙、蓝、半蓝、橙、半棕、棕 T568B：半橙、橙、半绿、蓝、半蓝、绿、半棕、棕 13、直通线和交叉线直通线两端都使用T568B连线，一般用于不同设备 交叉线一段使用T568B连线，一段用T568A连线，一般用于相同或相近的设备 14、MAC地址的基本特点单播MAC地址：固化在网卡上，十六进制表示：AC-DE-48-D0-00-80，二进制表示：第八位必须为0. 广播MAC地址：FF-FF-FF-FF-FF-FF 组播MAC地址：组播MAC地址通过组播IP地址后23位映射而成 15、多模光纤和单模光纤 多模光纤 单模光纤 核心直径 大 小 光传播模式 以多路径或多模式传播 以一种模式无散射传播 带宽 低 高 光源 LED光源 激光光源 适合距离 短距离 长距离 16、以太网的两大标准商业标准Ethernet V2、官方标准802.3（增加了LLC子层） 17、以太网帧的结构网络层 数据 数据链路层 目的地址 源MAC地址 类型 数据 FCS（CRC） 物理层 前导符 10110010…………………………………………………………………………………………………….10101011 前导符：用于收发双方同步 18、以太网的特性以太网提供无连接不可靠的服务。 以太网对于出错的帧(CRC校验失败)直接丢弃，不重传。 共享式（半双工）以太网使用CSMA/CD协议处理碰撞。 以太网最短帧长定为64字节(或者以太网的最小数据定为46字节），小于64字节的帧被认为是碰撞帧，实际发送数据小于46字节时会自动填充。对于碰撞帧最多重传16次。 传统10M以太网帧间间隔为9.6 s。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.whkblog.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"https://www.whkblog.work/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"马克思主义原理概论知识点总结","slug":"马克思主义原理概论知识点总结","date":"2021-01-08T13:07:31.000Z","updated":"2021-01-12T08:43:19.166Z","comments":true,"path":"2021/01/08/马克思主义原理概论知识点总结/","link":"","permalink":"https://www.whkblog.work/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"◆ 绪论一：马克思主义来源与创新 来源：德国古典哲学，英国古典政治经济学，英法空想社会主义 创新：马克思恩格斯批判地继承了前人的成果，创立了唯物史观和剩余价值学说，实现了人类思想史上的伟大革命。他们在这一时期创立的马克思主义，对人类先进思想已经提出的种种问题作了分析批判，对资本主义时代发展提出的理论课题作了科学的论述。马克思主义哲学为认识历史和时代问题提供了一种崭新的世界观和方法论原则。马克思主义政治经济学通过对资本主义生产方式的内在矛盾、运行机制和发展规律的深刻分析，揭示了资本主义剥削的秘密和它被社会主义必然代替的历史命运。科学社会主义在唯物史观和剩余价值论两大发现的基础上，阐明了由资本主义社会转变为社会主义、共产主义社会的客观规律，阐明了无产阶级获得彻底解放的历史条件和无产阶级的历史使命，使社会主义由空想成为科学。 二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征） 辩证唯物主义与历史唯物主义是马克思主义最根本的世界观和方法论 三：马克思主义最鲜明的政治立场是什么 马克思政党的一切理论和奋斗都应致力于实现以劳动人民为主体的最广大人民的根本利益，这是马克思主义最鲜明的政治立场 四：马克思主义最重要的理论品质 坚持一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理，是马克思主义最重要的理论品质 五：马克思主义最崇高的社会理想 实现物质财富极大丰富、人民精神境界极大提高、每个人自由而全面发展的共产主义社会，是马克思主义最崇高的社会理想 六：对待马克思主义的态度 必须坚持马克思主义不动摇，这是就马克思主义的基本原理、基本观点和基本方法而言的。随着时代的发展和历史条件的变化，要求我们在坚持马克思主义基本原理的基础上，不断地在实践中丰富和发展马克思主义。我们一定要适应实践的发展，以实践来检验一切，用发展着的马克思主义指导新的实践。我们必须坚持解放思想、实事求是、与时俱进，从理论和实践的结合上不断研究新情况、解决新问题，做到自觉地把思想认识从那些不合时宜的观念、做法和体制的束缚中解放出来，从对马克思主义的错误的和教条式的理解中解放出来，从主观主义和形而上学的桎梏中解放出来，不断有所发现、有所创造、有所前进。 ◆ 第一章一：近代哲学的基本问题 全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题 二：马克思主义物质的定义 物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映——列宁 三：马克思主义物质观理论意义 第一：坚持了物质的客观实在性原则，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。第二：坚持了能动的反映论和可知论，有力的批判了不可知论。第三：体现了唯物论和辩证法的统一。第四：体现了唯物主义自然观与唯物主义历史论的统一，为彻底的唯物主义奠定了理论基础。 四：联系特征 首先，联系具有客观性。其次，联系具有普遍性。最后，联系具有多样性。 五：发展的知识点 实质：是新事物的产生和旧事物的灭亡。 新旧事物：新事物是指合乎历史前进方向、具有远大前途的东西； 旧事物是指丧失历史必然性，日趋灭亡的东西 为什么新事物是不可战胜的？ ①新事物符合事物发展的必然趋势，具有强大的生命力和远大的发展前途，而旧事物丧失了存在的必然性，失去了生命力和发展前途，因而必然被新事物所代替。② 新事物优越于旧事物。新事物否定了旧事物中腐朽过时的东西，吸收并发展了旧事物中积极的因素，添加了旧事物中不能容纳的新的内容。③ 在社会领域中，新事物符合广大人民群众的根本利益和要求，因而得到广大人民群众的拥护和支持，它必然战胜旧事物。 六：矛盾的同一性，斗争性 矛盾的同一性：是指矛盾者双方相互依存、相互贯通的性质和趋势。 矛盾的斗争性：是矛盾者的对立面之间相互排斥、相互分离的性质和趋势。 七：矛盾的普遍性，特殊性 矛盾的普遍性：矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。 矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有不同特点；三是构成事物的诸多矛盾以及每一矛盾的不同方向各有不同的性质。 八：量变，质变 量变：事物数量的增减和次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物渐进过程的连续性。 质变：事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物渐进过程和连续性的中断。 量变和质变的辩证关系：1）量变是质变的必要准备 2）质变是量变的必然结果 3）量变和质变是相互渗透的 九：肯定，否定 肯定：维持现成事物存在的因素 否定：促成现成事物灭亡的因素 十：意识的作用 第一，意识是能动的，具有目的性和计划性。第二，意识活动具有创造性。第三，意识具有指导实践改造客观世界的作用。第四，意识还具有指导、控制人的行为和生理活动的作用。 十一：主观能动性与客观规律的辩证统一 首先，必须尊重客观规律。其次，在尊重客观规律的基础上，要充分发挥主观能动性。 ◆ 第二章一：实践在认识中的决定作用 第一，实践产生了认识的需要。第二，实践为认识提供了可能。第三，实践使认识得以产生和发展。第四，实践是检验认识的真理性的唯一标准。 二：马克思主义认识的本质是什么 认识是主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。 三：运动的基本规律 运动是一个辩证发展过程：从实践到认识；从认识到实践；实践、认识、再实践、再认识，认识运动不断反复和无限发展。 四：感性认识理性认识辩证关系 首先，理性认识依赖于感性认识，理性认识必须以感性认识为基础。坚持理性认识对感性认识的依赖关系，就是坚持了认识论的唯物论。其次，感性认识有待于发展和深化为理论认识。只有使感性认识上升到到理性认识，才能把握事物的本质，满足实践的需要。坚持了这一点，就是坚持了认识论的辩证法。最后，感性认识和理性认识相互渗透，相互包含，二者的区分是相对的，人们不应当也不可能把它们截然分开。 五：认识发展的总过程 从实践到认识，再从认识到实践如此实践、认识、再实践、再认识，循环往复以至无穷，一步步地深化和提高，这就是认识发展的总过程。 六：真理的客观性、绝对性和相对性 客观性：真理具有客观性，凡真理都是客观真理。首先，真理的内容是客观的。其次，检验真理的标准也是客观的 绝对性：即具有绝对性的真理，是指真理的无条件性，无限性。 相对性：即具有相对性的真理，是指真理的有条件性，有限性。 七：实践作为检验认识真理性的标准的确定性和不确定性 实践作为检验认识真理性的标准的确定性即绝对性，是指实践作为检验认识真理性的标准的唯一性，即离开了实践，再也没有另外的标准。 实践作为检验认识真理性的标准的不确定性即相对性，是指实践对认识真理性的检验的条件性。即任何实践都受到一定具体条件的制约，因而都具有一定的局限。 ◆ 第三章一：社会存在与社会意识及其辨证关系 社会存在:也称社会物质生活条件，是社会生活的物质方面，主要是指物质生活资料的生产及生产方式，也包括地理环境和人口因素。 社会意识：社会生活的精神方面，是社会存在的反映。 辨证关系：社会存在和社会意识是辨证统一的。①社会存在决定社会意识，社会存在的性质决定社会意识的性质，社会存在的变化决定社会意识的变化。②社会意识是社会存在的反映，并反作用于社会存在，错误的社会意识会阻碍社会存在的发展，正确的社会意识会促进社会存在的发展。 二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律） ①生产力决定生产关系，生产力的状况决定生产关系的性质，生产力的发展决定生产关系的变革。②第二，生产关系对生产力具有能动的反作用。即当生产关系适合生产力发展时，它对生产力发展起推动作用；当生产关系不适合生产力发展时，它会阻碍生产力的发展。 三：经济基础与上层建筑的矛盾运动规律 经济基础与上层建筑是辨证统一的：①经济基础决定上层建筑。②上层建筑对经济基础具有反作用。当上层建筑适合经济基础状况时，它会促进经济基础的巩固和完善;当上层建筑不适合经济基础状况时，它会阻碍经济基础的发展和变革。 四：人民群众在创造历史过程中的决定性作用 ⑴人民群众从质上说是指一切对社会历史发展起推动作用的人们，从量上说是指社会人口的绝大多数。人民群众的最稳定的主体部分始终是从事物质资料生产的劳动群众及其知识分子。 ⑵在社会历史发展过程中，人民群众起着决定性的作用。 ①人民群众是历史的主体，是历史的创造者。②人民群众的社会物质财富的创造者。③人民群众是社会精神财富的创造者。④人民群众是社会变革的决定力量 ◆ 第四章一：资本的原始积累 ⑴所谓资本原始积累，就是生产者与生产资料相分离，货币资本迅速集中于少数人手中的历史过程。 ⑵资本原始积累主要是通过两个途径进行的：一是用暴力手段剥夺农民的土地；二是用暴力手段掠夺货币财富。 二：商品的二因素和生产商品的劳动二重性 ⑴商品是用来交换的能满足人们某种需要的劳动产品，具有使用价值和价值两个因素，是使用价值和价值的矛盾统一体。 ⑵ 商品是劳动产品，生产商品的劳动可区分为具体劳动和抽象劳动。 三：价值量与价值规律 ⑴ 价值量是由生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量。决定商品价值量的，不是生产商品的个别劳动时间，而只能是社会必要劳动时间。“社会必要劳动时间是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。” ⑵ 商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行，形成价值规律。 ⑶ 价值规律的表现形式是，商品的价格围绕商品的价值自发波动。 ⑷ 价值规律的作用表现在：第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。第二，自发地刺激社会生产力的发展。第三，自发地调节社会收入的分配。 四：私有制基础上商品经济的基本矛盾 ⑴ 在私有制为基础的商品经济中，商品生产者的劳动具有两重性：既是具有社会性质的社会劳动，又是具有私人性质的私人劳动。 ⑵ 私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾。 五：劳动力成为商品的基本条件 劳动力成为商品，要具备两个基本条件：第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；第二，劳动者没有别的商品可以出卖，自由得一无所有，没有任何实现自己的劳动力所必需的物质条件。 六：劳动力商品的特点 劳动力商品在使用价值上有一个很大的特点，就是它的使用价值是价值的源泉，它在消费过程中能够创造新的价值，而且这个新的价值比劳动力本身的价值更大。 七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用 ⑴ 雇佣工人的劳动分为两部分：一部分是必要劳动，用于再生产劳动力的价值；另一部分是剩余劳动，用于无偿地为资本家生产剩余价值。因此，剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值，它是雇佣工人剩余劳动的凝结，体现了资本家与雇佣工人之间剥削与被剥削的关系。 ⑵ 不变资本是以生产资料形态存在的资本。可变资本是用来购买劳动力的那部分资本。 八：生产剩余价值的两种基本方法 资本家提高对工人的剥削程度的方法是多种多样的，最基本的方法有两种，即绝对剩余价值的生产和相对剩余价值的生产。绝对剩余价值是指在必要劳动时间不变的条件下，由于延长劳动日的长度而生产的剩余价值。相对剩余价值是指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。 九：资本积累 ⑴ 把剩余价值转化为资本，或者说，剩余价值的资本化，就是资本积累。 ⑵ 由资本的技术构成决定并反映技术构成变化的资本价值构成，叫做资本的有机构成。通常用c∶v来表示。 ⑶ 所谓相对过剩人口，就是劳动力供给超过了资本对它的需要。 十：资本的循环周转与再生产 ⑴ 资本循环是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。 ⑵ 产业资本在循环过程中要经历三个不同的阶段：第一个阶段是购买阶段，即生产资料与劳动力的购买阶段。在这一阶段，产业资本执行的是货币资本的职能。第二个阶段是生产阶段，即生产资料与劳动力按比例结合在一起从事资本主义生产的阶段。执行的是生产资本的职能。第三个阶段是售卖阶段，即商品资本向货币资本的转化阶段。在此阶段产业资本所执行的是商品资本的职能。 ⑶ 社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题。 ⑷ 在现实的资本主义经济生活中，资本家并不是把剩余价值看作可变资本的产物，而是把它看作全部垫付资本的产物或增加额，剩余价值便取得了利润的形态。 十一：资本主义基本矛盾 生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾。 十二：经济危机 实质：经济危机的实质或本质是旧的生产力产能过剩与供给过剩，有效需求饱和与不足 根源：资本主义经济危机爆发的根本原因是资本主义的基本矛盾 周期性：资本主义经济危机具有周期性，这是由资本主义基本矛盾运动的阶段性决定的。当资本主义基本矛盾达到尖锐化程度时，社会生产结构严重失调，引发了经济危机。 十三：资本主义政治制度及其本质 本质：作为资产阶级政治统治工具的阶级本质 ◆ 第五章一：垄断 ⑴ 所谓垄断，是指少数资本主义大企业，为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格，进行操纵和控制。 ⑵ 垄断的产生有以下原因：第一，当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以获得高额利润。第二，企业规模巨大，形成对竞争的限制，也会产生垄断。第三，激烈的竞争给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协，联合起来，实行垄断。 ⑶垄断条件下竞争的特点 第一，垄断没有消除产生竞争的经济条件。第二，垄断必须通过竞争来维持。第三，社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产都包下来。 二：金融资本与金融寡头 金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。 金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。 三：国家垄断资本主义的形成及作用 ⑴ 国家垄断资本主义是垄断资本主义的新发展，它对资本主义经济的发展产生了积极的作用。首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展。再次，通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高。最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通讯及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了这些国家国民经济的现代化进程。 ⑵ 国家垄断资本主义在本质上是资产阶级国家力量同垄断组织力量结合在一起的垄断资本主义。 四：垄断资本主义的实质 帝国主义的实质，即垄断资本凭借垄断地位，获取高额垄断利润。 五：经济全球化 ⑴ 表现：一是生产的全球化。二是贸易的全球化。三是金融的全球化。四是企业经营的全球化。 ⑵ 后果：经济全球化是一个充满矛盾的进程，它在产生积极效应的同时，也会产生消极的后果。主要表现是：其一，发达国家与发展中国家之间的差距扩大。其二，在经济增长中忽视社会进步，环境恶化与经济全球化有可能同时发生。其三，各国特别是相对落后国家原有的体制、政府领导能力、社会设施、政策体系、价值观念和文化都面临着全球化的冲击，国家内部和国际社会都出现不同程度的治理危机。其四，经济全球化使各国的产业结构调整变成一种全球行为，它既为一国经济竞争力的提高提供了条件，同时也存在着对别国形成依赖的危险。 六：当代资本主义新变化的实质 首先，当代资本主义发生的变化从根本上说是人类社会发展一般规律和资本主义经济规律作用的结果。其次，当代资本主义发生的变化是在资本主义制度基本框架内的变化，并不意味着资本主义生产关系的根本性质发生了变化。 七：资本主义的历史地位———过渡的资本主义 八：资本主义为社会主义所代替的历史必然性 （一）资本主义的内在矛盾决定了资本主义必然被社会主义所代替 （二）从资本主义向社会主义过渡是一个长期的历史过程 ◆ 第六章一：无产阶级革命 ⑴ 性质：无产阶级革命是迄今人类历史上最广泛、最彻底、最深刻的革命，是不同于以往一切革命的最新类型的革命。这是因为：第一，无产阶级革命是彻底消灭一切私有制、代之以生产资料公有制的革命。第二，无产阶级革命是要彻底消灭一切阶级和阶级统治的革命。第三，无产阶级革命是为绝大多数人谋利益的运动。 ⑵ 从理论上说，无产阶级革命有暴力的与和平的两种形式。 二：东欧剧变、苏联解体教训 最深刻的教训是：放弃了社会主义道路，放弃了无产阶级专政，放弃了*的领导地位，放弃了马克思列宁主义，结果使得已经相当严重的经济、政治、社会、**进一步激化，最终酿成了制度剧变、国家解体的历史悲剧。 三：社会主义的本质 社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。 四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性 第一，生产力发展状况的制约。第二，经济基础和上层建筑发展状况的制约。第三，国际环境的严峻挑战。第四，马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的艰苦的过程。 五：社会主义在曲折中前进的客观性 第一，社会主义作为新生事物，其成长不会一帆风顺。社会主义的产生和成长，意味着对资本主义旧社会的否定，这就必然要遭到资本主义势力的拼死反抗。社会主义新社会在开始的时候总是比较弱小的，而且在一个相当长的时期里，社会主义和资本主义的矛盾和斗争是不会停止的，时起时伏，有时甚至相当激烈，资本主义还可能会复辟，这就注定社会主义战胜资本主义的过程是一个曲折的发展过程。第二，社会主义社会的基本矛盾推动社会发展，是作为一个过程而展开的，人们对它的认识也有一个逐渐发展的过程。社会主义的基本矛盾推动社会发展，体现了生产关系一定要适合生产力状况的规律、上层建筑一定要适合经济基础状况的规律。由于受主观和客观条件的限制，对社会主义社会基本矛盾运动的规律和社会主义建设规律的认识有一个过程。只有尊重社会主义发展的客观规律，在实践中自觉地运用规律，及时研究新情况、有效地解决前进中出现的矛盾和问题时，社会主义事业才能够顺利地向前发展。 ◆ 第七章一：共产主义社会的基本特征 （一）物质财富极大丰富，消费资料按需分配 （二）社会关系高度和谐，人们精神境界极大提高 （三）每个人自由而全面的发展，人类从必然王国向自由王国的飞跃 二：确理解“两个必然”和“两个决不会”的关系 马克思恩格斯在《***宣言》中提出：“资产阶级的灭亡和无产阶级的胜利是同样不可避免的。”这就是我们常说的资本主义必然灭亡和社会主义必然胜利的“两个必然”（或“两个不可避免”）。后来，马克思在《〈政治经济学批判〉序言》中又提出了“两个决不会”，即：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。” “两个必然”和“两个决不会”有着内在的联系，应该结合起来加以理解。 “两个必然”和“两个决不会”是对资本主义灭亡和共产主义胜利必然性以及这种必然性实现的时间和条件的全面论述。前者讲的是资本主义灭亡和共产主义胜利的客观必然性，是根本的方面；而后者讲的是这种必然性实现的时间和条件，它告诫我们，“两个必然”的实现需要相应的客观条件，而在这个条件具备之前决不会成为现实。 全面准确地学习和把握“两个必然”和“两个决不会”，既有利于人们坚定资本主义必然灭亡、共产主义必然胜利的信心，同时也有利于人们坚持科学态度，充分尊重客观规律，在当前艰苦的实践中坚定地为共产主义的实现而奋斗。","categories":[{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"https://www.whkblog.work/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"https://www.whkblog.work/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"马克思主义原理期末考试重点","slug":"马克思主义原理期末考试重点","date":"2021-01-08T12:48:18.000Z","updated":"2021-01-08T12:57:34.642Z","comments":true,"path":"2021/01/08/马克思主义原理期末考试重点/","link":"","permalink":"https://www.whkblog.work/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/","excerpt":"","text":"《马克思主义基本原理概论》考试重点 1、三次起义运动(P6) 1831年、1834年法国里昂工人起义;1836年英国宪章运动;1844年德国西里西亚纺织工人起义。 2、马克思主义批判地继承、吸收(扬弃)德国古典哲学(主要代表人物:黑格尔、费尔巴哈)、英国古典政治经济学(主要代表人物:威廉·配第、亚当·斯密、大卫·李嘉图)和法国、英国空想社会主义(主要代表人物:昂利·圣西门、沙尔·傅立叶、罗伯特·欧文)。(P8~P9) 3、两大理论成果(P13) 毛泽东思想和中国特色社会主义理论体系(包括邓小平理论、“三个代表”重要思想、科学发展观) 4、哲学的基本问题(P29) ①意识和物质、思维和存在，究竟谁是世界的本原，即物质和精神何者第一性、何者第二性的问题;②思维能否认识或正确认识存在的问题。 5、哲学的分类(P29) ①根据哲学基本问题第一方面的回答划分为唯物主义和唯心主义。唯物主义把世界的本原归结为物质，主张物质第一性，意识第二性，意识是物质的产物;唯心主义把世界的本原归结为精神，主张意识第一性，物质第二性，物质是意识的产物。②根据哲学基本问题第二方面的回答划分为可知论和不可知论。可知论认为世界是可以被认识的;不可知论认为世界是不能被人所认识或不能被完全认识的，否定思维和存在的统一。 6、旧唯物主义哲学(P30) 包括古代朴素唯物主义和形而上学唯物主义。 7、意识的发展阶段(P31) 一切物质所具有的反应特性→低等生物的刺激感应性→高等动物的感觉和心理→人类的意识。 8、马克思指出“观念的东西不外是移入人的头脑并在人的头脑中改造过的物质的东西而已。”这表明，物质决定意识，意识依赖于物质并反作用于物质。(P31) 9、时间和空间(P33) 时间和空间是物质运动的存在形式，物质运动与时间和空间的不可分割证明了时间和空间的客观性。时间是指物质运动的持续性、顺序性，特点是一维性，即一去不复返;空间是指物质运动的广延性、伸张性，特点是三维性。 10、马克思主义以前的旧唯物主义都是“半截子”唯物主义。因为它们在自然观上是唯物主义，一到社会历史领域，就陷入了唯心主义。(P33) 11、实践的基本特征及构成实践活动的要素(P35) 基本特征:物质性、自觉能动性、社会历史性。要素:实践主体(人)、实践对象(客体)、实践手段(工具等)。 12、实践的基本形式(P36) 物质生产实践(人类最基本的实践活动)、社会政治实践、科学文化实践。 13、为什么说实践是人的存在方式？(P37) 人类的产生、生存和活动，是以实践为基本方式和标志的。①实践是人所独有的活动。②实践集中表现了人的本质的社会性。③实践对物质世界的改造是对象性的活动。 14、社会生活的实践性主要体现在哪几方面？(P39) ①实践是社会关系形成的基础。②实践形成了社会生活的基本领域。③实践构成了社会发展的动力。 15、意识的能动作用及主要表现的方面(P41) 意识能动作用是人的意识所特有的积极反映世界与改造世界的能力和活动。主要表现在:①意识活动具有目的性和计划性。②意识活动具有创造性。③意识具有指导实践改造客观世界的作用。④意识具有指导、控制人的行为和生理活动的作用。 16、主观能动性与客观规律性的辩证统一(P42) ①尊重客观规律是发挥主观能动性的前提。②在尊重客观规律的基础上充分发挥主观能动性。人们通过自觉活动能够认识规律和利用规律。自觉能动性是人与动物的重要区别。③尊重事物发展的规律与发挥人的主观能动性是辩证统一的。④实践是客观规律性与主观能动性统一的基础。 17、如何正确发挥主观能动作用？(P43) ①从实际出发，努力认识和把握事物的发展规律。②实践是发挥人的主观能动作用的基本途径。③主观能动作用的发挥，还依赖于一定的物质条件和物质手段。 18、联系的特点(P44) ①客观性。事物的联系是事物本身所固有的，不是主观臆想的。世界上没有孤立存在的事物，每一种事物都是和其他事物联系而存在的，这是一切事物的客观本性。②普遍性。a.任何事物内部的不同部分和要素都是相互联系的，也就是说，任何事物都具有内在的结构。b.任何事物都不能孤立存在，都同其他事物处于一定的相互联系之中。c.整个世界是相互联系的统一整体。③多样性。直接联系与间接联系，内部联系与外部联系，本质联系与非本质联系，必然联系与偶然联系等。 19、新生事物不可战胜的原因(P46) ①就新生事物与环境的关系而言，新事物之所以新，是因为有新的结构和功能，它适应已经变化了的环境和条件;旧事物之所以旧，是因为它的各种要素和功能已不适应环境和客观条件的变化，走向灭亡就成为不可避免的。②就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、仍然适合新的条件的因素，并添加了旧事物所不能容纳的新内容。 20、对立统一规律是唯物辩证法体系的实质和核心的原因(P47) ①对立统一规律揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题；②对立统一规律是贯穿质量互变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解这些规律和范畴“钥匙”；③对立统一规律提供了人们认识世界和改造世界的根本方法——矛盾分析法。 21、矛盾的同一性与斗争性的辩证统一关系(P48) 矛盾同一性与斗争性之间是对立统一的辩证关系。①矛盾的同一性和斗争性之间是相互联结、相辅相成、相互制约的。一方面，同一性依赖于斗争性，同一是包含着差别、对立的同一，没有斗争性就没有同一性；另一方面，斗争性寓于同一性之中，斗争是是同一中的斗争，没有同一性，斗争性也不能成立。②同一性与斗争性之间是相对与绝对的关系。斗争性是绝对的、无条件的，同一性是相对的、有条件的，斗争性最终导致同一性的分解，有条件的同一性和无条件的斗争性相结合，推动着事物发展。 22、矛盾的普遍性和特殊性及其相互关系(P49~P50) 矛盾的普遍性: 矛盾无处不在，无时不有。矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有特点；三是构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质、地位和作用。 矛盾的普遍性和特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。矛盾的共性是无条件的、绝对的，矛盾的个性是有条件的、相对的。任何现实存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键，不懂得它，就不能真正掌握唯物辩证法。矛盾的共性和个性相统一的关系，既是客观事物固有的辩证法，也是科学的认识方法。人的认识的一般规律就是由认识个别上升到认识一般，再由一般到个别的辩证发展过程。 23、量变和质变的辩证关系(P51) ①量变是质变的必要准备。任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。②质变是量变的必然结果。单纯的量变不会永远持续下去的，量变达到一定程度必然引起质变。③量变和质变是相互渗透的。一方面，在总的两边过程中有阶段性和局部性的部分质变。另一方面，在质变的过程中也有旧质在量上的收缩和新质在量上的扩张。 量变和质变是相互依存、相互贯通的，量变引起质变，在新质的基础上，事物又开始新的量变，如此交替循环，形成事物质量互变的规律性。质量互变规律体现了事物发展的渐进性和飞跃性的统一。 24、辩证否定观的主要内容(P52) ①否定是事物的自我否定，是事物内部矛盾运动的结果。②否定是事物发展的环节。它是旧事物向新事物的转变，是从旧质到新质的飞跃。只有经过否定，旧事物才能向新事物转变。③否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物通过否定环节联系起来的。④辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。 25、必然性与偶然性的关系(P54) ①必然性和偶然性是对立的。必然性是事物发展过程中确定不移的趋势，是由事物的根本矛盾决定的，体现事物发展的本质联系和发展前途;偶然性是事物发展过程中不确定的趋势，是由事物的非根本矛盾和外部条件引起的，对事物的发展起加速或延缓作用。②必然性和偶然性又是统一的。a.必然性总是通过大量的偶然现象表现出来，由此为自己开辟道路，没有脱离偶然性的纯粹必然性。b.偶然性是必然性的表现形式和必要补充，偶然性背后隐藏着必然性并受到其制约，没有脱离必然性的纯粹偶然性。c.必然性和偶然性在一定条件下可以相互转化。 26、主体和客体相互作用的过程(P64) ①确立实践目的和实践方案。②实践主体按照实践目的和实践方案实际地作用于实践客体，通过一定的实践手段把实践方案变成实践的实践活动。③通过反馈和调节，使实践目的、手段和结果按一定方向运行。 27、实践在认识中的决定作用(P65) 实践是认识的基础，对实践具有决定作用。①实践产生了认识的需要。②实践为认识提供了可能。③实践使认识得以产生和发展。④实践是检验认识的真理性的唯一标准。 28、两条根本对立的认识路线(P67) ①坚持从物到感觉和思想的唯物主义路线。②坚持从思想和感觉到物的唯心主义路线。 29、主观唯心主义和客观唯心主义(P67) 主观唯心主义认为人的认识是主观自生的，是“内心反省”的结果，是心灵的自由创造物。客观唯心主义认为人的认识是上帝的启示或绝对精神的产物。 30、辩证唯物主义认识论和旧唯物主义认识论(P67、P68) ①旧唯物主义的认识论即形而上学唯物主义认识论，把人的认识看成是消极地、被动地反映和接受外界对象。有两个严重缺陷:a.离开实践考察认识问题，因而不了解实践对认识的决定作用。b.不了解认识的辩证性质，离开辩证法来考察认识问题，不能把认识看作是一个不断发展的过程，而认为认识是一次性完成的。②辩证唯物主义认识论认为，认识是主体对客体的能动反映。这种能动反映具有摹写性和创造性。 31、感性认识和理性认识及其辩证关系(P69、P70) 感性认识：人们在实践基础上，由感觉器官直接感受到的关于事物的现象、事物的外部联系、事物各方面的认识，包括感觉、知觉和表象三种形式。理性认识：指人们借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物的本质、全体、内部联系和事物自身规律性的认识。理性认识包括概念、判断、推理三种形式。辩证关系:①理性认识依赖于感性认识。理性认识必须以感性认识为基础，坚持理性认识对感性认识的依赖关系就是坚持了认识论的唯物论。②感性认识有待于发展和深化为理性认识。只有使感性认识上升到理性认识才能把握住事物的本质，满足实践的需要，坚持这一点就是坚持了认识论的辩证法。③感性认识和理性认识相互渗透、相互包含。感性认识和理性认识是辩证统一的，统一的基础是实践。 32、从感性认识过渡到理性认识所具备的条件(P70) ①勇于实践，深入调查，获取十分丰富和合乎实际的感性材料，这是正确实现由感性认识上升到理性认识的基础。②必须经过理性思考的作用，将丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的制作加工，才能将感性认识上升到理性认识。也就是说，必须运用辩证思维的科学方法，才能获得真正的认识。 33、造成认识过程反复性和无限性的原因(P72) ①人们对事物的认识，由于主客观条件的限制，往往不是一次完成的。从主观方面说，人们总是受到自己认识能力和实践活动范围的限制。从客观方面说，会受到科学技术条件的限制，以及客观过程的发展和表现程度的限制。②从人们具体的认识过程看，当某一思想、理论、计划、方案等，经过多次反复，在实践中达到预想结果，就算完成了。 34、实用主义所鼓吹的“有用就是真理”这句话是错误的。这是主观真理论的一个典型，实用主义者把“有用”和“真理”完全等同，从根本上否认了客观真理的存在。(P74) 35、真理的绝对性和相对性及其关系(P75) 真理的绝对性即具有绝对性的真理，是指真理的无条件性、无限性。真理的相对性即具有相对性的真理，是指真理的有条件性、有限性。任何真理都只能是主管对客观事物近似正确即相对正确的反映。关系:真理的绝对性和相对性是辩证统一的。①具有绝对性的真理和具有相对性的真理是相互渗透和相互包含的。②具有相对性的真理向具有绝对性的真理转化。 36、价值的特性(P81) ①客观性。价值关系的各个环节都是客观的。a.人的需要具有客观性。b.用来满足人的需要的对象也具有客观性。c.满足人的需要的过程和结果也具有客观性。②主体性。③社会历史性。④多维性。 37、价值评价及其特点(P82、P83) 价值评价是一种关于价值现象的认识活动。特点:①评价是以主客体的价值关系为认识对象的。②评价结果与评价主体有直接关系，是依主体的特点而转移的。③评价结果的正确与否依赖于相关的知识性认识。 38、党的十八大“三个倡导”(P85) 倡导富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善，积极培育和践行社会主义核心价值观。 39、两种根本对立的历史观(P95、P98) ①唯物史观。认为:社会历史发展具有自身固有的客观规律；社会存在决定社会意识，社会意识又反作用于社会存在；生产力和生产关系之间的矛盾，经济基础和上层建筑之间的矛盾是推动社会发展的基本矛盾。②唯心史观。认为:社会意识决定社会存在，人们的思想动机是社会发展的根本原因，否认社会发展的客观规律。 40、社会存在与社会意识及其辩证关系(P96) 社会存在:也称社会物质生活条件，是社会生活的物质方面，它包括地理环境和人口因素和物质资料的生产方式，其中物质资料的生产方式是社会存在的主要方面。社会意识:社会意识是社会生活的精神方面，是社会存在的反映。辩证关系:社会存在决定社会意识，社会意识是对社会存在的反映。社会存在和社会意识是辩证统一的。社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。①社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。②社会意识是人们社会物质交往的产物。③随着社会存在的发展，社会意识也相应地或迟或早地发生变化和发展。 41、社会意识的分类(P96) 社会意识具有复杂的结构。按照社会意识主体的不同，可以区分为个人意识和群体意识；按照社会意识反映层次的高低，可以区分为社会心理和社会意识形式；按照同经济基础关系的不同，可以区分为作为上层建筑的意识形式（社会意识形态）和非上层建筑的意识形式。上层建筑的意识形式（或者说社会意识形态）包括政治法律思想、道德、艺术、宗教、哲学和大部分的社会科学（例如：经济学、政治学、法学、社会学等等）；它们从各自不同方面发挥独特的作用。而非上层建筑的意识形式主要是指自然科学，也包括一部分社会科学和思维科学（例如：语言学、修辞学、逻辑学等等）。在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级的意识形态，因而具有鲜明的阶级属性。 42、社会意识相对独立性的主要表现(P99) ①社会意识与社会存在发展的不完全同步性和不平衡性。②社会意识的发展具有历史继承性。③社会意识各种内部形式之间的相互影响、相互作用。④社会意识对社会存在的能动的反作用，这是社会意识相对独立性的突出表现。 43、生产力的基本要素(P101) ①劳动资料(也称劳动手段)。②劳动对象。③劳动者。 44、生产力与生产关系的相互关系(P104) 生产力决定生产关系，生产关系对生产力有反作用。①生产力决定生产关系:a.生产力状况决定生产关系的性质，有什么样的生产力，就会产生什么样的生产关系；b.生产力的发展决定生产关系的发展和变革。②生产关系对生产力具有能动的反作用:a.当生产关系与生产力的发展要求相适合时，它会有力地推动生产力的发展；b.当生产关系与生产力的发展要求不相适合时，它会阻碍甚至破坏生产力的发展。 45、经济基础和上层建筑的矛盾运动(P108) 经济基础与上层建筑是辩证统一的。①经济基础决定上层建筑。经济基础是上层建筑赖以产生、存在和发展的物质基础，上层建筑是经济基础得以确立统治地位并巩固和发展不可缺少的政治、思想条件。任何上层建筑的产生、存在和发展，都能直接或间接地从社会的经济结构中得到说明。经济基础的性质决定上层建筑的性质，有什么样的经济基础就有什么样的上层建筑。经济基础的变更必然引起上层建筑的变革，并决定着其变革的方向。②上层建筑对经济基础具有反作用。集中表现在:为自己的经济基础的形成和巩固服务，确立或维护其在社会中的统治地位。上层建筑这种反作用的后果可能有两种:当它为适合生产力发展要求的经济基础服务时，就成为推动社会发展的进步力量;反之，就会成为阻碍社会发展的消极力量。 46、社会形态的分类(P110) ①经济形态(基础)。②政治形态。③意识形态。 47、社会历史发展的动力(P113) ①根本动力:社会基本矛盾(生产力和生产关系、经济基础和上层建筑的矛盾)。②直接动力:阶级斗争。③重要动力:革命、改革、科学技术。 48、群众观点与群众路线(P133) 群众观点:人民群众至上。坚信人民群众自己解放自己;全心全意为人民服务;一切向人民群众负责;虚心向群众学习。 群众路线:一切为了群众，一切依靠群众，从群众中来，到群众中去。 49、试用物质和意识的辩证关系原理，说明我国的现代化建设必须走自己的路，建设中国特色的社会主义。 答:①物质和意识的辩证关系是：物质第一性，意识第二性，先有物质，后有意识。物质决定意识，意识是物质的反应，意识对物质具有能动的反作用，正确的意识对事物的发展起足进作用，错误的意识对事物的发展起阻碍作用。这一原理要求我们在实际工作要坚持一切从实际出发，实事求是。②我国的社会主义现代化建设，必须从中国的客观实际出发，从中国的国情，国力和基本特点出发。我国当前乃至今后相当长一段时期处于社会主义初级阶段是我国的基本国情，是我国当前的最大实际，是我们党制定路线，方针和政策的客观依据。我国的现代化建设必须从这一基本国情出发，把马克思主义的基本原理同中国的实际紧密结合起来。建设中国特色的这会注义。③在现代化建设过程中，必须会遇到需多新情况、新问题。这就要求我们从实际出发，尊重客观规律，不断开创现代化建设的新局面。必须反对从主观愿望和书本教条出发，反对照搬照抄他人的检验和模式。 50、试用矛盾的普遍性和特殊性的辩证关系原理，说明坚持中国特色社会主义道路的重要性。 答:①矛盾的普遍性是指矛盾存在于一切事物的发展过程中，存在于一切事物发展过程的始终。矛盾的特殊性是指具体事物的矛盾及每一矛盾的各个方面都有其特点。②矛盾的普遍性和特殊性是辩证的统一。第一，矛盾的普遍性和特殊性是相互联结的。普遍性存在于特殊性之中，特殊性中包含着普遍性。第二，矛盾的普遍性和特殊性在一定条件下可能相互转化。③矛盾的普遍性和特殊性辩证统一的原理，是把马克思主义普遍真理与中国的具体实际相结合，走建设有中国特色社会主义道路的重要理论依据。④我们既要坚持社会主义的根本制度和基本原则，又必须注意中国的特点，从中国正处于并将长期处于社会主义初级阶段这一实际出发，走自己的路。只有这样，才能把建设有中国特色社会主义事业推向前进。 51、用认识和实践的关系原理，说明科学发展观对中国特色社会主义建设的重要意义。 答:①认识是实践的基础，实践对认识起决定作用。实践是认识的来源、动力、检验标准和目的。理论一经形成对实践有能动作用，主要表现在:正确的认识和理论可以指导实践指向适当的对象，采取正确的方法，从而取得成功。错误的认识和理论，会引导实践指向不适当的对象，采取错误的方法，从而导致失败。②科学发展观是马克思主义关于发展世界观和方法论的集中体现，是我国经济社会发展的重要指导方针。它进一步正确地回答了实现什么样的发展、怎样发展的问题，体现了我们党对执政规律、社会主义建设规律和人类社会发展规律认识的进一步深化。③科学发展观能够指导我国经济社会实现又快又好的发展，解决发展中的不平衡、不协调问题，为我国经济社会发展指明了正确的方向。④认真学习全面领会科学发展观，才能真正坚持贯彻科学发展观。 52、用真理的绝对性和相对性的辩证关系原理，说明对待马克思主义的正确态度。 答:①真理的绝对性和相对性的关系:首先，两者相互对立、相互区别;绝对真理是指真理的内容是客观的，人类的认识按其本性是能够正确反映无限发展着的物质世界。相对真理是指真理只是对客观事物一定范围的正确反映，是对事物一定程度、一定层次的近似正确的反映。其次，两者相互依存、相互渗透。相对真理中包含着绝对真理的成分，绝对真理是由无数相对真理构成的。再次，人类的认识永远处在从相对真理向绝对真理的转化过程中。②马克思主义作为科学真理，是绝对性和相对性的统一。马克思主义是关于自然、社会和思维发展的普遍规律的科学，它的基本原理经过实践的反复检验、证明，对各国的革命和建设具有普遍的指导意义，这是无条件的、绝对的。马克思主义没有穷尽一切真理，必将随着科技的进步和实践的发展而前进，这又是其相对性。对待马克思主义的科学态度关键在于正确处理好坚持和发展马克思主义的关系，即既要坚持，又要发展，在坚持中发展，在发展中坚持。③割裂真理的绝对性和相对性的关系会导致真理问题上的绝对主义或相对主义。在实际工作中要反对片面夸大马克思主义的绝对性、否认其相对性的教条主义、本本主义的错误，又要反对片面夸大其相对性、否认其绝对性的所谓马克思主义“过时论”、“无用论”的错误。 53、试述社会意识相对独立的原理并用以说明加强社会主义精神文明建设的重要性。 答:(1)社会存在决定社会意识，社会意识是社会存在的反映，因此，它没有绝对独立性，只具有相对独立性。社会意识相对独立性的表现：①社会意识对社会存在有巨大的能动的反作用：先进的社会意识对社会存在的发展起着促进和推动的作用，落后反动的社会意识阻碍社会存在的发展。②社会意识和社会存在变化和发展的不完全同步性：社会意识的变化有时落后于社会存在的变化；先进的社会意识在不同程度上预见社会存在变化发展的趋势和未来。③社会意识同社会经济发展水平的不平衡性：经济上先进的国家，意识形态的发展却可能落后；经济上落后的国家，意识形态发展可能先进。④社会意识各种形式之间能互相作用，其中政治思想居于主导地位，对其他意识形式有巨大影响。⑤社会意识具有历史继承性，后人总要继承前人的思想材料，并加以改造和发展。(2)重要性：①社会主义精神文明建设，是实现社会主义现代化的战略任务，它能推动社会主义社会存在的发展。它为社会主义生产方式、经济制度的发展提供了精神动力和智力支持及思想保证，也是改革开放和实现社会主义现代化的根本保证。②社会主义精神文明建设又是抵制封建主义、资产阶级腐朽思想的重要武器，是反对资产阶级自由化的重要武器。③社会主义精神文明建设不仅关系到我国社会主义方向和道路，而且是关系到我国整个社会生活的精神面貌的大问题。因此，搞好它是极为重要的。","categories":[{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"https://www.whkblog.work/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"https://www.whkblog.work/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"数据科学概论考试知识点","slug":"数据科学概论考试知识点","date":"2021-01-04T07:55:11.000Z","updated":"2021-01-08T08:34:25.077Z","comments":true,"path":"2021/01/04/数据科学概论考试知识点/","link":"","permalink":"https://www.whkblog.work/2021/01/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA%E8%80%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"第一章数据科学定义 定义：数据科学是关于对与数据进行分析、抽取信息和知识的过程提供指导合作支持的基本原则方法科学 ​ 数据科学的核心任务是从数据中从获取信息、发现知识。数据科学包含一组概念、原则、过程、技能/方法以及工具，为其核心任务为服务 ​ 简而言之，数据科学是以各类数据作为研究对象的，建立在在应对分析挑战的众多关键技术基础上的通识意义上的科学 大数据的三个主要特点： 数据量大、数据类型多、数据生成快、价值密度低 数据科学的基本原则： ​ 1、数据分析可以划分成一系列的明确阶段 ​ 2、描述性与预测分析 ​ 3、实体的相似度 ​ 4、模型泛化能力 ​ 5、分析结果的评估与特定的应用场景有关 ​ 6、相关性不同于因果关系 ​ 7、通过并行处理提高数据处理（分析）速度 数据处理的流程： 1、数据采集2、数据表示和储存3、数据清洗4、数据集成5、数据分析6、数据可视化7、基于数据的决策 ​ 第二章 OLTP与数据服务数据服务是指面向操作型业务，提供数据的增加、删除、修改以及简单的查询功能（增删改查） 联机事务处理（OLTP）指的是用户的业务请求转化成数据库的操作，传送到后台数据库管理系统，数据库管理系统在很短的时间内，把用户的相关数据操作当作一个事务来处理，对用户的请求进行响应 联机事务处理的两个特点：一个是用户请求作为一个事务进行处理，另一个是响应时间短 ACID事务特性：A：原子性，指的是事务的所有操作，要么全部执行，要么都没有执行 ​ C：一致性，值的是事务把数据库状态，从一个有效状态转化为另一个新的有效状态 ​ I：隔离性，是指在一个并发的事务处理系统中和其他事务是相互隔离的，事务的各个操作步骤可以交替执行，但必须和保 证某个未提交的事务和其他事务时相互隔离的，目的是保证未提交的数据，别的事物不能看到 ​ D：指的时提交的数据的必须保存起来，当系统失败和重启，数据能够恢复到最近的正确后状态 数据安全性保证的主要技术手段： 用户认证和授权、审计和数据加密等 关系模型的完整性包括实体完整性、参照完整性、用户自定义完整性 NoSQL数据​ Not only SQL ,是某一类数据库的统称 ​ 主要特点：采用和关系模型不同的数据模型，采取了一些新的设计原则，目的是利用大型计算机集群实现大数据的有效处 理 ​ 新原则：1、采用横向扩展方式应对大数据挑战；2、放弃严格的ACID一致性约束，允许数据暂时出现不一致，接受最终一致性； ​ 3、对数据的储存进行容错处理，一般对数据块进行适当的备份 CAP理论：在大型分布式数据库中，一致性、系统可用性、网络分区容忍性这三个目标中，只可以获得其中两个，追求其中两个将损害另外一个的目标 ​ NoSQL的四种数据库类型| 四种类型 | 代表 || ——————- | ——————- || Key-Value数据库 | Dynamo数据库、Redis || Column Family数据库 | Big Table、HBase、 || Document数据库 | MongoDB || Graph数据库 | Neo4J | NewSQL没怎讲，不搞了 分布式数据库 定义：所谓分布式数据库，它运行在多台计算机上，这些计算机通过网络互联。每台计算机可以放在一个地方，每台计算机安装独立的RDBMS系统，拥有数据的完整拷贝，或者部分拷贝。这些计算机系统共同组成一个完整的、逻辑上集中、但是物理上分布的大型数据库。 第三章 OLAP 与结构化数据联机分析处理（OLAP）：是在以星型模型（或雪花模型）建立的数据仓库上进行多维分析 结构化数据分析： 是一个更为广泛的概念，它运行在结构化数据上，分析可以表达成一个SQL聚集查询 数据仓库与星型模型，BILL Inmon认为数据仓库是面向主题的、集成的、非易失的和时变的数据集合，用以支持管理决策 数据仓库一般不对应到某个厂商的具体产品，而是指一种面向对象的数据分析储存方案 联机分析处理的主要操作：下钻、上卷、切片、切块、旋转等 ​ 下钻和上卷是改变维的层次；切片和切块是选定一部风维度值，然后查看度量数据剩余维度上的分布情况；旋转操作时改变维的方向 三种类型的OLAP系统：多维OLAP（MOLAP)、关系OLAP(ROLAP)、混合OLAP(HOLAP)； ​ MOLAP优点性能高，缺点是占用大量的空间保存汇总数据 ​ ROLAP优点利用关系数据库保存原始明细数据，占用空间有限，但性能有限 ​ HOLAP是两者的集合，HOLAP的查询效率比ROLAP高，比MOLAP低 高性能OALP系统的三种实现技术 ​ 列储存技术​ ​ 位图索引技术 ​ 内存数据库技术 第四章 数据清洗与数据集成ETL (Extract、Tansform and Load) : 数据抽取，转换和装载 数据集成是从多个数据源建立统一的数据视图的一种技术 数据清洗是一种消除数据里面错误、去掉重复数据的技术 数据清洗​ 数据清洗的意义：剔除数据中的错误，以便获得高质量的数据，基于高质量的数据分析才能获得可信的分析结果，进而做出正确的决策 ​ 数据异常的不同类型： ​ 1、语法类异常：词法错误、值域格式错误、不规则的取值 ​ 2、语意类异常：违反完整性约束规则、数据中出现矛盾、数据重复 ​ 3、覆盖类异常：值缺失、元组缺失 数据质量：​ 数据质量的评价标准：完整的评价标准是子评价标准的综合加权评分 ​ 1、正确性：完整性、一致性（可继续划分为模式符合性和统一性）、密度 ​ 2、唯一性 ​ 数据清洗的任务和过程 ​ 任务：剔除数据里的异常，使得数据集成为现实世界的准确、没有重复的表示过程 ​ 主要操作：1、对元组及其各个属性的格式进行调整。2、完整性约束条件的检查和实施。3、从已知值中导出缺失值。4、检测离群值 ​ 过程： ​ 数据审计—&gt;选择合适的方法—&gt;执行方法—&gt;后序处理和控制 ​ 数据清洗的具体方法： ​ 1、数据解析数据解析的目的是检测语法错误 ​ 2、数据转换数据转换的目的是把数据从一个格式映射到另外一种格式，以适应程序的需要。在实例层面一般采取标准化和规范化方法，提出数据的不规则性 ​ 3、实施完整性约束条件 ​ 4、重复数据消除 ​ 5、一些统计方法 数据集成：​ 数据集成是指把数据从多个数据源整合在一起，提供一个观察这些数据统一视图的过程、 ​ 数据集成分为物理式数据集成、虚拟式数据集成两类 ​ 数据集成需要解决的问题——异构性：管理系统的异构性、通信协议异构性、数据模式异构性、数据类型异构性、 ​ 数据集成的三种模式：建立数据仓库、联邦数据库模式、中介者模式 第五章 数据的深度分析（数据挖掘、机器学习）广义上而言，机器学习是一种能够赋予机器学习的能力，让它完成直接编程无法完成的功能的方法。 机器学习的目的是：是预测（包括分类和回归） 特征选择算法（书上出现的）： 互信息、文档频率、信息增益、卡方检验 机器学习的基本过程是利用训练数据（包含输入数据和预期输出的分类或者数值）训练一个模型，利用这个模型，就可以对新的实例数据进行分类和计算一个预测 机器学习的方法可以分为：监督学习、无监督学习、半监督学习 ​ 监督学习：是机器学习的一种类别，训练数据由输入特征（Feature）和预期的输出构成，输出可以是一个连续的值，或者是一个分类的标签。 ​ 无监督学习：与监督学习的区别就是没有训练样本，直接对数据建模。 ​ 半监督学习：是监督学习和无监督学习的结合，它研究利用少量的标注样本和大量未标注的样本进行训练和预测问题。半监督学习分为半监督分类，半监督回 归，半监督聚类，半监督降维算法 主流机器学习算法决策树、聚类算法K-means、SVM、关联规则分析Apriori算法、EM算法、协同过滤推荐算法、朴素贝叶斯算法 第六章 流数据处理流数据处理应用​ 网络监控、电信数据管理、工业制造、传感器网络、电子商务、量化交易等 流式处理和批处理的区别​ 流式处理时针对批处理来讲的 流式处理（Stream Processing） 是针对 批处理（Batch Processing）来讲的，即它们是两种截然不同的数据处理模式，具有不同的特点，适用于不同的应用场合。不能简单地认为其中一种数据处理模式优于另一种数据处理模式。 对于批处理来讲，首先数据被不断地采集，保存到数据库中，然后进行分析处理（包括SQL查询）。批处理适用于对大量数据（High Volume）进行处理的场合。人们需要等到整个分析处理任务完成，才能获得最终结果。由于需要处理的数据集大小以及计算机系统的计算能力的差异，整个过程有时需要耗费相当长的时间，即获得最终分析处理结果的延迟较大。批处理是最通用的数据处理模式。传统的关系数据库系统、Hadoop以及Spark大数据处理平台等，都采用了这样的数据处理模式，或者以该处理模式为主。由于需要完整地保存整个数据集，并且在上面进行分析处理，比起流式数据处理系统，人们需要投入更多的硬件资源。 批处理系统可以存取已经入库的所有数据，人们可以对数据进行复杂深入的分析，分析处理的延迟以分钟或者小时计。批处理作业（Job）一旦提交，则一直运行，直到获得最终结果或者失败退出，无需用户人工干预。这些作业在整个数据集或者某个子集上执行一系列的分析，产生分析结果。在性能方面，批处理系统主要考虑系统的吞吐能力，而不是单个分析处理任务的处理延迟（Latency）。 在流式数据处理模式里，数据持续到达，系统及时处理新到达的数据，并不断产生输出。处理过的数据一般丢弃掉，当然也可以保存起来。流式数据处理模式强调数据处理的速度（Velocity）。部分原因是数据产生的速度很快，需要及时进行处理。由于流式数据处理系统能够对新到达的数据进行及时的处理，所以它能够给决策者提供最新的事物发展变化的趋势，以便对突发事件进行及时响应，调整应对措施。 查询处理的基础算法​ 随机采样、梗概技术、直方图、小波分析、布隆过滤器、计数最小梗概 流数据处理系统 Storm 第七章 文本分析文本分析的意义：深入了解非结构化数据，帮助企业或个人对产品和服务做出改进 文本分析的过程1、采集文本数据。2、运用文本分析方法分析文本。3、对分析结果进行可视化以及解释和评估分析结果等。 文本分析的任务和方法句子切分、分词、词性标注、语法分析 ​ 切分和分词 ，对于文本进行分析需要将文本切分为一个一个的句子，完成该功能的软件是语句切分器 ​ 词性标注 ​ 语法树 1、概率型上下文无关语法分析激素。2、位移归约语法分析技术。3、基于神经网络的语法分析技术 文本聚类的几种方法1、基于距离的聚类算法。2、基于单词或者短语的聚类算法。3、基于话题建模技术的概率聚类算法。 第十章 数据可视化、可视分析与探索十数据分析什么是什么可视化可视化是一种数据的可视表现形式以及交互技术的总称。它通过图形化的方式把数据表现出来，方便用户进行观察和理解，并且帮助用户对数据进行探索，发现数据里隐藏的模式，获得对大量数据的理解和洞察力 可视化分析技术1、数据：数据是所有可视化分析的基础 2、模型：可以是某个方面的属性的统计值，也可以是复杂的数据挖掘和机器学习算法 3、可视化：结果一般依据模型的分析结果进行绘制 4、探索回路：描述的是分析者如何和可视分析系统进行交互，目的是生成新的可视化结果或者调整模型；它涉及两个方面，即动作和发现 5、验证回路 ：（1）假设 （2）理解和洞察力，洞察里定义为分析者对于上述的法相如何进行解释。在解释过程中，需要用到领域的先验知识 6、产生知识回路 第十一章 云计算平台云计算的概念与特点​ 概念：云计算也称为按需计算，它是对可配置的共享的计算资源池提供安迅存取的一种计算模型，这里的资源包括计算、储存、网络等硬件资源 ​ 特点：虚拟化、弹性、成本低廉、高度容错性和高度可靠性 ​ 云计算与并行计算、分布式计算、集群计算、网格计算的区别于联系： ​ 并行计算是相对串行计算而言，可以分为时间上和空间上的并行。 ​ 分布式计算通过把整个计算任务分解成一些列的小任务，分布到各个结点上计算分别执行，最后汇总结果。获得最终结果。 ​ 集群计算通过高速网络把一组本来松散联系的结点（计算机）通过软件紧密联系在一起，协作完成计算工作 ​ 网格计算在本章中算作集群计算的一种 ​ 云计算是上述技术的发展新阶段，器底层的核心技术是虚拟化，即把计算、储存、网络等硬件都进行虚拟化。 ​ 云计算强调子要你的利用率 虚拟化技术与数据中心虚拟化技术包括服务器虚拟化，储存虚拟化和网络虚拟化等重要内容 服务器虚拟化​ 指把一台物理服务器虚拟成若干独立的逻辑服务器，各个逻辑夫妻拥有自己的CPU,内存以及I/O设备。 ​ 储存虚拟化分为两种：寄居虚拟化以及裸机虚拟化（通俗而言，前者就是，在一个已经安装了操作系统的机器上安装VMM，后者则是直接在未安装操作系统的 机器上安装VMM，后者为轻量级） ​ 储存虚拟化​ 目的是把分散的、异构的储存设备，想办法映射成一个统一的、连续编址的逻辑储存空间，也叫虚拟存储池 ​ 三种实现方式：基于主机的存储虚拟化，基于储存设备的虚拟化、基于网络的储存虚拟化 网络虚拟化​ 网络虚拟化在不改变数据中心网络的物理拓扑和布线情况下，可以虚拟出各层网络，并实现互联，形成统一的交换架构。 ​ 网络虚拟化包括核心层、接入层以及虚拟机网络化三个层次 数据中心​ 数据中心主要特点和优势：通过服务器虚拟化、储存虚拟化、网络虚拟化、应用虚拟化技术，把各种硬件资源整合，对外提供服务，提高设备利用率。 ​ 数据中心一般采用冗余、容错、容灾设计 第十二章 Hadoop两个版本之间的区别与联系1.0版本的优势与局限：​ 优势是它的可拓展性。 ​ 局限是：1、仅支持一种计算模型，即MapReduce。2、MapReduce作业的Map阶段和Reduce阶段执行过程中需要通过磁盘的存取操作进行，效率低下。 ​ 3、调度方法远未达到优化资源利用率的效果 2.0版本的不同​ 新增YARN模块，将1.0中的resource management部分拿出来作为YARN的内容单独（把资源管理功能单独划分出来）。 ​ 支持更多的计算模型，包括流数据处理、图数据处理、批处理、交互式处理","categories":[{"name":"数据科学概论","slug":"数据科学概论","permalink":"https://www.whkblog.work/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"https://www.whkblog.work/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"begin","slug":"begin","date":"2021-01-02T09:18:22.000Z","updated":"2021-04-01T01:01:49.284Z","comments":true,"path":"2021/01/02/begin/","link":"","permalink":"https://www.whkblog.work/2021/01/02/begin/","excerpt":"","text":"这是我在上次丢失文件后再次创建的个人博客，也没有啥说的吧就算是个新的开始吧；然后博客还没搞好，先凑合一下吧","categories":[],"tags":[{"name":"闲话","slug":"闲话","permalink":"https://www.whkblog.work/tags/%E9%97%B2%E8%AF%9D/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://www.whkblog.work/categories/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"python","permalink":"https://www.whkblog.work/categories/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.whkblog.work/categories/%E7%88%AC%E8%99%AB/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.whkblog.work/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"OS","slug":"OS","permalink":"https://www.whkblog.work/categories/OS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.whkblog.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"https://www.whkblog.work/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"},{"name":"数据科学概论","slug":"数据科学概论","permalink":"https://www.whkblog.work/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whkblog.work/tags/python/"},{"name":"vue","slug":"vue","permalink":"https://www.whkblog.work/tags/vue/"},{"name":"django","slug":"django","permalink":"https://www.whkblog.work/tags/django/"},{"name":"后端","slug":"后端","permalink":"https://www.whkblog.work/tags/%E5%90%8E%E7%AB%AF/"},{"name":"多线程","slug":"多线程","permalink":"https://www.whkblog.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.whkblog.work/tags/%E7%88%AC%E8%99%AB/"},{"name":"没事做的","slug":"没事做的","permalink":"https://www.whkblog.work/tags/%E6%B2%A1%E4%BA%8B%E5%81%9A%E7%9A%84/"},{"name":"操作系统算法","slug":"操作系统算法","permalink":"https://www.whkblog.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"},{"name":"期末复习","slug":"期末复习","permalink":"https://www.whkblog.work/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"闲话","slug":"闲话","permalink":"https://www.whkblog.work/tags/%E9%97%B2%E8%AF%9D/"}]}