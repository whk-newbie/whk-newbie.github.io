{"meta":{"title":"whks-blog","subtitle":"","description":"你好呀，谢谢观看","author":"whk","url":"http://example.com","root":"/"},"pages":[{"title":"友情链接","date":"2021-01-05T11:57:26.408Z","updated":"2021-01-05T11:38:49.011Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-01-05T13:39:14.000Z","updated":"2021-01-05T13:41:42.554Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2021-01-05T13:39:27.000Z","updated":"2021-01-05T13:41:43.139Z","comments":true,"path":"tages/index.html","permalink":"http://example.com/tages/index.html","excerpt":"","text":""}],"posts":[{"title":"OS算法","slug":"OS算法","date":"2021-05-09T12:42:49.000Z","updated":"2021-05-22T02:56:21.353Z","comments":true,"path":"2021/05/09/OS算法/","link":"","permalink":"http://example.com/2021/05/09/OS%E7%AE%97%E6%B3%95/","excerpt":"","text":"此文写的是操作系统的算法（java版） 读前须知1、文中算法，都是为了完成作业而写的，存在较多BUG, 算法最后带一个测试数据，就是实验要求的测试数据，并不全，算法本身问题较多，很多可能边界数据不能运行，会出现bug,例如进程调度里面，一个进程结束了，新的进程还未到达这一类情况就并没有写解决方法。、 2、由于我不会java,但是实验老师说用java加分，所有边学边写的，代码有些不规范敬请谅解。 3、由于java不太会，许多算法，都是在前任的基础之上写的；在此感谢哪些人(≧∇≦)ﾉ 进程调度算法FCFS主要思想​ 先来先服务的调度算法：最简单的调度算法，既可以用于作业调度 ，也可以用于程序调度，当作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，优先从后备队列中，选择一个或多个位于队列头部的作业，把他们调入内存，分配所需资源、创建进程，然后放入“就绪队列”,直到该进程运行到完成或发生某事件堵塞后，进程调度程序才将处理机分配给其他进程。 Java具体实现数据结构1234567891011121314151617public class Shuru &#123; int id; String name; //进程名 time arrve; //到达就绪时间 int zx;//执行时间 int grad; time start;//开始时间 time end;//完成时间 int zz; //周转时间=完成时间-到达时间 double zzxs; //周转系数 =周转时间/执行时间&#125;public class time &#123; int hour; int mintes;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.util.Scanner;public class FCFS &#123; public void SortByTime(Shuru shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrve.hour*60+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*60+shuru[i].arrve.mintes) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void SortBygrade(Shuru shuru[])&#123; for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i + 1; j &lt; shuru.length; j++) &#123; if (shuru[j].grad &lt; shuru[i].grad) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void fcfs(int n) &#123;// Scanner scan = new Scanner(System.in); Shuru shuru[] = new Shuru[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); shuru[i].id = Integer.parseInt(sa[0]); shuru[i].name = sa[1]; shuru[i].grad = Integer.parseInt(sa[2]); String[] time = sa[3].split(&quot;:&quot;); shuru[i].arrve.hour = Integer.parseInt(time[0]); shuru[i].arrve.mintes = Integer.parseInt(time[1]); shuru[i].zx = Integer.parseInt(sa[4]); shuru[i].start.hour = shuru[i].start.mintes = 0; shuru[i].end.hour = shuru[i].end.mintes = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; &#125; System.out.println(&quot;**********************************************************&quot;); SortByTime(shuru); calculate(shuru,n); SortBygrade(shuru); calculate(shuru,n); &#125; public void calculate(Shuru shuru[],int n)&#123; /*第一个执行的程序*/ shuru[0].start.hour = shuru[0].arrve.hour; shuru[0].start.mintes = shuru[0].arrve.mintes; //计算结束时间 if ((shuru[0].start.mintes + shuru[0].zx) &gt;= 60) &#123; shuru[0].end.hour = shuru[0].start.hour + 1; shuru[0].end.mintes = (shuru[0].start.mintes + shuru[0].zx - 60); &#125; else &#123; shuru[0].end.hour = shuru[0].start.hour; shuru[0].end.mintes = (shuru[0].start.mintes + shuru[0].zx); &#125; //计算周转时间 if (shuru[0].end.hour == shuru[0].start.hour) &#123; shuru[0].zz = (shuru[0].end.mintes - shuru[0].arrve.mintes); &#125; else &#123; shuru[0].zz = ((shuru[0].end.hour - shuru[0].arrve.hour)*60 + shuru[0].end.mintes - shuru[0].arrve.mintes); &#125; //计算周转系数 shuru[0].zzxs = (float)shuru[0].zz/shuru[0].zx; /*计算除去第一个进程外的其他进程*/ for (int i = 1; i &lt; n; i++) &#123; shuru[i].start.hour = shuru[i - 1].end.hour; shuru[i].start.mintes = shuru[i - 1].end.mintes; //计算结束时间 if ((shuru[i].start.mintes + shuru[i].zx) &gt;= 60) &#123; shuru[i].end.hour = (shuru[i].start.hour + 1); shuru[i].end.mintes = (shuru[i].zx + shuru[i].start.mintes - 60); &#125;else &#123; shuru[i].end.hour = shuru[i].start.hour; shuru[i].end.mintes = shuru[i].start.mintes + shuru[i].zx; &#125; //计算周转时间 if (shuru[i].end.hour == shuru[i].arrve.hour) &#123; shuru[i].zz = shuru[i].end.mintes - shuru[i].arrve.mintes; &#125;else&#123; shuru[i].zz = (shuru[i].end.hour - shuru[i].arrve.hour) * 60 + shuru[i].end.mintes - shuru[i].arrve.mintes; &#125; shuru[i].zzxs = (float)shuru[i].zz / shuru[i].zx; &#125; System.out.println(&quot;进程id\\t进程名\\t优先级\\t执行时间\\t\\t到达时间\\t\\t开始时间\\t\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); int sumzz=0; float sumzzxs=0; for(int i=0;i&lt;n;i++)&#123; show(shuru[i]); sumzz += shuru[i].zz; sumzzxs += shuru[i].zzxs; &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n);// &#125; public void show (Shuru shuru)&#123; System.out.printf(&quot;%d\\t%s\\t\\t%d\\t\\t%d（分钟）\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs); &#125; public static void main(String[]args)&#123; FCFS j = new FCFS(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); j.fcfs(n); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*实验数据5001 p1 1 9:40 205004 p4 4 10:10 105005 p5 3 10:05 305002 p2 3 9:55 155003 p3 2 9:45 25 */ SJF主要思想同先来先服务算法一样的功能，与之不同的是，短作业优先算法，是以作业运行时间长短排序； 1、在已到达的作业中，选择作业时间最短的进程 2、当前进程结束后，再在已到达的进程中选择运行时间最短的进程进入CPU进行执行 具体实现数据结构与FCFS数结构一样 Java具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200import java.util.Scanner;public class SJF &#123; public void SortByTime(Shuru shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrve.hour*60+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*60+shuru[i].arrve.mintes) &#123; Shuru t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void SortBygrade(Shuru shuru[])&#123; for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i + 1; j &lt; shuru.length; j++) &#123; if(shuru[j].grad &gt; shuru[i].grad)&#123; Shuru temp = shuru[i]; shuru[i] = shuru[j]; shuru[j] = temp; &#125; &#125; &#125; &#125; public void init(Shuru shuru[])&#123; for(int i=0;i&lt;shuru.length;i++)&#123; shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); shuru[i].id = 0; shuru[i].name = &quot;nothing&quot;; shuru[i].grad = 0; shuru[i].zx = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; shuru[i].start.hour = 0; shuru[i].start.mintes = 0; shuru[i].end.hour = 0; shuru[i].end.mintes = 0; shuru[i].arrve.hour = 0; shuru[i].arrve.mintes = 0; &#125; &#125; public boolean find(Shuru shuru[],Shuru shuru1)&#123; for(int i=0;i&lt;shuru.length;i++)&#123; if(shuru[i].id == shuru1.id)&#123; return true; &#125; &#125; return false; &#125; public void sjf(int n)&#123; Scanner scan = new Scanner(System.in); Shuru shuru[] = new Shuru[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); shuru[i] = new Shuru(); shuru[i].start = new time(); shuru[i].arrve = new time(); shuru[i].end = new time(); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间:\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); shuru[i].id = Integer.parseInt(sa[0]); shuru[i].name = sa[1]; shuru[i].grad = Integer.parseInt(sa[2]); String[] time = sa[3].split(&quot;:&quot;); shuru[i].arrve.hour = Integer.parseInt(time[0]); shuru[i].arrve.mintes = Integer.parseInt(time[1]); shuru[i].zx = Integer.parseInt(sa[4]); shuru[i].start.hour = shuru[i].start.mintes = 0; shuru[i].end.hour = shuru[i].end.mintes = 0; shuru[i].zz = 0; shuru[i].zzxs = 0; &#125; System.out.println(&quot;**********************************************************&quot;); Shuru shuruans[] = new Shuru[n]; init(shuruans); Shuru shurutemp[] = new Shuru[n]; init(shurutemp); //先时间排序 SortByTime(shuru); //按优先级进行执行 System.out.println(&quot;进程id\\t进程名\\t优先级\\t执行时间\\t\\t到达时间\\t\\t开始时间\\t\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); calculate(shuru[0],shuru[0].arrve.hour,shuru[0].arrve.mintes); //执行第一个到达的进程 int count=0; shuruans[count] = shuru[0]; for(int k=0;k&lt;n-1;k++) &#123; /* 从第一次执行完成后，每次执行时， 先从已经到达的进程中选择优先级最高的进程进行执行； 执行完后再次选择，直到所有进程都执行完毕。 */ init(shurutemp);//作为中间变量，储存筛选出来的进程 for (int i = 0; i &lt; shuru.length; i++) &#123; if (shuru[i].arrve.hour*60+shuru[i].arrve.mintes &lt;= shuruans[count].end.hour*60+shuruans[count].end.mintes &amp;&amp; !find(shuruans,shuru[i]) ) &#123; shurutemp[i] = shuru[i]; &#125; if(i==shuru.length-1 &amp;&amp; shurutemp[0].id==0)&#123; shurutemp[0] = shuru[count+1]; &#125; &#125; SortBygrade(shurutemp);//按优先级排序 if(count&lt;n)&#123; if(shurutemp[0].arrve.hour*60+shurutemp[0].arrve.mintes &lt;= shuruans[count].end.hour*60+shuruans[count].end.mintes) &#123; calculate(shurutemp[0], shuruans[count].end.hour, shuruans[count].end.mintes); &#125; else&#123; calculate(shurutemp[0],shurutemp[0].arrve.hour,shurutemp[0].arrve.mintes); &#125; count+=1; shuruans[count] = shurutemp[0]; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; show(shuru[i]); &#125; System.out.printf(&quot;------------------------------------------------\\n&quot;); //计算带权平均与输出 for(int i=0;i&lt;n;i++)&#123; show(shuruans[i]); &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n); &#125; public void calculate(Shuru shuru,int TimeHour,int TimeMinte)&#123; shuru.start.hour = TimeHour; shuru.start.mintes = TimeMinte; //计算结束时间 if ((shuru.start.mintes + shuru.zx) &gt;= 60) &#123; shuru.end.hour = (shuru.start.hour + 1); shuru.end.mintes = (shuru.zx + shuru.start.mintes - 60); &#125;else &#123; shuru.end.hour = shuru.start.hour; shuru.end.mintes = shuru.start.mintes + shuru.zx; &#125; //计算周转时间 if (shuru.end.hour == shuru.arrve.hour) &#123; shuru.zz = shuru.end.mintes - shuru.arrve.mintes; &#125;else&#123; shuru.zz = (shuru.end.hour - shuru.arrve.hour) * 60 + shuru.end.mintes - shuru.arrve.mintes; &#125; shuru.zzxs = (float)shuru.zz / shuru.zx; &#125; public void show (Shuru shuru)&#123; System.out.printf(&quot;%d\\t%s\\t\\t%d\\t\\t%d（分钟）\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs); &#125; public static void main(String[]args)&#123; SJF j = new SJF(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); j.sjf(n); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*5001 p1 1 9:40 205004 p4 4 10:10 105005 p5 3 10:05 305002 p2 3 9:55 155003 p3 2 9:45 25 *//*1001 p1 1 10:00 201002 p2 2 9:20 651003 p3 2 10:25 501004 p4 3 8:10 101005 p5 2 7:40 201006 p6 1 11:20 1001007 p7 1 10:30 120 */ 时间片轮转算法主要思想设置时间片段，每次进入CPU的进程，只允许运行时间片段长度的时间，时间片用完后，解除CPU占用，进入当前就绪队列的最后； CPU再选入就绪队列中最前面的进程调入CPU运行；如此反复，直到所有进程都运行完毕。 Java具体实现数据结构123456789101112131415161718192021222324252627//数据结构定义class Time &#123; int hour; int mintes; public static void timePlus(Time begin, int time) &#123; begin.hour = (begin.hour + (int) (begin.mintes + time) / 60); begin.mintes = ((begin.mintes + time) % 60); &#125; public static int timesub(Time begin,Time end)&#123; return (end.hour*60+end.mintes - begin.hour*60+begin.mintes); &#125;&#125;class Process&#123; int id; String name; //进程名 int zx;//执行时间 Time arrive; //到达就绪时间 Time start;//每轮开始开始时间 Time first;//首次执行时间 int have_finished;//已完成时间 Time arr;//每轮到达时间 Time end;//完成时间 int zz; //周转时间=完成时间-到达时间 double zzxs; //周转系数 =周转时间/执行时间 int flag;&#125; 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273public class RoundRobin &#123; public void SortByTime(Process shuru[]) &#123;//比较到达时间 for (int i = 0; i &lt;=shuru.length-1; i++) &#123; for (int j = i+1; j &lt; shuru.length; j++) &#123; if (shuru[j].arrive.hour*60+shuru[j].arrive.mintes &lt; shuru[i].arrive.hour*60+shuru[i].arrive.mintes) &#123; Process t = shuru[i]; shuru[i] = shuru[j]; shuru[j] = t; &#125; &#125; &#125; &#125; public void insert(Process a[],Process b)&#123; int n = a.length; Process temp; temp = b; if(find(b,a)) remove(a,b); for (int j = 0; j &lt; n; j++) &#123; if (a[j].name == &quot;nothing&quot; || j==n-1)&#123; a[j] = temp;//新增 a[j].start.hour = 0; a[j].start.mintes = 0; break; &#125; &#125; &#125; public void remove(Process A[],Process a)&#123; int len = A.length; for (int i=0;i&lt;len;i++)&#123; if (A[i].id==a.id)&#123; for (int j=i;j&lt;len-1;j++)&#123; A[j] = A[j+1]; &#125; &#125; break; &#125;// if (A[len-1].id==A[len-2].id)&#123;// A[len - 1].id = 0;// A[len - 1].name = &quot;nothing&quot;;// A[len - 1].zx = 0;// A[len - 1].arrive.hour = 0;// A[len - 1].arrive.mintes = 0;// A[len - 1].start.hour = 0;// A[len - 1].start.mintes = 0;// A[len - 1].have_finished = 0;// A[len - 1].arr.hour = 0;// A[len - 1].arr.mintes = 0;// A[len - 1].end.hour = 0;// A[len - 1].end.mintes = 0;// A[len - 1].zz = 0;// A[len - 1].zzxs = 0;// A[len - 1].flag = -1;// &#125; &#125; public void init(Process input[])&#123; for(int i=0;i&lt;input.length;i++)&#123; input[i] = new Process(); input[i].id = 0; input[i].name = &quot;nothing&quot;; input[i].zx = 0; input[i].arrive = new Time(); input[i].arrive.hour = 0; input[i].arrive.mintes = 0; input[i].start = new Time(); input[i].start.hour = 0; input[i].start.mintes = 0; input[i].first = new Time(); input[i].have_finished = 0; input[i].arr = new Time(); input[i].arr.hour = 0; input[i].arr.mintes = 0; input[i].end = new Time(); input[i].end.hour = 0; input[i].end.mintes = 0; input[i].zz = 0; input[i].zzxs = 0; input[i].flag = -1; &#125; &#125; public void show (Process process[]) &#123; int sumzz=0; double sumzzxs=0; int n = process.length; System.out.println(&quot;进程id\\t进程名\\t到达时间\\t执行时间\\t\\t首次开始时间\\t结束时间\\t\\t周转时间\\t\\t带权周转系数&quot;); for (int i = 0; i &lt; n; i++) &#123; process[i].zz = ((process[i].end.hour*60+process[i].end.mintes)-(process[i].arrive.hour*60+process[i].arrive.mintes)); process[i].zzxs = (float)process[i].zz/process[i].zx; sumzz += process[i].zz; sumzzxs += process[i].zzxs; System.out.printf(&quot;%d\\t%s\\t\\t%02d:%02d\\t%d(分钟)\\t\\t%02d:%02d\\t\\t%02d:%02d\\t\\t%d（分钟）\\t\\t%.2f\\n&quot;, process[i].id, process[i].name, process[i].arrive.hour, process[i].arrive.mintes, process[i].zx, process[i].first.hour, process[i].first.mintes, process[i].end.hour, process[i].end.mintes, process[i].zz, process[i].zzxs); &#125; System.out.printf(&quot;系统平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,(float)sumzz/n); System.out.printf(&quot;带权平均周转时间\\t\\t\\t\\t\\t%10.2f（分钟）\\n&quot;,sumzzxs/n); &#125; public void showRun(Process process[], int n, Time now) &#123; System.out.println(&quot;第&quot;+n+&quot;执行和就绪队列&quot;); System.out.printf(&quot;当前时间: %02d :%02d\\n&quot;,now.hour,now.mintes); System.out.println(&quot;ID号\\t名字\\t到达时间\\t总执行时间(分钟)\\t当前开始时间\\t已完成时间\\t剩余时间(分钟)&quot;); for(int i=0;i&lt;process.length;i++)&#123; if (process[i].id!=0 &amp;&amp; process[i].name!=&quot;nothing&quot;) &#123; System.out.printf(&quot;%d\\t%s\\t%02d:%02d\\t%d（分钟）\\t\\t\\t%02d:%02d\\t%d(分钟)\\t\\t%d（分钟）\\n&quot;, process[i].id, process[i].name, process[i].arrive.hour, process[i].arrive.mintes, process[i].zx, process[i].start.hour, process[i].start.mintes, process[i].have_finished, (process[i].zx - process[i].have_finished)); &#125; &#125; &#125; public boolean sure(Process input[])&#123; int n=input.length; for(int j=0;j&lt;n;j++)&#123; if (input[j].flag!=1) &#123; return true; &#125; &#125; return false; &#125; public boolean find(Process process,Process A[])&#123; for(int i=0;i&lt;A.length;i++)&#123; if (process.id==A[i].id)&#123; return true; &#125; &#125; return false; &#125; public void calculate(Process A[],Time now,int time,Process B[])&#123; if (time&lt;=0)&#123; return; &#125; else &#123; int less; A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; /* 不可直接A.start = now,这只是建立索引，start与now会一同变化 */ less = A[0].zx - A[0].have_finished; //第一次执行进程 if (A[0].have_finished == 0) &#123; A[0].first.hour = now.hour; A[0].first.mintes = now.mintes; if (less &gt; time) &#123; //剩余未做完&gt;大于时间片 A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; A[0].have_finished += time; Time.timePlus(now, time); time = 0; &#125; else &#123; A[0].have_finished = A[0].zx; A[0].flag = 1; //表示做完了 A[0].end.hour = (now.hour + (int) (now.mintes + less) / 60); A[0].end.mintes = ((now.mintes + less) % 60); Time.timePlus(now, (time - less)); &#125; &#125; else &#123; if (less &gt; time) &#123; A[0].start.hour = now.hour; A[0].start.mintes = now.mintes; A[0].have_finished += time; Time.timePlus(now, time); time = 0; &#125; else &#123; A[0].have_finished = A[0].zx; A[0].flag = 1; //表示做完了 A[0].end.hour = (now.hour + (int) (now.mintes + less) / 60); A[0].end.mintes = ((now.mintes + less) % 60); Time.timePlus(now, (time - less));// calculate(A, now, time,B); &#125; &#125; &#125; &#125; public void rr(int n,int Timeslice) &#123; Scanner scan = new Scanner(System.in); Process input[] = new Process[n]; Process temp[] = new Process[n]; Process ans[] = new Process[5]; //初始化 init(input); init(ans); init(temp); //输入进程 for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;进程&quot; + (i + 1) + &quot;信息输入：&quot;); System.out.println(&quot;进程id\\t进程名\\t优先级\\t进程到达时间:\\t进程执行时间&quot;); String s = scan.nextLine(); String[] sa = s.split(&quot; &quot;); input[i].id = Integer.parseInt(sa[0]); input[i].name = sa[1]; String[] time = sa[2].split(&quot;:&quot;); input[i].arrive.hour = Integer.parseInt(time[0]); input[i].arrive.mintes = Integer.parseInt(time[1]); input[i].zx = Integer.parseInt(sa[3]); &#125; SortByTime(input); int count=0,count_num=0,timeset; /* count用于计算已经完成了多少个进程 count_num 第几轮执行 */ Time now = new Time(); now.hour = input[0].arrive.hour; now.mintes = input[0].arrive.mintes; insert(temp,input[0]); while(sure(ans))&#123;// while(count_num&lt;20)&#123; count_num++; calculate(temp, now, Timeslice,ans); showRun(temp, count_num, now); for (int j=0;j&lt;n;j++)&#123; if (temp[j].flag==1 &amp;&amp; count&lt;5 &amp;&amp; !find(temp[j],ans))&#123; ans[count++] = temp[j]; remove(temp,temp[j]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123;//查找已经到达的程序 if (now.hour * 60 + now.mintes &gt; input[i].arrive.hour * 60 + input[i].arrive.mintes) &#123; if (!find(input[i], temp) &amp;&amp; !find(input[i],ans)) &#123; insert(temp, input[i]); &#125; &#125; &#125; insert(temp, temp[0]); &#125; show(ans); &#125; public static void main(String[]args)&#123; RoundRobin j = new RoundRobin(); Scanner s = new Scanner(System.in); System.out.print(&quot;请输入进程数目：\\n&quot;); int n = s.nextInt(); System.out.print(&quot;请输入时间片时间：\\n&quot;); int TimeSlice = s.nextInt(); j.rr(n, TimeSlice); System.out.println(&quot;所有进程执行完毕！&quot;); &#125;&#125;/*5001 p1 9:40 205004 p4 10:10 105005 p5 10:05 305002 p2 9:55 155003 p3 9:45 25 */ 2021/5/9 21:00 今天就写到这，下次补充 2021/5/13 9:23 补充,银行家算法 银行家算法这个算法好像是不强制要求完成的，故此算法存在大问题的可能性较大（我不记得了o(￣▽￣)o） 主要思想我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 为保证资金的安全，银行家规定： (1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客； (2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量； (3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款； (4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金. Java具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285import jdk.management.resource.internal.inst.FileOutputStreamRMHooks;import javax.lang.model.element.NestingKind;import javax.print.attribute.standard.Finishings;import java.util.Scanner;public class Banker&#123;//BankerOfAlgorithm 银行家算法 int Max[][]; int Allocation[][]; int Need[][]; int Available[]; int Work[]; String name[]; int temp[]; int S = 100, P = 100; int safequeue[]; int Flag[]; int Request[]; Scanner sc; public Banker() &#123; int maxsize = 100; int Max[][] = new int[maxsize][maxsize]; int Allocation[][] = new int[maxsize][maxsize]; int Need[][] = new int[maxsize][maxsize]; int Available[] = new int[maxsize]; int Work[] = new int[maxsize]; String name[] = new String[maxsize]; int temp[] = new int[maxsize]; int S = 100, P = 100; int Flag[] = new int[maxsize]; int safequeue[] = new int[maxsize]; int Request[] = new int[maxsize]; &#125; public boolean iffinish()&#123; for (int i=0;i&lt;P;i++)&#123; for (int j=0;j&lt;S;j++)&#123; if (Need[i][j]!=0)&#123; return false; &#125; &#125; &#125; return true; &#125; public void Showdata() &#123; int i, j, k, l,temp=0;; System.out.println(&quot;进程名\\t\\t最大需求量\\t尚需求量\\t\\t已分配量\\t\\t执行是否结束&quot;); System.out.print(&quot;\\t\\t\\t&quot;); for (j = 0; j &lt; 3; j++) &#123; for (i = 0; i &lt; S; i++) &#123; System.out.print(name[i] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); &#125; System.out.println(); for (i = 0; i &lt; P; i++) &#123; temp = 0; System.out.print(&quot;进程P[&quot;+(i+1)+&quot;]&quot; + &quot;\\t\\t&quot;); for (j = 0; j &lt; S; j++) &#123; System.out.print(Max[i][j] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); for (l = 0; l &lt; S; l++) &#123; System.out.print(Need[i][l] + &quot; &quot;); temp += Need[i][j]; &#125; System.out.print(&quot;\\t\\t&quot;); for (k = 0; k &lt; S; k++) &#123; System.out.print(Allocation[i][k] + &quot; &quot;); &#125; System.out.print(&quot;\\t\\t&quot;); if(Flag[i]==1)&#123; System.out.printf(&quot;finish\\n&quot;); &#125;else&#123; System.out.printf(&quot;working\\n&quot;); &#125; &#125; System.out.println(&quot;\\n当前可用资源：&quot;); for (i = 0; i &lt; S; i++) &#123; System.out.print(Available[i] + &quot; &quot;); &#125; System.out.println(); &#125; public int Judgesafe() &#123; int[][] tempwork = new int[100][100]; int i, x, k = 0, m, apply; int[] Finish = new int[100]; int[] temp = new int[100]; int j; int flag = 0; Work = new int[100]; for (i = 0; i &lt; S; i++) &#123; Work[i] = Available[i]; &#125; for (i = 0; i &lt; P; i++) &#123; apply = 0; for (j = 0; j &lt; S; j++) &#123; if (Finish[i] == 0 &amp;&amp; Need[i][j] &lt;= Work[j]) &#123; apply++; if (apply == S) &#123; for (m = 0; m &lt; S; m++) &#123; tempwork[i][m] = Work[m]; Work[m] = Work[m] + Allocation[i][m]; &#125; Finish[i] = 1; temp[k] = i; i = -1; k++; flag++; &#125; &#125; &#125; &#125; for (i = 0; i &lt; P; i++) &#123; if (Finish[i] == 0) &#123; System.out.println(&quot;申请不成功&quot;); return -1; &#125; &#125; System.out.println(&quot;申请成功&quot;); System.out.print(&quot;分配的序列:&quot;); for (i = 0; i &lt; P; i++) &#123; System.out.print(&quot;P[&quot;+(temp[i]+1)+&quot;]&quot;); if (i &lt; P - 1) &#123; System.out.print(&quot;--&gt;&quot;); &#125; &#125; System.out.println(); return 0; &#125; public void Changedata(int flag) &#123; for (int i = 0; i &lt; S; i++) &#123; Available[i] = Available[i] - Request[i]; Allocation[flag][i] = Allocation[flag][i] + Request[i]; Need[flag][i] = Need[flag][i] - Request[i]; &#125; &#125; public void Share() &#123; sc = new Scanner(System.in); int i, flag; char ch = &#x27;Y&#x27;; System.out.println(&quot;输入请求资源的进程：&quot;); flag = sc.nextInt()-1; Request = new int[100]; if (flag &gt;= P) &#123; System.out.println(&quot;此进程不存在!&quot;); &#125; else &#123; System.out.println(&quot;输入此进程对各个资源的请求数量：&quot;); for (i = 0; i &lt; S; i++) &#123; Request[i] = sc.nextInt(); &#125; for (i = 0; i &lt; S; i++) &#123; if (Request[i] &gt; Need[flag][i]) &#123; System.out.println(&quot;进程P[&quot; + (flag+1)+&quot;]&quot; + &quot;申请的资源大于可用资源需要的资源!&quot;); System.out.println(&quot;分配不合理不予分配!&quot;); ch = &#x27;N&#x27;; break; &#125; else if (Request[i] &gt; Available[i]) &#123; System.out.println(&quot;进程&quot; + (flag +1)+ &quot;申请的资源大于可利用的资源。&quot;); System.out.println(&quot;分配不合理，不予分配!&quot;); ch = &#x27;N&#x27;; break; &#125; &#125; if (ch == &#x27;Y&#x27;) &#123; if (Judgesafe() == -1) &#123; System.out.println(&quot;进程&quot; + flag + &quot;申请资源后，系统进入死锁状态，分配失败!&quot;); for (int j = 0; j &lt; S; j++) &#123; Available[j] = Available[j] + Request[j]; Allocation[flag][j] = Allocation[flag][j] - Request[j]; Need[flag][j] = Need[flag][j] + Request[j]; &#125; &#125; Changedata(flag); &#125; if(iffinish())&#123; Flag[i]=1; &#125; &#125; &#125; public static void main(String[] args) &#123; Banker mytext = new Banker(); Scanner sc = new Scanner(System.in); int i, j, M, N, number; String choice, tempstring; System.out.println(&quot;输入资源种类：&quot;); N = sc.nextInt(); mytext.S = N; System.out.println(&quot;输入进程的数量：&quot;); M = sc.nextInt(); mytext.P = M; System.out.println(&quot;输入资源的名称和数量：&quot;); mytext.name = new String[100]; mytext.Available = new int[100]; for (i = 0; i &lt; N; i++) &#123; mytext.name[i] = sc.next(); mytext.Available[i] = sc.nextInt(); &#125; System.out.println(&quot;输入各进程资源最大需求量：&quot;); System.out.print(&quot;进程名\\t\\t&quot;); for (i = 0; i &lt; mytext.S; i++) &#123; System.out.print(mytext.name[i] + &quot; &quot;); &#125; System.out.printf(&quot;\\n&quot;); sc.nextLine(); mytext.Max = new int[100][100]; mytext.Flag = new int[100]; for (i = 0; i &lt; M; i++) &#123; mytext.Flag[i] = 0; String ss = sc.nextLine(); String[] sslist = ss.split(&quot; &quot;); for (j = 0; j &lt; N; j++) &#123; mytext.Max[i][j] = Integer.parseInt(sslist[j+1]); &#125; &#125; System.out.println(&quot;输入各进程资源已分配量：&quot;); System.out.print(&quot;进程名\\t\\t&quot;); for (i = 0; i &lt; mytext.S; i++) &#123; System.out.print(mytext.name[i] + &quot; &quot;); &#125; System.out.printf(&quot;\\n&quot;); mytext.Allocation = new int[100][100]; mytext.Need = new int[100][100]; for (i = 0; i &lt; M; i++) &#123; String as = sc.nextLine(); String[] aslist = as.split(&quot; &quot;); for (j = 0; j &lt; N; j++) &#123; mytext.Allocation[i][j] = Integer.parseInt(aslist[j+1]); mytext.Available[j] = mytext.Available[j] - mytext.Allocation[i][j]; mytext.Need[i][j] = mytext.Max[i][j] - mytext.Allocation[i][j]; &#125; mytext.Judgesafe(); &#125; mytext.Showdata(); while (true) &#123; System.out.println(&quot;是否分配资源? Y/N：&quot;); choice = sc.next(); char choice_char = choice.charAt(0); switch (choice_char) &#123; case &#x27;N&#x27;: System.exit(0); default: mytext.Share(); break; &#125; mytext.Showdata(); &#125; &#125;&#125; /*A 10B 5C 7进程P[1] 7 5 3进程P[2] 3 2 2进程P[3] 9 0 2进程P[4] 2 2 2进程P[5] 4 3 3进程P[1] 0 1 1进程P[2] 2 0 0进程P[3] 3 0 2进程P[4] 2 1 1进程P[5] 0 0 2 */ 以下是储存管理算法 储存管算法固定分区储存管理主要思想固定式分区是在处理作业之前存储器就已经被划分成若干个分区，每个分区的大小可以相同，也可以不同。但是，一旦划分好分区后，主存储器中的分区的个数就固定了，且每个分区的大小固定不变。 Java具体实现数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Collections;import java.util.LinkedList;import java.util.Scanner;class Node implements Comparable&lt;Node&gt; &#123; private int id; //id号 private int size; //分区长度 private int address; //分区地址 String s; //分区状态 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getS() &#123; return s; &#125; public void setS(String ss) &#123; this.s = ss; &#125; @Override public String toString() &#123; return &quot;Node[ id=&quot; + id + &quot;size=&quot; + size + &quot;address=&quot; + address + &quot;s=&quot; + s + &quot;]&quot;; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class FPSM &#123; private int nums; private LinkedList&lt;Node&gt; NodeList; public void show() &#123; System.out.println(&quot;*************打印区块信息**************&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (int i = 0; i &lt; nums; i++) &#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,node.getId(),node.getSize(),node.getAddress(),node.getS()); &#125; &#125; public boolean find() &#123; for (int i = 0; i &lt; nums; i++) &#123; if (NodeList.get(i).getS() != &quot;0&quot;) &#123; return true; &#125; &#125; return false; &#125; public void allocate() &#123; Collections.sort(NodeList); //按分区大小排序 Scanner scan = new Scanner(System.in); show(); System.out.println(&quot;请输入作业数:&quot;); int n = scan.nextInt(); System.out.println(&quot;请输入这&quot; + (n) + &quot;作业的信息:&quot;); int[] list = new int[n]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;请输入作业&quot; + (i + 1) + &quot;的大小:&quot;); list[i] = scan.nextInt(); for (int j = 0; j &lt; nums; j++) &#123; if (NodeList.get(j).getSize() &gt; list[i]) &#123; String ss = Integer.toString((i + 1)); String s = &quot;JOB&quot; + ss; NodeList.get(j).setS(s); break; &#125; if(j==(nums-1))&#123; System.out.println(&quot;JOB&quot; + (i + 1) + &quot;大小超过最大分区大小，分配失败&quot;); &#125; &#125; &#125; System.out.println(&quot;各作业信息:&quot;); System.out.println(&quot;作业名\\t\\t作业大小&quot;); for (int i = 0; i &lt; n; i++) &#123; System.out.println(&quot;JOB&quot; + (i + 1) + &quot;\\t\\t&quot; + list[i] + &quot;KB&quot;); &#125; &#125; public void free() &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入要回收的作业名:&quot;); String name = scan.next(); for (int i = 0; i &lt; nums; i++)&#123; if (NodeList.get(i).getS().equalsIgnoreCase(name)) &#123; //字符串比较需要调用函数，不然会出错 NodeList.get(i).setS(&quot;0&quot;); System.out.println(&quot;回收成功&quot;); break; &#125; if (i==nums-1)&#123; System.out.println(&quot;回收失败，分配区中未找到该作业，请从新输入！&quot;); &#125; &#125; &#125; private void init() &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入系统的分区块数：&quot;); nums = scan.nextInt(); System.out.println(&quot;请依次输入：&quot;); System.out.println(&quot;分区号\\t大小\\t起始&quot;); NodeList = new LinkedList&lt;Node&gt;(); for (int i = 0; i &lt; nums; i++) &#123; NodeList.add(new Node()); &#125; scan.nextLine(); Node[] node = new Node[nums]; for (int i = 0; i &lt; nums; i++) &#123; String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); NodeList.get(i).setId(Integer.parseInt(slist[0])); NodeList.get(i).setSize(Integer.parseInt(slist[1])); NodeList.get(i).setAddress(Integer.parseInt(slist[2])); NodeList.get(i).setS(&quot;0&quot;); &#125; &#125; private void fpsm() &#123; Scanner scan = new Scanner(System.in); init(); allocate(); show(); while (find()) &#123; System.out.println(&quot;是否还需要回收(y/n):&quot;); char c = scan.next().charAt(0); if (c == &#x27;Y&#x27; || c == &#x27;y&#x27;) &#123; free(); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; FPSM f = new FPSM(); f.fpsm(); &#125;&#125;/*1 12 202 32 323 64 644 128 1285 100 256 */ 可变分区储存管理主要思想在作业要求装入内存时，若当时内存中有足够的存储空间满足该作业的需求，那就划分出一个与作业相对地址空间同样大小的分区分配给它使用。 前后相邻接分区的四种关系 释放分区的前、后邻接分区都是已分配区，没有合并的问题存在。 释放分区的前邻接分区是空闲区，后邻接分区是已分配区。释放区应该和前邻接的空闲区合并成一个新的空闲区。 释放区的前邻接分区是已分配区，后邻接分区是空闲区。因此，释放分区应该和后邻接的空闲区合并成一个新的空闲区。 释放区的前、后邻接分区都是空闲区。因此，释放区应该和前、后两个邻接的空闲区合并成一个新的空闲区。 空闲分区合并的时机 一是调度到某作业时，若系统的每个空闲区尺寸都小于它的需要，但空闲区总存储量大于它的存储请求，于是进行空闲区合并，得到一个大的空闲区，满足该作业的需要。 一是只要有作业运行完归还所占用的存储区，系统就进行空闲区的合并。 Java具体实现数据结构123456789101112131415161718192021222324252627282930313233class Node implements Comparable&lt;Node&gt; &#123; private int size; //分区长度 private int address; //分区地址 String flag; //分区状态 public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getFlag() &#123; return flag; &#125; public void setFlag(String ss) &#123; this.flag = ss; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264public class VPSM &#123; private int length; private int totalsize; private int startaddress; private LinkedList&lt;Node&gt; NodeList; private LinkedList&lt;Node&gt; FreeList; public void show() &#123; System.out.println(&quot;**********可变分区管理**********&quot;); System.out.println(&quot;* [1] 内存分配 *&quot;); System.out.println(&quot;* [2] 内存去配 *&quot;); System.out.println(&quot;* [0] 退出管理 *&quot;); System.out.println(&quot;***********分配算法************&quot;); System.out.println(&quot;* [1] 最先分配算法 *&quot;); System.out.println(&quot;* [2] 最优分配算法 *&quot;); System.out.println(&quot;* [0] 最坏分配算法 *&quot;); System.out.println(&quot;*************主存分配情况**************&quot;); System.out.println(&quot;已分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); int i,j; for (i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(i+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; System.out.println(&quot;未分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (j=0;j&lt; FreeList.size();j++)&#123; Node node = FreeList.get(j); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(j+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; &#125; //分配 private void FirstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小&quot;); int size; for (int i=0;i&lt;length;i++)&#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=0;j&lt; FreeList.size();j++) &#123; if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if(j == FreeList.size()-1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress()-o2.getAddress(); &#125; &#125;); System.out.println(&quot;分配成功&quot;); &#125; private void BestAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小大小&quot;); int size; for (int i=1;i&lt;length;i++) &#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=0;j&lt; FreeList.size();j++) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; &#125; private void WorstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入请求分配作业信息：&quot;); System.out.println(&quot;作业名\\t分配主存大小大小&quot;); int size; for (int i=1;i&lt;length;i++) &#123; Node node = new Node(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); size = Integer.parseInt(slist[1]); for(int j=FreeList.size()-1;j&gt;=0;j--) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(slist[0]); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; &#125; public void free()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入你要删除的作业名：&quot;); String s = scan.next(); System.out.println(s); Node recycle = new Node(); int neighborup = -1;//记录上面相邻接块的位置，-1代表不邻接 int neighbordown = -1;//记录上面相邻接块的位置，-1代表不邻接 for (int i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); String flag = node.getFlag(); if(flag.equalsIgnoreCase(s))&#123; recycle.setSize(node.getSize()); recycle.setAddress(node.getAddress()); recycle.setFlag(node.getFlag()); //先找到要回收的内存,保留信息 NodeList.remove(node); //移除作业 &#125;// else if(!(flag.equalsIgnoreCase(s)) &amp;&amp; (i==(NodeList.size()-1)))&#123;// System.out.println(&quot;未找到该作业!分配失败!&quot;);// return ;// &#125; &#125; for (int i = 0; i &lt;FreeList.size(); i++) &#123; Node free = FreeList.get(i); //上邻 if(recycle.getAddress()==(free.getAddress()+free.getSize()))&#123; neighborup = FreeList.indexOf(free); free.setSize(free.getSize()+recycle.getSize());//更新区间长度 FreeList.set(neighborup,free); &#125; //下邻 if((recycle.getAddress()+recycle.getSize())==free.getAddress())&#123; neighbordown = FreeList.indexOf(free);//更新两块合并后的长度 free.setAddress(recycle.getAddress());//更新该空闲区间首地址 free.setSize(free.getSize()+recycle.getSize());//更新该空闲区间长度 FreeList.set(neighbordown,free); &#125; //上下邻 if (neighbordown!=-1 &amp;&amp; neighborup!=-1)&#123; Node up = FreeList.get(neighborup); Node down = FreeList.get(neighbordown); up.setSize(down.getSize()-up.getSize()); FreeList.set(neighbordown,up);//修改链表中三块合一后的最终空闲块 FreeList.remove(down);//下面这块已经被上面那块合并 &#125; &#125; if (neighbordown==-1 &amp;&amp; neighborup==-1)&#123; Node addFree = new Node(); addFree.setSize(recycle.getSize()); addFree.setAddress(recycle.getAddress()); addFree.setFlag(&quot;空闲&quot;); FreeList.addLast(addFree); &#125; Collections.sort(FreeList); &#125; private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入内存大小：&quot;); totalsize = scan.nextInt(); System.out.println(&quot;请输入起始地址大小：&quot;); startaddress = scan.nextInt(); //初始空闲化分区 NodeList = new LinkedList&lt;Node&gt;(); FreeList = new LinkedList&lt;Node&gt;(); Node start = new Node(); start.setSize(totalsize); start.setAddress(startaddress); start.setFlag(&quot;空闲&quot;); FreeList.add(start); &#125; private void vpsm() &#123; Scanner scan = new Scanner(System.in); init(); show(); while (true) &#123; System.out.println(&quot;请输入要进行的管理选项：&quot;); int FuncChoic = scan.nextInt(); if (FuncChoic == 1) &#123; System.out.println(&quot;请输入分配方式选项：&quot;); int AllocWay = scan.nextInt(); System.out.println(&quot;请输入你要分配的个数：&quot;); int nums = scan.nextInt(); length = nums; switch (AllocWay) &#123; case 1: FirstAllotment(); break; case 2: BestAllotment(); break; case 3: WorstAllotment(); break; default: System.out.println(&quot;选择的分配方式有误&quot;); &#125; &#125; else if (FuncChoic == 2) &#123; free(); &#125; else if (FuncChoic == 0) &#123; System.exit(0); &#125; else &#123; System.out.println(&quot;输入有误！！请从新输入&quot;); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; VPSM f = new VPSM(); f.vpsm(); &#125;&#125;/*25640JOB_A 15JOB_B 50JOB_C 10JOB_D 25JOB_E 14JOB_F 32done */ 实验老师要求是页式、段式、段页式储存管理选一个，我选了短时储存管理，故只有一个啦 段式储存管理主要思想了进行段式管理，每道程序在系统中都有一个段（映象）表来存放该道程序各段装入主存的状况信息。段表中的每一项（对应表中的每一行）描述该道程序一个段的基本状况，由若干个字段提供。段名字段用于存放段的名称，段名一般是有其逻辑意义的，也可以转换成用段号指明。由于段号从0开始顺序编号，正好与段表中的行号对应，如2段必是段表中的第3行，这样，段表中就可不设段号（名）字段。装入位字段用来指示该段是否已经调入主存，“1”表示已装入，“0”表示未装入。在程序的执行过程中，各段的装入位随该段是否活跃而动态变化。当装入位为“1”时，地址字段用于表示该段装入主存中起始（绝对）地址，当装入位为“0”时，则无效（有时机器用它表示该段在辅存中的起始地址）。段长字段指明该段的大小，一般以字数或字节数为单位，取决于所用的编址方式。段长字段是用来判断所访问的地址是否越出段界的界限保护检查用的。访问方式字段用来标记该段允许的访问方式，如只读、可写、只能执行等，以提供段的访问方式保护。除此之外，段表中还可以根据需要设置其它的字段。段表本身也是一个段，一般常驻在主存中，也可以存在辅存中，需要时再调入主存。假设系统在主存中最多可同时有N道程序，可设N个段表基址寄存器。对应于每道程序，由基号（程序号）指明使用哪个段表基址寄存器。段表基址寄存器中的段表基址字段指向该道程序的段表在主存中的起始地址。段表长度字段指明该道程序所用段表的行数，即程序的段数。 Java具体实现数据结构123456789101112131415161718192021222324252627282930313233343536import java.util.Collections;import java.util.Comparator;import java.util.LinkedList;import java.util.Scanner;class Node implements Comparable&lt;Node&gt; &#123; private int size; //分区长度 private int address; //分区地址 String flag; //分区状态 public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; public int getAddress() &#123; return address; &#125; public void setAddress(int address) &#123; this.address = address; &#125; public String getFlag() &#123; return flag; &#125; public void setFlag(String ss) &#123; this.flag = ss; &#125; @Override public int compareTo(Node node) &#123; return this.getSize()-node.getSize(); &#125;&#125; 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322public class SSM &#123; private int totalsize; private int startaddress; private LinkedList&lt;Node&gt; NodeList; private LinkedList&lt;Node&gt; FreeList; public void show() &#123; System.out.println(&quot;**********段式储存管理**********&quot;); System.out.println(&quot;* [1] 内存分配 *&quot;); System.out.println(&quot;* [2] 内存去配 *&quot;); System.out.println(&quot;* [0] 退出管理 *&quot;); System.out.println(&quot;***********分配算法************&quot;); System.out.println(&quot;* [1] 最先分配算法 *&quot;); System.out.println(&quot;* [2] 最优分配算法 *&quot;); System.out.println(&quot;* [0] 最坏分配算法 *&quot;); System.out.println(&quot;*************主存分配情况**************&quot;); System.out.println(&quot;已分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); int i,j; for (i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(i+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; System.out.println(&quot;未分配：&quot;); System.out.println(&quot;分区号\\t大小(KB)\\t起始(KB)\\t状态&quot;); for (j=0;j&lt; FreeList.size();j++)&#123; Node node = FreeList.get(j); System.out.printf(&quot;%d\\t\\t%d\\t\\t%d\\t\\t%s\\n&quot;,(j+1),node.getSize(),node.getAddress(),node.getFlag()); &#125; &#125; public void ShowSegmentTable(String n)&#123; System.out.println(&quot;******打印&quot;+n+&quot;段表*****&quot;); System.out.println(&quot;段号\\t段长（KB）\\t基址（KB）&quot;); for (int i=0;i&lt;NodeList.size();i++)&#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0,5); String ID = line.substring(6,7); if(ns.equals(n))&#123; System.out.println(ID+&quot;\\t&quot;+node.getSize()+&quot;\\t\\t\\t&quot;+node.getAddress()); &#125; &#125; &#125; //分配 private void FirstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++)&#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=0;j&lt; FreeList.size();j++) &#123; if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if(j == FreeList.size()-1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress()-o2.getAddress(); &#125; &#125;); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; private void BestAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++) &#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=0;j&lt; FreeList.size();j++) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; private void WorstAllotment()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入作业名：&quot;); String name = scan.nextLine(); System.out.println(&quot;请输入&quot;+name+&quot;请求分配的内存大小（单位：KB）：&quot;); int allSize = scan.nextInt(); System.out.println(&quot;请输入分成几段：&quot;); int nums = scan.nextInt(); int size; for (int i=0;i&lt;nums;i++) &#123; Node node = new Node(); System.out.println(&quot;剩余&quot;+allSize+&quot;K的内存,请输入第&quot;+(i+1)+&quot;段内存大小（单位：KB）：&quot;); size = scan.nextInt(); String flag = name+&quot;(&quot;+Integer.toString(i)+&quot;)&quot;; for(int j=FreeList.size()-1;j&gt;=0;j--) &#123; //从空闲分区中查找 if (size &lt; FreeList.get(j).getSize()) &#123; node.setFlag(flag); node.setSize(size); node.setAddress(FreeList.get(j).getAddress()); FreeList.get(j).setAddress(FreeList.get(j).getAddress() + size); FreeList.get(j).setSize(FreeList.get(j).getSize() - size); NodeList.add(node); allSize -= size; break; &#125; if (j == FreeList.size() - 1) &#123; System.out.println(&quot;剩余储存空间不足，分配失败！&quot;); System.exit(0); &#125; &#125; show(); Collections.sort(NodeList, new Comparator&lt;Node&gt;() &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.getAddress() - o2.getAddress(); &#125; &#125;); Collections.sort(FreeList); &#125; System.out.println(&quot;分配成功&quot;); ShowSegmentTable(name); &#125; //去配 public boolean sure(String name)&#123; for(int i=0;i&lt; NodeList.size();i++)&#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0, 5); if (ns.equals(name))&#123; return true; &#125; &#125; return false; &#125; public void free()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入你要删除的作业名：&quot;); String name = scan.next(); Node recycle = new Node(); while(sure(name)) &#123; //每次free前要初始化邻接状态 int neighborup = -1;//记录上面相邻接块的位置，-1代表不邻接 int neighbordown = -1;//记录上面相邻接块的位置，-1代表不邻接 //查找要释放的作业 for (int i = 0; i &lt; NodeList.size(); i++) &#123; Node node = NodeList.get(i); String line = node.getFlag(); String ns = line.substring(0, 5); if (ns.equals(name)) &#123; recycle.setSize(node.getSize()); recycle.setAddress(node.getAddress()); recycle.setFlag(node.getFlag()); //先找到要回收的内存,保留信息 NodeList.remove(node); //移除作业 break; &#125; else if (!(ns.equals(name)) &amp;&amp; (i == (NodeList.size() - 1))) &#123; System.out.println(&quot;未找到该作业!去配失败!&quot;); return; &#125; &#125; //去配作业 for (int i = 0; i &lt; FreeList.size(); i++) &#123; Node free = FreeList.get(i); //上邻 if (recycle.getAddress() == (free.getAddress() + free.getSize())) &#123; neighborup = FreeList.indexOf(free); free.setSize(free.getSize() + recycle.getSize());//更新区间长度 FreeList.set(neighborup, free); &#125; //下邻 if ((recycle.getAddress() + recycle.getSize()) == free.getAddress()) &#123; neighbordown = FreeList.indexOf(free);//更新两块合并后的长度 free.setAddress(recycle.getAddress());//更新该空闲区间首地址 free.setSize(free.getSize() + recycle.getSize());//更新该空闲区间长度 FreeList.set(neighbordown, free); &#125; //上下邻 if (neighbordown != -1 &amp;&amp; neighborup != -1) &#123; Node up = FreeList.get(neighborup); Node down = FreeList.get(neighbordown); up.setSize(down.getSize() + up.getSize()-recycle.getSize()); FreeList.set(neighborup, up);//修改链表中三块合一后的最终空闲块 FreeList.remove(down);//下面这块已经被上面那块合并 &#125; &#125; if (neighbordown == -1 &amp;&amp; neighborup == -1) &#123; Node addFree = new Node(); addFree.setSize(recycle.getSize()); addFree.setAddress(recycle.getAddress()); addFree.setFlag(&quot;空闲&quot;); FreeList.addLast(addFree); &#125; Collections.sort(FreeList); System.out.println(&quot;回收&quot;+name+&quot;的段&quot;+recycle.getFlag()+&quot;成功！&quot;); &#125; &#125; //初始化 private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入初始内存大小：&quot;); totalsize = scan.nextInt(); System.out.println(&quot;请输入起始地址大小：&quot;); startaddress = scan.nextInt(); //初始空闲化分区 NodeList = new LinkedList&lt;Node&gt;(); FreeList = new LinkedList&lt;Node&gt;(); Node start = new Node(); start.setSize(totalsize); start.setAddress(startaddress); start.setFlag(&quot;空闲&quot;); FreeList.add(start); &#125; private void ssm() &#123; Scanner scan = new Scanner(System.in); init(); show(); while (true) &#123; System.out.println(&quot;请输入要进行的管理选项：&quot;); int FuncChoic = scan.nextInt(); if (FuncChoic == 1) &#123; System.out.println(&quot;请输入分配方式选项：&quot;); int AllocWay = scan.nextInt(); switch (AllocWay) &#123; case 1: FirstAllotment(); break; case 2: BestAllotment(); break; case 3: WorstAllotment(); break; default: System.out.println(&quot;选择的分配方式有误&quot;); &#125; &#125; else if (FuncChoic == 2) &#123; free(); &#125; else if (FuncChoic == 0) &#123; System.exit(0); &#125; else &#123; System.out.println(&quot;输入有误！！请从新输入&quot;); &#125; show(); &#125; &#125; public static void main(String[] args) &#123; SSM f = new SSM(); f.ssm(); &#125;&#125;/*25640JOB_A5022030JOB_C100303535 */ 页面置换算法主要思想这个较难，一两句话讲不清 参考链接 https://www.jianshu.com/p/18285ecffbfb Java具体实现算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231import java.util.*;public class PRA &#123; private int n;//物理块数 private int F;//未能找到的次数 缺页率=F/length private String name; //作业名 private int length; //作业长度 private List&lt;Integer&gt;list = null; //作业页面顺序 private Map&lt;Integer,Integer&gt;map = null; private int[][] showlist; public void ShowProcess()&#123; System.out.println(&quot;作业名：&quot;+name); System.out.println(&quot;作业调度过程&quot;); System.out.print(&quot; \\t&quot;); for (int i = 0; i &lt; length; i++) &#123; System.out.print((i+1)+&quot;\\t&quot;); &#125; System.out.println(); System.out.print(&quot; \\t&quot;); for (int i=0;i&lt;length;i++)&#123; System.out.print(list.get(i)+&quot;\\t&quot;); &#125; System.out.println(); for (int j=0;j&lt;n;j++) &#123; System.out.printf(&quot;块%d\\t&quot;,(j+1)); for (int i = 0; i &lt; length; i++) &#123; if(showlist[j][i]==-1)&#123; System.out.print(&quot; &quot;+&quot;\\t&quot;); &#125; else &#123; System.out.print(showlist[j][i] + &quot;\\t&quot;); &#125; &#125; System.out.println(); &#125; &#125; public void menu()&#123; System.out.println(&quot;**********请求分页式储存管理**********&quot;); System.out.println(&quot;* [1] FIFO分配 *&quot;); System.out.println(&quot;* [2] LRU(LFU)分配 *&quot;);// System.out.println(&quot;* [3] OPT分配 *&quot;); System.out.println(&quot;* [0] 退出 *&quot;); &#125; public void FIFO()&#123; map.clear(); F = 0; Queue&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsValue(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(temp, k); q.offer(temp); &#125; else &#123; int temp=q.poll();//排除的元素位置 map.remove(temp); map.put(temp,k); q.offer(temp); &#125; &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; else&#123; showlist[s][i] = -1; &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void LRU()&#123; map.clear(); F = 0; List&lt;Integer&gt; linkedlist = new LinkedList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsKey(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(k,temp); linkedlist.add(k);//添加位置 &#125; else &#123; int temp=linkedlist.get(0); int c=map.get(temp);//位置 map.remove(temp); map.put(k,c); linkedlist.remove(0); linkedlist.add(k); &#125; &#125; else//如果包含这个值，把这个值拿走并在后面压入 &#123; int d=linkedlist.indexOf(k);//查找存在位置 linkedlist.remove(d); linkedlist.add(k); &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; else&#123; showlist[s][i] = -1; &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void OPT()&#123; int j; for (int i=0;i&lt;length;i++) &#123; int k=list.get(i);//待处理元素 if (!map.containsValue(k))&#123; F++;//不能直接找到次数加1 if (map.size()&lt;n)&#123;//如果没有装满 int temp=map.size(); map.put(temp, k); &#125; else&#123;//如果装满了 int index=0;//把哪个位置的淘汰出去 int min=0;//初始最长长度 for (int t=0;t&lt;n;t++) &#123; for (j=i+1;j&lt;length;j++)&#123;//看后面哪一个出现的最晚 if (list.get(j)==map.get(t))&#123;//第一次找到 if (j-i&gt;min)&#123; index=t;//更新值 min=j-i; &#125; break; &#125; &#125; if (j==length)&#123;//如果到最后 index=t; min=j-i; &#125; &#125; map.remove(index); map.put(index,k);//修改表内元素 &#125; &#125; for (int s=0; s&lt;n;s++) &#123; if(map.get(s)!=null) &#123; showlist[s][i] = map.get(s); &#125; &#125; &#125; ShowProcess(); System.out.printf(&quot;缺页中断率为:%02.2f\\n&quot;,(F*1.0/length)*100); &#125; public void pra()&#123; map=new HashMap&lt;Integer,Integer&gt;();//存储每一个内储页框所存的内容 map.clear(); Scanner scan = new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入物理块数：&quot;); n = scan.nextInt(); menu(); System.out.println(&quot;请输入选项：&quot;); int choice = scan.nextInt(); scan.nextLine();//读走回车 System.out.println(&quot;请输入作业名：&quot;); name = scan.nextLine(); System.out.println(&quot;请输入作业的页面长度&quot;); length = scan.nextInt(); scan.nextLine();//读走回车 System.out.println(&quot;请输入作业的页面顺序&quot;); String str = scan.nextLine(); String[] sList = str.split(&quot; &quot;); list = new ArrayList&lt;Integer&gt;(); for (int i=0;i&lt;length;i++)&#123; list.add(Integer.parseInt(sList[i])); &#125; //showlist初始化 showlist = new int[n][length]; for (int j=0;j&lt;n;j++) &#123; for (int i = 0; i &lt; length; i++) &#123; showlist[j][i] = -1; &#125; &#125; switch (choice) &#123; case 1: FIFO(); break; case 2: LRU(); break;// case 3:// OPT();// break; case 0: System.exit(0); default: System.out.println(&quot;输入的选项有误请从新输入&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; PRA pra = new PRA(); pra.pra(); &#125;&#125;/*JOB_1207 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1JOB_2207 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 */ 补充这个算法中，showProcess函数存在错误，并非正确显示，可以忽略，如需输出，可自行再修改 磁盘臂调度算法主要思想思想太长了，我好懒不想写；参见别人的说法，连接如下 https://blog.csdn.net/Zhxin606a/article/details/89577836 Java具体实现数据结构 没有特殊的数据结构，用数组即可算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234import java.util.ArrayList;import java.util.Scanner;import java.util.Collections;import java.awt.*;import javax.swing.*;import java.awt.geom.*;public class DSASA extends JFrame&#123; private int length; //访问序列长度 private ArrayList&lt;Integer&gt; acessSque = null; //访问顺序 private int now; //正在访问页面 /** 调用画图函数 */ public void drawGraphics(int[] x) &#123; int[] y = new int[x.length]; for (int i = 0; i &lt; x.length; i++) &#123; y[i] = (i + 1) * 60; &#125; Draw d = new Draw(); d.setX(x); d.setY(y); d.setVisible(true); &#125; private void init()&#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入访问序列长度：&quot;); length = scan.nextInt(); scan.nextLine(); System.out.println(&quot;请输入访问柱面顺序：&quot;); acessSque = new ArrayList&lt;Integer&gt;();; acessSque.clear(); String s = scan.nextLine(); String[] slist = s.split(&quot; &quot;); for(int i=0; i&lt;length;i++)&#123; acessSque.add(Integer.parseInt(slist[i])); &#125; System.out.println(&quot;请输入正在访问的页面：&quot;); now = scan.nextInt(); scan.nextLine(); &#125; private void FCFS()&#123; System.out.println(&quot;***********FCFS磁盘臂调度过程***********&quot;); init(); int[] moveSque = new int[length+1]; int movesum = 0; moveSque[0] = now; for(int i=0; i&lt;length;i++)&#123; if(i==0) &#123; movesum += Math.abs(acessSque.get(i) - now); &#125; else &#123; movesum += Math.abs(acessSque.get(i)-acessSque.get(i-1)); &#125; moveSque[i+1] = acessSque.get(i); &#125; System.out.println(&quot;移动顺序为：&quot;); for(int i=0;i&lt; moveSque.length;i++)&#123; System.out.print(moveSque[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum); drawGraphics(moveSque); &#125; private void SSTF()&#123; System.out.println(&quot;***********SSTF磁盘臂调度过程***********&quot;); init(); int[] moveSque = new int[length+1]; int movesum = 0; int min; int x; moveSque[0] = now; Collections.sort(acessSque); for(int i=0; i&lt;length;i++)&#123; min = Math.abs((acessSque.get(0)-moveSque[i])); x = i; for (int j=0;j&lt; acessSque.size();j++)&#123; if(Math.abs((acessSque.get(j)-moveSque[i]))&lt;= min)&#123; min = Math.abs(acessSque.get(j)-moveSque[i]); x = acessSque.get(j); &#125; &#125; moveSque[i+1] = x; acessSque.remove(acessSque.indexOf(x)); movesum += Math.abs(moveSque[i]-moveSque[i+1]); &#125; System.out.println(&quot;最短优先的顺序为：&quot;); for(int i=0;i&lt; moveSque.length;i++)&#123; System.out.print(moveSque[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum); drawGraphics(moveSque); &#125; private void SCAN()&#123; System.out.println(&quot;***********电梯调度***********&quot;); init(); int[] moveSque_out_to_in = new int[length+1]; //由外向里 int[] moveSque_in_to_out = new int[length+1]; //由里向外 int movesum_out = 0; int movesum_in = 0; moveSque_out_to_in[0] = now; moveSque_in_to_out[0] = now; Collections.sort(acessSque); int locats=0; int count = 1; for(int i=0;i&lt;length-1;i++)&#123; if(acessSque.get(i)&lt;=now &amp;&amp; acessSque.get(i+1)&gt;now)&#123; locats = i; break; &#125; &#125; if(locats!=0) &#123; //开始位置在中间 count = 1; for (int k = locats; k &gt;= 0; k--) &#123; moveSque_in_to_out[count++] = acessSque.get(k); movesum_in += Math.abs(moveSque_in_to_out[count-1]-moveSque_in_to_out[count-2]); &#125; for (int k = locats+1; k &lt; length; k++) &#123; moveSque_in_to_out[count++] = acessSque.get(k); movesum_in += Math.abs(moveSque_in_to_out[count-1]-moveSque_in_to_out[count-2]); &#125; count = 1; for (int k=locats+1;k&lt;length;k++)&#123; moveSque_out_to_in[count++] = acessSque.get(k); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; for (int k=locats;k &gt;= 0; k--)&#123; moveSque_out_to_in[count++] = acessSque.get(k); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; else&#123; if (acessSque.get(length-1) &lt;= now)&#123; count = 1; for (int i=0;i&lt;length;i++)&#123; moveSque_out_to_in[count++] = acessSque.get(i); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; else&#123; count = 1; for (int i=length-1;i&gt;=0;i--)&#123; moveSque_in_to_out[count++] = acessSque.get(i); movesum_out += Math.abs(moveSque_out_to_in[count-1]-moveSque_out_to_in[count-2]); &#125; &#125; &#125; System.out.println(&quot;由里向外移动顺序为：&quot;); for(int i=0;i&lt; moveSque_in_to_out.length;i++)&#123; System.out.print(moveSque_in_to_out[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum_in); drawGraphics(moveSque_in_to_out); System.out.println(&quot;由外向里移动顺序为：&quot;); for(int i=0;i&lt; moveSque_out_to_in.length;i++)&#123; System.out.print(moveSque_out_to_in[i]+ &quot; &quot;); &#125; System.out.println(&quot;\\n移动柱面为：&quot;+movesum_out); drawGraphics(moveSque_out_to_in); &#125; public void dsasa() &#123; FCFS();SSTF();SCAN(); &#125; public static void main(String[] args) &#123; DSASA dsasa = new DSASA(); dsasa.dsasa(); &#125;&#125;class Draw extends JFrame &#123; private int[] x; private int[] y; public int[] getx() &#123; return x; &#125; public void setX(int[] x) &#123; this.x = x; &#125; public int[] gety() &#123; return y; &#125; public void setY(int[] y) &#123; this.y = y; &#125; public Draw() &#123; setSize(1000,800); setDefaultCloseOperation(DISPOSE_ON_CLOSE); setLocationRelativeTo(null); &#125; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D)g; //g是Graphics对象 g2.setStroke(new BasicStroke(3.0f)); g2.setColor(Color.blue); g2.drawLine(50, y[0], 950, y[0]); for (int i = 0; i &lt; x.length-1; i++) &#123;// g.setColor(Color.RED); g2.drawString(&quot;&quot; + x[i], x[i]*5, y[i]);// g.setColor(Color.BLUE); g2.drawLine(x[i]*5, y[i], x[i+1]*5, y[i+1]); &#125;// g.setColor(Color.RED); g.drawString(&quot;&quot; + x[x.length-1], x[x.length-1]*5, y[y.length-1]); &#125;&#125;/*898 183 37 122 14 124 65 6753 */","categories":[{"name":"OS","slug":"OS","permalink":"http://example.com/categories/OS/"}],"tags":[{"name":"操作系统算法","slug":"操作系统算法","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2021-04-17T08:38:33.000Z","updated":"2021-05-13T02:25:34.847Z","comments":true,"path":"2021/04/17/计算机网络/","link":"","permalink":"http://example.com/2021/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"写在最前，这个只是个人的计网知识总结，内容不是全面，可供参考 第一章互联网概述网络的网络​ 计算机网络（简称网络）由若干结点和连接这些结点的链路组成。网络中的结点可以是计算机、集线器、交换机或路由器等\\n ​ 多个网络通过路由器互联起来成为互连网；互连网是网络的网络\\n ​ 网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与互联网相连的计算机常称为主机**\\n 互联网的基础结构发展三个阶段第一阶段：ARPANET向互连网发展的过程\\n​ internet(互连网)是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。网络之间的通信协议可以任意选择\\n ​ Internet(互联网，或因特网)则是一个专用名词，它只电器那全球最大的、开放的、由众多网络相互连接而成的特定互联网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET\\n 第二阶段： 特点是建成了三级结构的互联网​ 分为 主干网、地区网和 校园网（或 企业网） ​ www万维网 第三阶段： 特点是逐渐形成了多层次IPS结构的互联网互联网的标准化工作互联网的组成​ 边缘部分 由所以连接在互联网上的主机组成。这部分是 用户直接使用的,用来进行通信（传输数据、音频或视频）和资源共享 ​ 核心部分 由大量网络和连接这些网络的路由器组成。这部分是 为边缘部分提供服务的 （提供连通性和交换） 互联网的边缘部分​ 处在互联网边缘的部分就是连接在互联网上的所有主机。这些主机由称为 端系统\\n ​ 主机A的某个进程和主机B上的某一个进程进行通信 简称为 “计算机之间的通信”\\n ​ 通信的方式可分为两大类：\\n 1.客户-服务器方式​ 客户和服务器都是只通信中所涉及的两个应用进程 ​ 客户是服务请求方，服务器是服务提供方 2.对等连接方式第二章物理层的基本概念用于物理层的协议也可称为物理层规程 数据通信的基础知识数据通信系统的模型一个数据通信系统可划分为三大部分，即源系统（或发送端、发送方）传输系统（传输网络）和目的系统（或接受端、接受方） 原系统包含以下两个部分： 源点： 源点设备产生要传输的数据；也可称为 源站，或 信源 发送器：通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器 目的系统包含以下两个部分： 接收器：接受传输过来的信号，并把它转换为能够被目标设备处理的信息，典型的接受器就是解调器 终点：终点设备从接收器获取传来的数字比特流，然后把信号输出。终点又称为目的站，或信宿 根据信号中代表消息的参数的取值方式不同 ，信号可以分为：模拟信号（或 连续信号）、数字信号（或 离散信号） 信道的基本概念第三章","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"马克思主义原理概论知识点总结","slug":"马克思主义原理概论知识点总结","date":"2021-01-08T13:07:31.000Z","updated":"2021-01-12T08:43:19.166Z","comments":true,"path":"2021/01/08/马克思主义原理概论知识点总结/","link":"","permalink":"http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"◆ 绪论一：马克思主义来源与创新 来源：德国古典哲学，英国古典政治经济学，英法空想社会主义 创新：马克思恩格斯批判地继承了前人的成果，创立了唯物史观和剩余价值学说，实现了人类思想史上的伟大革命。他们在这一时期创立的马克思主义，对人类先进思想已经提出的种种问题作了分析批判，对资本主义时代发展提出的理论课题作了科学的论述。马克思主义哲学为认识历史和时代问题提供了一种崭新的世界观和方法论原则。马克思主义政治经济学通过对资本主义生产方式的内在矛盾、运行机制和发展规律的深刻分析，揭示了资本主义剥削的秘密和它被社会主义必然代替的历史命运。科学社会主义在唯物史观和剩余价值论两大发现的基础上，阐明了由资本主义社会转变为社会主义、共产主义社会的客观规律，阐明了无产阶级获得彻底解放的历史条件和无产阶级的历史使命，使社会主义由空想成为科学。 二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征） 辩证唯物主义与历史唯物主义是马克思主义最根本的世界观和方法论 三：马克思主义最鲜明的政治立场是什么 马克思政党的一切理论和奋斗都应致力于实现以劳动人民为主体的最广大人民的根本利益，这是马克思主义最鲜明的政治立场 四：马克思主义最重要的理论品质 坚持一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理，是马克思主义最重要的理论品质 五：马克思主义最崇高的社会理想 实现物质财富极大丰富、人民精神境界极大提高、每个人自由而全面发展的共产主义社会，是马克思主义最崇高的社会理想 六：对待马克思主义的态度 必须坚持马克思主义不动摇，这是就马克思主义的基本原理、基本观点和基本方法而言的。随着时代的发展和历史条件的变化，要求我们在坚持马克思主义基本原理的基础上，不断地在实践中丰富和发展马克思主义。我们一定要适应实践的发展，以实践来检验一切，用发展着的马克思主义指导新的实践。我们必须坚持解放思想、实事求是、与时俱进，从理论和实践的结合上不断研究新情况、解决新问题，做到自觉地把思想认识从那些不合时宜的观念、做法和体制的束缚中解放出来，从对马克思主义的错误的和教条式的理解中解放出来，从主观主义和形而上学的桎梏中解放出来，不断有所发现、有所创造、有所前进。 ◆ 第一章一：近代哲学的基本问题 全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题 二：马克思主义物质的定义 物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映——列宁 三：马克思主义物质观理论意义 第一：坚持了物质的客观实在性原则，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。第二：坚持了能动的反映论和可知论，有力的批判了不可知论。第三：体现了唯物论和辩证法的统一。第四：体现了唯物主义自然观与唯物主义历史论的统一，为彻底的唯物主义奠定了理论基础。 四：联系特征 首先，联系具有客观性。其次，联系具有普遍性。最后，联系具有多样性。 五：发展的知识点 实质：是新事物的产生和旧事物的灭亡。 新旧事物：新事物是指合乎历史前进方向、具有远大前途的东西； 旧事物是指丧失历史必然性，日趋灭亡的东西 为什么新事物是不可战胜的？ ①新事物符合事物发展的必然趋势，具有强大的生命力和远大的发展前途，而旧事物丧失了存在的必然性，失去了生命力和发展前途，因而必然被新事物所代替。② 新事物优越于旧事物。新事物否定了旧事物中腐朽过时的东西，吸收并发展了旧事物中积极的因素，添加了旧事物中不能容纳的新的内容。③ 在社会领域中，新事物符合广大人民群众的根本利益和要求，因而得到广大人民群众的拥护和支持，它必然战胜旧事物。 六：矛盾的同一性，斗争性 矛盾的同一性：是指矛盾者双方相互依存、相互贯通的性质和趋势。 矛盾的斗争性：是矛盾者的对立面之间相互排斥、相互分离的性质和趋势。 七：矛盾的普遍性，特殊性 矛盾的普遍性：矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。 矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有不同特点；三是构成事物的诸多矛盾以及每一矛盾的不同方向各有不同的性质。 八：量变，质变 量变：事物数量的增减和次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物渐进过程的连续性。 质变：事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物渐进过程和连续性的中断。 量变和质变的辩证关系：1）量变是质变的必要准备 2）质变是量变的必然结果 3）量变和质变是相互渗透的 九：肯定，否定 肯定：维持现成事物存在的因素 否定：促成现成事物灭亡的因素 十：意识的作用 第一，意识是能动的，具有目的性和计划性。第二，意识活动具有创造性。第三，意识具有指导实践改造客观世界的作用。第四，意识还具有指导、控制人的行为和生理活动的作用。 十一：主观能动性与客观规律的辩证统一 首先，必须尊重客观规律。其次，在尊重客观规律的基础上，要充分发挥主观能动性。 ◆ 第二章一：实践在认识中的决定作用 第一，实践产生了认识的需要。第二，实践为认识提供了可能。第三，实践使认识得以产生和发展。第四，实践是检验认识的真理性的唯一标准。 二：马克思主义认识的本质是什么 认识是主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。 三：运动的基本规律 运动是一个辩证发展过程：从实践到认识；从认识到实践；实践、认识、再实践、再认识，认识运动不断反复和无限发展。 四：感性认识理性认识辩证关系 首先，理性认识依赖于感性认识，理性认识必须以感性认识为基础。坚持理性认识对感性认识的依赖关系，就是坚持了认识论的唯物论。其次，感性认识有待于发展和深化为理论认识。只有使感性认识上升到到理性认识，才能把握事物的本质，满足实践的需要。坚持了这一点，就是坚持了认识论的辩证法。最后，感性认识和理性认识相互渗透，相互包含，二者的区分是相对的，人们不应当也不可能把它们截然分开。 五：认识发展的总过程 从实践到认识，再从认识到实践如此实践、认识、再实践、再认识，循环往复以至无穷，一步步地深化和提高，这就是认识发展的总过程。 六：真理的客观性、绝对性和相对性 客观性：真理具有客观性，凡真理都是客观真理。首先，真理的内容是客观的。其次，检验真理的标准也是客观的 绝对性：即具有绝对性的真理，是指真理的无条件性，无限性。 相对性：即具有相对性的真理，是指真理的有条件性，有限性。 七：实践作为检验认识真理性的标准的确定性和不确定性 实践作为检验认识真理性的标准的确定性即绝对性，是指实践作为检验认识真理性的标准的唯一性，即离开了实践，再也没有另外的标准。 实践作为检验认识真理性的标准的不确定性即相对性，是指实践对认识真理性的检验的条件性。即任何实践都受到一定具体条件的制约，因而都具有一定的局限。 ◆ 第三章一：社会存在与社会意识及其辨证关系 社会存在:也称社会物质生活条件，是社会生活的物质方面，主要是指物质生活资料的生产及生产方式，也包括地理环境和人口因素。 社会意识：社会生活的精神方面，是社会存在的反映。 辨证关系：社会存在和社会意识是辨证统一的。①社会存在决定社会意识，社会存在的性质决定社会意识的性质，社会存在的变化决定社会意识的变化。②社会意识是社会存在的反映，并反作用于社会存在，错误的社会意识会阻碍社会存在的发展，正确的社会意识会促进社会存在的发展。 二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律） ①生产力决定生产关系，生产力的状况决定生产关系的性质，生产力的发展决定生产关系的变革。②第二，生产关系对生产力具有能动的反作用。即当生产关系适合生产力发展时，它对生产力发展起推动作用；当生产关系不适合生产力发展时，它会阻碍生产力的发展。 三：经济基础与上层建筑的矛盾运动规律 经济基础与上层建筑是辨证统一的：①经济基础决定上层建筑。②上层建筑对经济基础具有反作用。当上层建筑适合经济基础状况时，它会促进经济基础的巩固和完善;当上层建筑不适合经济基础状况时，它会阻碍经济基础的发展和变革。 四：人民群众在创造历史过程中的决定性作用 ⑴人民群众从质上说是指一切对社会历史发展起推动作用的人们，从量上说是指社会人口的绝大多数。人民群众的最稳定的主体部分始终是从事物质资料生产的劳动群众及其知识分子。 ⑵在社会历史发展过程中，人民群众起着决定性的作用。 ①人民群众是历史的主体，是历史的创造者。②人民群众的社会物质财富的创造者。③人民群众是社会精神财富的创造者。④人民群众是社会变革的决定力量 ◆ 第四章一：资本的原始积累 ⑴所谓资本原始积累，就是生产者与生产资料相分离，货币资本迅速集中于少数人手中的历史过程。 ⑵资本原始积累主要是通过两个途径进行的：一是用暴力手段剥夺农民的土地；二是用暴力手段掠夺货币财富。 二：商品的二因素和生产商品的劳动二重性 ⑴商品是用来交换的能满足人们某种需要的劳动产品，具有使用价值和价值两个因素，是使用价值和价值的矛盾统一体。 ⑵ 商品是劳动产品，生产商品的劳动可区分为具体劳动和抽象劳动。 三：价值量与价值规律 ⑴ 价值量是由生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量。决定商品价值量的，不是生产商品的个别劳动时间，而只能是社会必要劳动时间。“社会必要劳动时间是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。” ⑵ 商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行，形成价值规律。 ⑶ 价值规律的表现形式是，商品的价格围绕商品的价值自发波动。 ⑷ 价值规律的作用表现在：第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。第二，自发地刺激社会生产力的发展。第三，自发地调节社会收入的分配。 四：私有制基础上商品经济的基本矛盾 ⑴ 在私有制为基础的商品经济中，商品生产者的劳动具有两重性：既是具有社会性质的社会劳动，又是具有私人性质的私人劳动。 ⑵ 私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾。 五：劳动力成为商品的基本条件 劳动力成为商品，要具备两个基本条件：第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；第二，劳动者没有别的商品可以出卖，自由得一无所有，没有任何实现自己的劳动力所必需的物质条件。 六：劳动力商品的特点 劳动力商品在使用价值上有一个很大的特点，就是它的使用价值是价值的源泉，它在消费过程中能够创造新的价值，而且这个新的价值比劳动力本身的价值更大。 七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用 ⑴ 雇佣工人的劳动分为两部分：一部分是必要劳动，用于再生产劳动力的价值；另一部分是剩余劳动，用于无偿地为资本家生产剩余价值。因此，剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值，它是雇佣工人剩余劳动的凝结，体现了资本家与雇佣工人之间剥削与被剥削的关系。 ⑵ 不变资本是以生产资料形态存在的资本。可变资本是用来购买劳动力的那部分资本。 八：生产剩余价值的两种基本方法 资本家提高对工人的剥削程度的方法是多种多样的，最基本的方法有两种，即绝对剩余价值的生产和相对剩余价值的生产。绝对剩余价值是指在必要劳动时间不变的条件下，由于延长劳动日的长度而生产的剩余价值。相对剩余价值是指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。 九：资本积累 ⑴ 把剩余价值转化为资本，或者说，剩余价值的资本化，就是资本积累。 ⑵ 由资本的技术构成决定并反映技术构成变化的资本价值构成，叫做资本的有机构成。通常用c∶v来表示。 ⑶ 所谓相对过剩人口，就是劳动力供给超过了资本对它的需要。 十：资本的循环周转与再生产 ⑴ 资本循环是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。 ⑵ 产业资本在循环过程中要经历三个不同的阶段：第一个阶段是购买阶段，即生产资料与劳动力的购买阶段。在这一阶段，产业资本执行的是货币资本的职能。第二个阶段是生产阶段，即生产资料与劳动力按比例结合在一起从事资本主义生产的阶段。执行的是生产资本的职能。第三个阶段是售卖阶段，即商品资本向货币资本的转化阶段。在此阶段产业资本所执行的是商品资本的职能。 ⑶ 社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题。 ⑷ 在现实的资本主义经济生活中，资本家并不是把剩余价值看作可变资本的产物，而是把它看作全部垫付资本的产物或增加额，剩余价值便取得了利润的形态。 十一：资本主义基本矛盾 生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾。 十二：经济危机 实质：经济危机的实质或本质是旧的生产力产能过剩与供给过剩，有效需求饱和与不足 根源：资本主义经济危机爆发的根本原因是资本主义的基本矛盾 周期性：资本主义经济危机具有周期性，这是由资本主义基本矛盾运动的阶段性决定的。当资本主义基本矛盾达到尖锐化程度时，社会生产结构严重失调，引发了经济危机。 十三：资本主义政治制度及其本质 本质：作为资产阶级政治统治工具的阶级本质 ◆ 第五章一：垄断 ⑴ 所谓垄断，是指少数资本主义大企业，为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格，进行操纵和控制。 ⑵ 垄断的产生有以下原因：第一，当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以获得高额利润。第二，企业规模巨大，形成对竞争的限制，也会产生垄断。第三，激烈的竞争给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协，联合起来，实行垄断。 ⑶垄断条件下竞争的特点 第一，垄断没有消除产生竞争的经济条件。第二，垄断必须通过竞争来维持。第三，社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产都包下来。 二：金融资本与金融寡头 金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。 金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。 三：国家垄断资本主义的形成及作用 ⑴ 国家垄断资本主义是垄断资本主义的新发展，它对资本主义经济的发展产生了积极的作用。首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展。再次，通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高。最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通讯及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了这些国家国民经济的现代化进程。 ⑵ 国家垄断资本主义在本质上是资产阶级国家力量同垄断组织力量结合在一起的垄断资本主义。 四：垄断资本主义的实质 帝国主义的实质，即垄断资本凭借垄断地位，获取高额垄断利润。 五：经济全球化 ⑴ 表现：一是生产的全球化。二是贸易的全球化。三是金融的全球化。四是企业经营的全球化。 ⑵ 后果：经济全球化是一个充满矛盾的进程，它在产生积极效应的同时，也会产生消极的后果。主要表现是：其一，发达国家与发展中国家之间的差距扩大。其二，在经济增长中忽视社会进步，环境恶化与经济全球化有可能同时发生。其三，各国特别是相对落后国家原有的体制、政府领导能力、社会设施、政策体系、价值观念和文化都面临着全球化的冲击，国家内部和国际社会都出现不同程度的治理危机。其四，经济全球化使各国的产业结构调整变成一种全球行为，它既为一国经济竞争力的提高提供了条件，同时也存在着对别国形成依赖的危险。 六：当代资本主义新变化的实质 首先，当代资本主义发生的变化从根本上说是人类社会发展一般规律和资本主义经济规律作用的结果。其次，当代资本主义发生的变化是在资本主义制度基本框架内的变化，并不意味着资本主义生产关系的根本性质发生了变化。 七：资本主义的历史地位———过渡的资本主义 八：资本主义为社会主义所代替的历史必然性 （一）资本主义的内在矛盾决定了资本主义必然被社会主义所代替 （二）从资本主义向社会主义过渡是一个长期的历史过程 ◆ 第六章一：无产阶级革命 ⑴ 性质：无产阶级革命是迄今人类历史上最广泛、最彻底、最深刻的革命，是不同于以往一切革命的最新类型的革命。这是因为：第一，无产阶级革命是彻底消灭一切私有制、代之以生产资料公有制的革命。第二，无产阶级革命是要彻底消灭一切阶级和阶级统治的革命。第三，无产阶级革命是为绝大多数人谋利益的运动。 ⑵ 从理论上说，无产阶级革命有暴力的与和平的两种形式。 二：东欧剧变、苏联解体教训 最深刻的教训是：放弃了社会主义道路，放弃了无产阶级专政，放弃了*的领导地位，放弃了马克思列宁主义，结果使得已经相当严重的经济、政治、社会、**进一步激化，最终酿成了制度剧变、国家解体的历史悲剧。 三：社会主义的本质 社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。 四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性 第一，生产力发展状况的制约。第二，经济基础和上层建筑发展状况的制约。第三，国际环境的严峻挑战。第四，马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的艰苦的过程。 五：社会主义在曲折中前进的客观性 第一，社会主义作为新生事物，其成长不会一帆风顺。社会主义的产生和成长，意味着对资本主义旧社会的否定，这就必然要遭到资本主义势力的拼死反抗。社会主义新社会在开始的时候总是比较弱小的，而且在一个相当长的时期里，社会主义和资本主义的矛盾和斗争是不会停止的，时起时伏，有时甚至相当激烈，资本主义还可能会复辟，这就注定社会主义战胜资本主义的过程是一个曲折的发展过程。第二，社会主义社会的基本矛盾推动社会发展，是作为一个过程而展开的，人们对它的认识也有一个逐渐发展的过程。社会主义的基本矛盾推动社会发展，体现了生产关系一定要适合生产力状况的规律、上层建筑一定要适合经济基础状况的规律。由于受主观和客观条件的限制，对社会主义社会基本矛盾运动的规律和社会主义建设规律的认识有一个过程。只有尊重社会主义发展的客观规律，在实践中自觉地运用规律，及时研究新情况、有效地解决前进中出现的矛盾和问题时，社会主义事业才能够顺利地向前发展。 ◆ 第七章一：共产主义社会的基本特征 （一）物质财富极大丰富，消费资料按需分配 （二）社会关系高度和谐，人们精神境界极大提高 （三）每个人自由而全面的发展，人类从必然王国向自由王国的飞跃 二：确理解“两个必然”和“两个决不会”的关系 马克思恩格斯在《***宣言》中提出：“资产阶级的灭亡和无产阶级的胜利是同样不可避免的。”这就是我们常说的资本主义必然灭亡和社会主义必然胜利的“两个必然”（或“两个不可避免”）。后来，马克思在《〈政治经济学批判〉序言》中又提出了“两个决不会”，即：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。” “两个必然”和“两个决不会”有着内在的联系，应该结合起来加以理解。 “两个必然”和“两个决不会”是对资本主义灭亡和共产主义胜利必然性以及这种必然性实现的时间和条件的全面论述。前者讲的是资本主义灭亡和共产主义胜利的客观必然性，是根本的方面；而后者讲的是这种必然性实现的时间和条件，它告诫我们，“两个必然”的实现需要相应的客观条件，而在这个条件具备之前决不会成为现实。 全面准确地学习和把握“两个必然”和“两个决不会”，既有利于人们坚定资本主义必然灭亡、共产主义必然胜利的信心，同时也有利于人们坚持科学态度，充分尊重客观规律，在当前艰苦的实践中坚定地为共产主义的实现而奋斗。","categories":[{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"http://example.com/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"马克思主义原理期末考试重点","slug":"马克思主义原理期末考试重点","date":"2021-01-08T12:48:18.000Z","updated":"2021-01-08T12:57:34.642Z","comments":true,"path":"2021/01/08/马克思主义原理期末考试重点/","link":"","permalink":"http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/","excerpt":"","text":"《马克思主义基本原理概论》考试重点 1、三次起义运动(P6) 1831年、1834年法国里昂工人起义;1836年英国宪章运动;1844年德国西里西亚纺织工人起义。 2、马克思主义批判地继承、吸收(扬弃)德国古典哲学(主要代表人物:黑格尔、费尔巴哈)、英国古典政治经济学(主要代表人物:威廉·配第、亚当·斯密、大卫·李嘉图)和法国、英国空想社会主义(主要代表人物:昂利·圣西门、沙尔·傅立叶、罗伯特·欧文)。(P8~P9) 3、两大理论成果(P13) 毛泽东思想和中国特色社会主义理论体系(包括邓小平理论、“三个代表”重要思想、科学发展观) 4、哲学的基本问题(P29) ①意识和物质、思维和存在，究竟谁是世界的本原，即物质和精神何者第一性、何者第二性的问题;②思维能否认识或正确认识存在的问题。 5、哲学的分类(P29) ①根据哲学基本问题第一方面的回答划分为唯物主义和唯心主义。唯物主义把世界的本原归结为物质，主张物质第一性，意识第二性，意识是物质的产物;唯心主义把世界的本原归结为精神，主张意识第一性，物质第二性，物质是意识的产物。②根据哲学基本问题第二方面的回答划分为可知论和不可知论。可知论认为世界是可以被认识的;不可知论认为世界是不能被人所认识或不能被完全认识的，否定思维和存在的统一。 6、旧唯物主义哲学(P30) 包括古代朴素唯物主义和形而上学唯物主义。 7、意识的发展阶段(P31) 一切物质所具有的反应特性→低等生物的刺激感应性→高等动物的感觉和心理→人类的意识。 8、马克思指出“观念的东西不外是移入人的头脑并在人的头脑中改造过的物质的东西而已。”这表明，物质决定意识，意识依赖于物质并反作用于物质。(P31) 9、时间和空间(P33) 时间和空间是物质运动的存在形式，物质运动与时间和空间的不可分割证明了时间和空间的客观性。时间是指物质运动的持续性、顺序性，特点是一维性，即一去不复返;空间是指物质运动的广延性、伸张性，特点是三维性。 10、马克思主义以前的旧唯物主义都是“半截子”唯物主义。因为它们在自然观上是唯物主义，一到社会历史领域，就陷入了唯心主义。(P33) 11、实践的基本特征及构成实践活动的要素(P35) 基本特征:物质性、自觉能动性、社会历史性。要素:实践主体(人)、实践对象(客体)、实践手段(工具等)。 12、实践的基本形式(P36) 物质生产实践(人类最基本的实践活动)、社会政治实践、科学文化实践。 13、为什么说实践是人的存在方式？(P37) 人类的产生、生存和活动，是以实践为基本方式和标志的。①实践是人所独有的活动。②实践集中表现了人的本质的社会性。③实践对物质世界的改造是对象性的活动。 14、社会生活的实践性主要体现在哪几方面？(P39) ①实践是社会关系形成的基础。②实践形成了社会生活的基本领域。③实践构成了社会发展的动力。 15、意识的能动作用及主要表现的方面(P41) 意识能动作用是人的意识所特有的积极反映世界与改造世界的能力和活动。主要表现在:①意识活动具有目的性和计划性。②意识活动具有创造性。③意识具有指导实践改造客观世界的作用。④意识具有指导、控制人的行为和生理活动的作用。 16、主观能动性与客观规律性的辩证统一(P42) ①尊重客观规律是发挥主观能动性的前提。②在尊重客观规律的基础上充分发挥主观能动性。人们通过自觉活动能够认识规律和利用规律。自觉能动性是人与动物的重要区别。③尊重事物发展的规律与发挥人的主观能动性是辩证统一的。④实践是客观规律性与主观能动性统一的基础。 17、如何正确发挥主观能动作用？(P43) ①从实际出发，努力认识和把握事物的发展规律。②实践是发挥人的主观能动作用的基本途径。③主观能动作用的发挥，还依赖于一定的物质条件和物质手段。 18、联系的特点(P44) ①客观性。事物的联系是事物本身所固有的，不是主观臆想的。世界上没有孤立存在的事物，每一种事物都是和其他事物联系而存在的，这是一切事物的客观本性。②普遍性。a.任何事物内部的不同部分和要素都是相互联系的，也就是说，任何事物都具有内在的结构。b.任何事物都不能孤立存在，都同其他事物处于一定的相互联系之中。c.整个世界是相互联系的统一整体。③多样性。直接联系与间接联系，内部联系与外部联系，本质联系与非本质联系，必然联系与偶然联系等。 19、新生事物不可战胜的原因(P46) ①就新生事物与环境的关系而言，新事物之所以新，是因为有新的结构和功能，它适应已经变化了的环境和条件;旧事物之所以旧，是因为它的各种要素和功能已不适应环境和客观条件的变化，走向灭亡就成为不可避免的。②就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、仍然适合新的条件的因素，并添加了旧事物所不能容纳的新内容。 20、对立统一规律是唯物辩证法体系的实质和核心的原因(P47) ①对立统一规律揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题；②对立统一规律是贯穿质量互变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解这些规律和范畴“钥匙”；③对立统一规律提供了人们认识世界和改造世界的根本方法——矛盾分析法。 21、矛盾的同一性与斗争性的辩证统一关系(P48) 矛盾同一性与斗争性之间是对立统一的辩证关系。①矛盾的同一性和斗争性之间是相互联结、相辅相成、相互制约的。一方面，同一性依赖于斗争性，同一是包含着差别、对立的同一，没有斗争性就没有同一性；另一方面，斗争性寓于同一性之中，斗争是是同一中的斗争，没有同一性，斗争性也不能成立。②同一性与斗争性之间是相对与绝对的关系。斗争性是绝对的、无条件的，同一性是相对的、有条件的，斗争性最终导致同一性的分解，有条件的同一性和无条件的斗争性相结合，推动着事物发展。 22、矛盾的普遍性和特殊性及其相互关系(P49~P50) 矛盾的普遍性: 矛盾无处不在，无时不有。矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有特点；三是构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质、地位和作用。 矛盾的普遍性和特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。矛盾的共性是无条件的、绝对的，矛盾的个性是有条件的、相对的。任何现实存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键，不懂得它，就不能真正掌握唯物辩证法。矛盾的共性和个性相统一的关系，既是客观事物固有的辩证法，也是科学的认识方法。人的认识的一般规律就是由认识个别上升到认识一般，再由一般到个别的辩证发展过程。 23、量变和质变的辩证关系(P51) ①量变是质变的必要准备。任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。②质变是量变的必然结果。单纯的量变不会永远持续下去的，量变达到一定程度必然引起质变。③量变和质变是相互渗透的。一方面，在总的两边过程中有阶段性和局部性的部分质变。另一方面，在质变的过程中也有旧质在量上的收缩和新质在量上的扩张。 量变和质变是相互依存、相互贯通的，量变引起质变，在新质的基础上，事物又开始新的量变，如此交替循环，形成事物质量互变的规律性。质量互变规律体现了事物发展的渐进性和飞跃性的统一。 24、辩证否定观的主要内容(P52) ①否定是事物的自我否定，是事物内部矛盾运动的结果。②否定是事物发展的环节。它是旧事物向新事物的转变，是从旧质到新质的飞跃。只有经过否定，旧事物才能向新事物转变。③否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物通过否定环节联系起来的。④辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。 25、必然性与偶然性的关系(P54) ①必然性和偶然性是对立的。必然性是事物发展过程中确定不移的趋势，是由事物的根本矛盾决定的，体现事物发展的本质联系和发展前途;偶然性是事物发展过程中不确定的趋势，是由事物的非根本矛盾和外部条件引起的，对事物的发展起加速或延缓作用。②必然性和偶然性又是统一的。a.必然性总是通过大量的偶然现象表现出来，由此为自己开辟道路，没有脱离偶然性的纯粹必然性。b.偶然性是必然性的表现形式和必要补充，偶然性背后隐藏着必然性并受到其制约，没有脱离必然性的纯粹偶然性。c.必然性和偶然性在一定条件下可以相互转化。 26、主体和客体相互作用的过程(P64) ①确立实践目的和实践方案。②实践主体按照实践目的和实践方案实际地作用于实践客体，通过一定的实践手段把实践方案变成实践的实践活动。③通过反馈和调节，使实践目的、手段和结果按一定方向运行。 27、实践在认识中的决定作用(P65) 实践是认识的基础，对实践具有决定作用。①实践产生了认识的需要。②实践为认识提供了可能。③实践使认识得以产生和发展。④实践是检验认识的真理性的唯一标准。 28、两条根本对立的认识路线(P67) ①坚持从物到感觉和思想的唯物主义路线。②坚持从思想和感觉到物的唯心主义路线。 29、主观唯心主义和客观唯心主义(P67) 主观唯心主义认为人的认识是主观自生的，是“内心反省”的结果，是心灵的自由创造物。客观唯心主义认为人的认识是上帝的启示或绝对精神的产物。 30、辩证唯物主义认识论和旧唯物主义认识论(P67、P68) ①旧唯物主义的认识论即形而上学唯物主义认识论，把人的认识看成是消极地、被动地反映和接受外界对象。有两个严重缺陷:a.离开实践考察认识问题，因而不了解实践对认识的决定作用。b.不了解认识的辩证性质，离开辩证法来考察认识问题，不能把认识看作是一个不断发展的过程，而认为认识是一次性完成的。②辩证唯物主义认识论认为，认识是主体对客体的能动反映。这种能动反映具有摹写性和创造性。 31、感性认识和理性认识及其辩证关系(P69、P70) 感性认识：人们在实践基础上，由感觉器官直接感受到的关于事物的现象、事物的外部联系、事物各方面的认识，包括感觉、知觉和表象三种形式。理性认识：指人们借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物的本质、全体、内部联系和事物自身规律性的认识。理性认识包括概念、判断、推理三种形式。辩证关系:①理性认识依赖于感性认识。理性认识必须以感性认识为基础，坚持理性认识对感性认识的依赖关系就是坚持了认识论的唯物论。②感性认识有待于发展和深化为理性认识。只有使感性认识上升到理性认识才能把握住事物的本质，满足实践的需要，坚持这一点就是坚持了认识论的辩证法。③感性认识和理性认识相互渗透、相互包含。感性认识和理性认识是辩证统一的，统一的基础是实践。 32、从感性认识过渡到理性认识所具备的条件(P70) ①勇于实践，深入调查，获取十分丰富和合乎实际的感性材料，这是正确实现由感性认识上升到理性认识的基础。②必须经过理性思考的作用，将丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的制作加工，才能将感性认识上升到理性认识。也就是说，必须运用辩证思维的科学方法，才能获得真正的认识。 33、造成认识过程反复性和无限性的原因(P72) ①人们对事物的认识，由于主客观条件的限制，往往不是一次完成的。从主观方面说，人们总是受到自己认识能力和实践活动范围的限制。从客观方面说，会受到科学技术条件的限制，以及客观过程的发展和表现程度的限制。②从人们具体的认识过程看，当某一思想、理论、计划、方案等，经过多次反复，在实践中达到预想结果，就算完成了。 34、实用主义所鼓吹的“有用就是真理”这句话是错误的。这是主观真理论的一个典型，实用主义者把“有用”和“真理”完全等同，从根本上否认了客观真理的存在。(P74) 35、真理的绝对性和相对性及其关系(P75) 真理的绝对性即具有绝对性的真理，是指真理的无条件性、无限性。真理的相对性即具有相对性的真理，是指真理的有条件性、有限性。任何真理都只能是主管对客观事物近似正确即相对正确的反映。关系:真理的绝对性和相对性是辩证统一的。①具有绝对性的真理和具有相对性的真理是相互渗透和相互包含的。②具有相对性的真理向具有绝对性的真理转化。 36、价值的特性(P81) ①客观性。价值关系的各个环节都是客观的。a.人的需要具有客观性。b.用来满足人的需要的对象也具有客观性。c.满足人的需要的过程和结果也具有客观性。②主体性。③社会历史性。④多维性。 37、价值评价及其特点(P82、P83) 价值评价是一种关于价值现象的认识活动。特点:①评价是以主客体的价值关系为认识对象的。②评价结果与评价主体有直接关系，是依主体的特点而转移的。③评价结果的正确与否依赖于相关的知识性认识。 38、党的十八大“三个倡导”(P85) 倡导富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善，积极培育和践行社会主义核心价值观。 39、两种根本对立的历史观(P95、P98) ①唯物史观。认为:社会历史发展具有自身固有的客观规律；社会存在决定社会意识，社会意识又反作用于社会存在；生产力和生产关系之间的矛盾，经济基础和上层建筑之间的矛盾是推动社会发展的基本矛盾。②唯心史观。认为:社会意识决定社会存在，人们的思想动机是社会发展的根本原因，否认社会发展的客观规律。 40、社会存在与社会意识及其辩证关系(P96) 社会存在:也称社会物质生活条件，是社会生活的物质方面，它包括地理环境和人口因素和物质资料的生产方式，其中物质资料的生产方式是社会存在的主要方面。社会意识:社会意识是社会生活的精神方面，是社会存在的反映。辩证关系:社会存在决定社会意识，社会意识是对社会存在的反映。社会存在和社会意识是辩证统一的。社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。①社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。②社会意识是人们社会物质交往的产物。③随着社会存在的发展，社会意识也相应地或迟或早地发生变化和发展。 41、社会意识的分类(P96) 社会意识具有复杂的结构。按照社会意识主体的不同，可以区分为个人意识和群体意识；按照社会意识反映层次的高低，可以区分为社会心理和社会意识形式；按照同经济基础关系的不同，可以区分为作为上层建筑的意识形式（社会意识形态）和非上层建筑的意识形式。上层建筑的意识形式（或者说社会意识形态）包括政治法律思想、道德、艺术、宗教、哲学和大部分的社会科学（例如：经济学、政治学、法学、社会学等等）；它们从各自不同方面发挥独特的作用。而非上层建筑的意识形式主要是指自然科学，也包括一部分社会科学和思维科学（例如：语言学、修辞学、逻辑学等等）。在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级的意识形态，因而具有鲜明的阶级属性。 42、社会意识相对独立性的主要表现(P99) ①社会意识与社会存在发展的不完全同步性和不平衡性。②社会意识的发展具有历史继承性。③社会意识各种内部形式之间的相互影响、相互作用。④社会意识对社会存在的能动的反作用，这是社会意识相对独立性的突出表现。 43、生产力的基本要素(P101) ①劳动资料(也称劳动手段)。②劳动对象。③劳动者。 44、生产力与生产关系的相互关系(P104) 生产力决定生产关系，生产关系对生产力有反作用。①生产力决定生产关系:a.生产力状况决定生产关系的性质，有什么样的生产力，就会产生什么样的生产关系；b.生产力的发展决定生产关系的发展和变革。②生产关系对生产力具有能动的反作用:a.当生产关系与生产力的发展要求相适合时，它会有力地推动生产力的发展；b.当生产关系与生产力的发展要求不相适合时，它会阻碍甚至破坏生产力的发展。 45、经济基础和上层建筑的矛盾运动(P108) 经济基础与上层建筑是辩证统一的。①经济基础决定上层建筑。经济基础是上层建筑赖以产生、存在和发展的物质基础，上层建筑是经济基础得以确立统治地位并巩固和发展不可缺少的政治、思想条件。任何上层建筑的产生、存在和发展，都能直接或间接地从社会的经济结构中得到说明。经济基础的性质决定上层建筑的性质，有什么样的经济基础就有什么样的上层建筑。经济基础的变更必然引起上层建筑的变革，并决定着其变革的方向。②上层建筑对经济基础具有反作用。集中表现在:为自己的经济基础的形成和巩固服务，确立或维护其在社会中的统治地位。上层建筑这种反作用的后果可能有两种:当它为适合生产力发展要求的经济基础服务时，就成为推动社会发展的进步力量;反之，就会成为阻碍社会发展的消极力量。 46、社会形态的分类(P110) ①经济形态(基础)。②政治形态。③意识形态。 47、社会历史发展的动力(P113) ①根本动力:社会基本矛盾(生产力和生产关系、经济基础和上层建筑的矛盾)。②直接动力:阶级斗争。③重要动力:革命、改革、科学技术。 48、群众观点与群众路线(P133) 群众观点:人民群众至上。坚信人民群众自己解放自己;全心全意为人民服务;一切向人民群众负责;虚心向群众学习。 群众路线:一切为了群众，一切依靠群众，从群众中来，到群众中去。 49、试用物质和意识的辩证关系原理，说明我国的现代化建设必须走自己的路，建设中国特色的社会主义。 答:①物质和意识的辩证关系是：物质第一性，意识第二性，先有物质，后有意识。物质决定意识，意识是物质的反应，意识对物质具有能动的反作用，正确的意识对事物的发展起足进作用，错误的意识对事物的发展起阻碍作用。这一原理要求我们在实际工作要坚持一切从实际出发，实事求是。②我国的社会主义现代化建设，必须从中国的客观实际出发，从中国的国情，国力和基本特点出发。我国当前乃至今后相当长一段时期处于社会主义初级阶段是我国的基本国情，是我国当前的最大实际，是我们党制定路线，方针和政策的客观依据。我国的现代化建设必须从这一基本国情出发，把马克思主义的基本原理同中国的实际紧密结合起来。建设中国特色的这会注义。③在现代化建设过程中，必须会遇到需多新情况、新问题。这就要求我们从实际出发，尊重客观规律，不断开创现代化建设的新局面。必须反对从主观愿望和书本教条出发，反对照搬照抄他人的检验和模式。 50、试用矛盾的普遍性和特殊性的辩证关系原理，说明坚持中国特色社会主义道路的重要性。 答:①矛盾的普遍性是指矛盾存在于一切事物的发展过程中，存在于一切事物发展过程的始终。矛盾的特殊性是指具体事物的矛盾及每一矛盾的各个方面都有其特点。②矛盾的普遍性和特殊性是辩证的统一。第一，矛盾的普遍性和特殊性是相互联结的。普遍性存在于特殊性之中，特殊性中包含着普遍性。第二，矛盾的普遍性和特殊性在一定条件下可能相互转化。③矛盾的普遍性和特殊性辩证统一的原理，是把马克思主义普遍真理与中国的具体实际相结合，走建设有中国特色社会主义道路的重要理论依据。④我们既要坚持社会主义的根本制度和基本原则，又必须注意中国的特点，从中国正处于并将长期处于社会主义初级阶段这一实际出发，走自己的路。只有这样，才能把建设有中国特色社会主义事业推向前进。 51、用认识和实践的关系原理，说明科学发展观对中国特色社会主义建设的重要意义。 答:①认识是实践的基础，实践对认识起决定作用。实践是认识的来源、动力、检验标准和目的。理论一经形成对实践有能动作用，主要表现在:正确的认识和理论可以指导实践指向适当的对象，采取正确的方法，从而取得成功。错误的认识和理论，会引导实践指向不适当的对象，采取错误的方法，从而导致失败。②科学发展观是马克思主义关于发展世界观和方法论的集中体现，是我国经济社会发展的重要指导方针。它进一步正确地回答了实现什么样的发展、怎样发展的问题，体现了我们党对执政规律、社会主义建设规律和人类社会发展规律认识的进一步深化。③科学发展观能够指导我国经济社会实现又快又好的发展，解决发展中的不平衡、不协调问题，为我国经济社会发展指明了正确的方向。④认真学习全面领会科学发展观，才能真正坚持贯彻科学发展观。 52、用真理的绝对性和相对性的辩证关系原理，说明对待马克思主义的正确态度。 答:①真理的绝对性和相对性的关系:首先，两者相互对立、相互区别;绝对真理是指真理的内容是客观的，人类的认识按其本性是能够正确反映无限发展着的物质世界。相对真理是指真理只是对客观事物一定范围的正确反映，是对事物一定程度、一定层次的近似正确的反映。其次，两者相互依存、相互渗透。相对真理中包含着绝对真理的成分，绝对真理是由无数相对真理构成的。再次，人类的认识永远处在从相对真理向绝对真理的转化过程中。②马克思主义作为科学真理，是绝对性和相对性的统一。马克思主义是关于自然、社会和思维发展的普遍规律的科学，它的基本原理经过实践的反复检验、证明，对各国的革命和建设具有普遍的指导意义，这是无条件的、绝对的。马克思主义没有穷尽一切真理，必将随着科技的进步和实践的发展而前进，这又是其相对性。对待马克思主义的科学态度关键在于正确处理好坚持和发展马克思主义的关系，即既要坚持，又要发展，在坚持中发展，在发展中坚持。③割裂真理的绝对性和相对性的关系会导致真理问题上的绝对主义或相对主义。在实际工作中要反对片面夸大马克思主义的绝对性、否认其相对性的教条主义、本本主义的错误，又要反对片面夸大其相对性、否认其绝对性的所谓马克思主义“过时论”、“无用论”的错误。 53、试述社会意识相对独立的原理并用以说明加强社会主义精神文明建设的重要性。 答:(1)社会存在决定社会意识，社会意识是社会存在的反映，因此，它没有绝对独立性，只具有相对独立性。社会意识相对独立性的表现：①社会意识对社会存在有巨大的能动的反作用：先进的社会意识对社会存在的发展起着促进和推动的作用，落后反动的社会意识阻碍社会存在的发展。②社会意识和社会存在变化和发展的不完全同步性：社会意识的变化有时落后于社会存在的变化；先进的社会意识在不同程度上预见社会存在变化发展的趋势和未来。③社会意识同社会经济发展水平的不平衡性：经济上先进的国家，意识形态的发展却可能落后；经济上落后的国家，意识形态发展可能先进。④社会意识各种形式之间能互相作用，其中政治思想居于主导地位，对其他意识形式有巨大影响。⑤社会意识具有历史继承性，后人总要继承前人的思想材料，并加以改造和发展。(2)重要性：①社会主义精神文明建设，是实现社会主义现代化的战略任务，它能推动社会主义社会存在的发展。它为社会主义生产方式、经济制度的发展提供了精神动力和智力支持及思想保证，也是改革开放和实现社会主义现代化的根本保证。②社会主义精神文明建设又是抵制封建主义、资产阶级腐朽思想的重要武器，是反对资产阶级自由化的重要武器。③社会主义精神文明建设不仅关系到我国社会主义方向和道路，而且是关系到我国整个社会生活的精神面貌的大问题。因此，搞好它是极为重要的。","categories":[{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"http://example.com/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"数据科学概论考试知识点","slug":"数据科学概论考试知识点","date":"2021-01-04T07:55:11.000Z","updated":"2021-01-08T08:34:25.077Z","comments":true,"path":"2021/01/04/数据科学概论考试知识点/","link":"","permalink":"http://example.com/2021/01/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA%E8%80%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"第一章数据科学定义 定义：数据科学是关于对与数据进行分析、抽取信息和知识的过程提供指导合作支持的基本原则方法科学 ​ 数据科学的核心任务是从数据中从获取信息、发现知识。数据科学包含一组概念、原则、过程、技能/方法以及工具，为其核心任务为服务 ​ 简而言之，数据科学是以各类数据作为研究对象的，建立在在应对分析挑战的众多关键技术基础上的通识意义上的科学 大数据的三个主要特点： 数据量大、数据类型多、数据生成快、价值密度低 数据科学的基本原则： ​ 1、数据分析可以划分成一系列的明确阶段 ​ 2、描述性与预测分析 ​ 3、实体的相似度 ​ 4、模型泛化能力 ​ 5、分析结果的评估与特定的应用场景有关 ​ 6、相关性不同于因果关系 ​ 7、通过并行处理提高数据处理（分析）速度 数据处理的流程： 1、数据采集2、数据表示和储存3、数据清洗4、数据集成5、数据分析6、数据可视化7、基于数据的决策 ​ 第二章 OLTP与数据服务数据服务是指面向操作型业务，提供数据的增加、删除、修改以及简单的查询功能（增删改查） 联机事务处理（OLTP）指的是用户的业务请求转化成数据库的操作，传送到后台数据库管理系统，数据库管理系统在很短的时间内，把用户的相关数据操作当作一个事务来处理，对用户的请求进行响应 联机事务处理的两个特点：一个是用户请求作为一个事务进行处理，另一个是响应时间短 ACID事务特性：A：原子性，指的是事务的所有操作，要么全部执行，要么都没有执行 ​ C：一致性，值的是事务把数据库状态，从一个有效状态转化为另一个新的有效状态 ​ I：隔离性，是指在一个并发的事务处理系统中和其他事务是相互隔离的，事务的各个操作步骤可以交替执行，但必须和保 证某个未提交的事务和其他事务时相互隔离的，目的是保证未提交的数据，别的事物不能看到 ​ D：指的时提交的数据的必须保存起来，当系统失败和重启，数据能够恢复到最近的正确后状态 数据安全性保证的主要技术手段： 用户认证和授权、审计和数据加密等 关系模型的完整性包括实体完整性、参照完整性、用户自定义完整性 NoSQL数据​ Not only SQL ,是某一类数据库的统称 ​ 主要特点：采用和关系模型不同的数据模型，采取了一些新的设计原则，目的是利用大型计算机集群实现大数据的有效处 理 ​ 新原则：1、采用横向扩展方式应对大数据挑战；2、放弃严格的ACID一致性约束，允许数据暂时出现不一致，接受最终一致性； ​ 3、对数据的储存进行容错处理，一般对数据块进行适当的备份 CAP理论：在大型分布式数据库中，一致性、系统可用性、网络分区容忍性这三个目标中，只可以获得其中两个，追求其中两个将损害另外一个的目标 ​ NoSQL的四种数据库类型| 四种类型 | 代表 || ——————- | ——————- || Key-Value数据库 | Dynamo数据库、Redis || Column Family数据库 | Big Table、HBase、 || Document数据库 | MongoDB || Graph数据库 | Neo4J | NewSQL没怎讲，不搞了 分布式数据库 定义：所谓分布式数据库，它运行在多台计算机上，这些计算机通过网络互联。每台计算机可以放在一个地方，每台计算机安装独立的RDBMS系统，拥有数据的完整拷贝，或者部分拷贝。这些计算机系统共同组成一个完整的、逻辑上集中、但是物理上分布的大型数据库。 第三章 OLAP 与结构化数据联机分析处理（OLAP）：是在以星型模型（或雪花模型）建立的数据仓库上进行多维分析 结构化数据分析： 是一个更为广泛的概念，它运行在结构化数据上，分析可以表达成一个SQL聚集查询 数据仓库与星型模型，BILL Inmon认为数据仓库是面向主题的、集成的、非易失的和时变的数据集合，用以支持管理决策 数据仓库一般不对应到某个厂商的具体产品，而是指一种面向对象的数据分析储存方案 联机分析处理的主要操作：下钻、上卷、切片、切块、旋转等 ​ 下钻和上卷是改变维的层次；切片和切块是选定一部风维度值，然后查看度量数据剩余维度上的分布情况；旋转操作时改变维的方向 三种类型的OLAP系统：多维OLAP（MOLAP)、关系OLAP(ROLAP)、混合OLAP(HOLAP)； ​ MOLAP优点性能高，缺点是占用大量的空间保存汇总数据 ​ ROLAP优点利用关系数据库保存原始明细数据，占用空间有限，但性能有限 ​ HOLAP是两者的集合，HOLAP的查询效率比ROLAP高，比MOLAP低 高性能OALP系统的三种实现技术 ​ 列储存技术​ ​ 位图索引技术 ​ 内存数据库技术 第四章 数据清洗与数据集成ETL (Extract、Tansform and Load) : 数据抽取，转换和装载 数据集成是从多个数据源建立统一的数据视图的一种技术 数据清洗是一种消除数据里面错误、去掉重复数据的技术 数据清洗​ 数据清洗的意义：剔除数据中的错误，以便获得高质量的数据，基于高质量的数据分析才能获得可信的分析结果，进而做出正确的决策 ​ 数据异常的不同类型： ​ 1、语法类异常：词法错误、值域格式错误、不规则的取值 ​ 2、语意类异常：违反完整性约束规则、数据中出现矛盾、数据重复 ​ 3、覆盖类异常：值缺失、元组缺失 数据质量：​ 数据质量的评价标准：完整的评价标准是子评价标准的综合加权评分 ​ 1、正确性：完整性、一致性（可继续划分为模式符合性和统一性）、密度 ​ 2、唯一性 ​ 数据清洗的任务和过程 ​ 任务：剔除数据里的异常，使得数据集成为现实世界的准确、没有重复的表示过程 ​ 主要操作：1、对元组及其各个属性的格式进行调整。2、完整性约束条件的检查和实施。3、从已知值中导出缺失值。4、检测离群值 ​ 过程： ​ 数据审计—&gt;选择合适的方法—&gt;执行方法—&gt;后序处理和控制 ​ 数据清洗的具体方法： ​ 1、数据解析数据解析的目的是检测语法错误 ​ 2、数据转换数据转换的目的是把数据从一个格式映射到另外一种格式，以适应程序的需要。在实例层面一般采取标准化和规范化方法，提出数据的不规则性 ​ 3、实施完整性约束条件 ​ 4、重复数据消除 ​ 5、一些统计方法 数据集成：​ 数据集成是指把数据从多个数据源整合在一起，提供一个观察这些数据统一视图的过程、 ​ 数据集成分为物理式数据集成、虚拟式数据集成两类 ​ 数据集成需要解决的问题——异构性：管理系统的异构性、通信协议异构性、数据模式异构性、数据类型异构性、 ​ 数据集成的三种模式：建立数据仓库、联邦数据库模式、中介者模式 第五章 数据的深度分析（数据挖掘、机器学习）广义上而言，机器学习是一种能够赋予机器学习的能力，让它完成直接编程无法完成的功能的方法。 机器学习的目的是：是预测（包括分类和回归） 特征选择算法（书上出现的）： 互信息、文档频率、信息增益、卡方检验 机器学习的基本过程是利用训练数据（包含输入数据和预期输出的分类或者数值）训练一个模型，利用这个模型，就可以对新的实例数据进行分类和计算一个预测 机器学习的方法可以分为：监督学习、无监督学习、半监督学习 ​ 监督学习：是机器学习的一种类别，训练数据由输入特征（Feature）和预期的输出构成，输出可以是一个连续的值，或者是一个分类的标签。 ​ 无监督学习：与监督学习的区别就是没有训练样本，直接对数据建模。 ​ 半监督学习：是监督学习和无监督学习的结合，它研究利用少量的标注样本和大量未标注的样本进行训练和预测问题。半监督学习分为半监督分类，半监督回 归，半监督聚类，半监督降维算法 主流机器学习算法决策树、聚类算法K-means、SVM、关联规则分析Apriori算法、EM算法、协同过滤推荐算法、朴素贝叶斯算法 第六章 流数据处理流数据处理应用​ 网络监控、电信数据管理、工业制造、传感器网络、电子商务、量化交易等 流式处理和批处理的区别​ 流式处理时针对批处理来讲的 流式处理（Stream Processing） 是针对 批处理（Batch Processing）来讲的，即它们是两种截然不同的数据处理模式，具有不同的特点，适用于不同的应用场合。不能简单地认为其中一种数据处理模式优于另一种数据处理模式。 对于批处理来讲，首先数据被不断地采集，保存到数据库中，然后进行分析处理（包括SQL查询）。批处理适用于对大量数据（High Volume）进行处理的场合。人们需要等到整个分析处理任务完成，才能获得最终结果。由于需要处理的数据集大小以及计算机系统的计算能力的差异，整个过程有时需要耗费相当长的时间，即获得最终分析处理结果的延迟较大。批处理是最通用的数据处理模式。传统的关系数据库系统、Hadoop以及Spark大数据处理平台等，都采用了这样的数据处理模式，或者以该处理模式为主。由于需要完整地保存整个数据集，并且在上面进行分析处理，比起流式数据处理系统，人们需要投入更多的硬件资源。 批处理系统可以存取已经入库的所有数据，人们可以对数据进行复杂深入的分析，分析处理的延迟以分钟或者小时计。批处理作业（Job）一旦提交，则一直运行，直到获得最终结果或者失败退出，无需用户人工干预。这些作业在整个数据集或者某个子集上执行一系列的分析，产生分析结果。在性能方面，批处理系统主要考虑系统的吞吐能力，而不是单个分析处理任务的处理延迟（Latency）。 在流式数据处理模式里，数据持续到达，系统及时处理新到达的数据，并不断产生输出。处理过的数据一般丢弃掉，当然也可以保存起来。流式数据处理模式强调数据处理的速度（Velocity）。部分原因是数据产生的速度很快，需要及时进行处理。由于流式数据处理系统能够对新到达的数据进行及时的处理，所以它能够给决策者提供最新的事物发展变化的趋势，以便对突发事件进行及时响应，调整应对措施。 查询处理的基础算法​ 随机采样、梗概技术、直方图、小波分析、布隆过滤器、计数最小梗概 流数据处理系统 Storm 第七章 文本分析文本分析的意义：深入了解非结构化数据，帮助企业或个人对产品和服务做出改进 文本分析的过程1、采集文本数据。2、运用文本分析方法分析文本。3、对分析结果进行可视化以及解释和评估分析结果等。 文本分析的任务和方法句子切分、分词、词性标注、语法分析 ​ 切分和分词 ，对于文本进行分析需要将文本切分为一个一个的句子，完成该功能的软件是语句切分器 ​ 词性标注 ​ 语法树 1、概率型上下文无关语法分析激素。2、位移归约语法分析技术。3、基于神经网络的语法分析技术 文本聚类的几种方法1、基于距离的聚类算法。2、基于单词或者短语的聚类算法。3、基于话题建模技术的概率聚类算法。 第十章 数据可视化、可视分析与探索十数据分析什么是什么可视化可视化是一种数据的可视表现形式以及交互技术的总称。它通过图形化的方式把数据表现出来，方便用户进行观察和理解，并且帮助用户对数据进行探索，发现数据里隐藏的模式，获得对大量数据的理解和洞察力 可视化分析技术1、数据：数据是所有可视化分析的基础 2、模型：可以是某个方面的属性的统计值，也可以是复杂的数据挖掘和机器学习算法 3、可视化：结果一般依据模型的分析结果进行绘制 4、探索回路：描述的是分析者如何和可视分析系统进行交互，目的是生成新的可视化结果或者调整模型；它涉及两个方面，即动作和发现 5、验证回路 ：（1）假设 （2）理解和洞察力，洞察里定义为分析者对于上述的法相如何进行解释。在解释过程中，需要用到领域的先验知识 6、产生知识回路 第十一章 云计算平台云计算的概念与特点​ 概念：云计算也称为按需计算，它是对可配置的共享的计算资源池提供安迅存取的一种计算模型，这里的资源包括计算、储存、网络等硬件资源 ​ 特点：虚拟化、弹性、成本低廉、高度容错性和高度可靠性 ​ 云计算与并行计算、分布式计算、集群计算、网格计算的区别于联系： ​ 并行计算是相对串行计算而言，可以分为时间上和空间上的并行。 ​ 分布式计算通过把整个计算任务分解成一些列的小任务，分布到各个结点上计算分别执行，最后汇总结果。获得最终结果。 ​ 集群计算通过高速网络把一组本来松散联系的结点（计算机）通过软件紧密联系在一起，协作完成计算工作 ​ 网格计算在本章中算作集群计算的一种 ​ 云计算是上述技术的发展新阶段，器底层的核心技术是虚拟化，即把计算、储存、网络等硬件都进行虚拟化。 ​ 云计算强调子要你的利用率 虚拟化技术与数据中心虚拟化技术包括服务器虚拟化，储存虚拟化和网络虚拟化等重要内容 服务器虚拟化​ 指把一台物理服务器虚拟成若干独立的逻辑服务器，各个逻辑夫妻拥有自己的CPU,内存以及I/O设备。 ​ 储存虚拟化分为两种：寄居虚拟化以及裸机虚拟化（通俗而言，前者就是，在一个已经安装了操作系统的机器上安装VMM，后者则是直接在未安装操作系统的 机器上安装VMM，后者为轻量级） ​ 储存虚拟化​ 目的是把分散的、异构的储存设备，想办法映射成一个统一的、连续编址的逻辑储存空间，也叫虚拟存储池 ​ 三种实现方式：基于主机的存储虚拟化，基于储存设备的虚拟化、基于网络的储存虚拟化 网络虚拟化​ 网络虚拟化在不改变数据中心网络的物理拓扑和布线情况下，可以虚拟出各层网络，并实现互联，形成统一的交换架构。 ​ 网络虚拟化包括核心层、接入层以及虚拟机网络化三个层次 数据中心​ 数据中心主要特点和优势：通过服务器虚拟化、储存虚拟化、网络虚拟化、应用虚拟化技术，把各种硬件资源整合，对外提供服务，提高设备利用率。 ​ 数据中心一般采用冗余、容错、容灾设计 第十二章 Hadoop两个版本之间的区别与联系1.0版本的优势与局限：​ 优势是它的可拓展性。 ​ 局限是：1、仅支持一种计算模型，即MapReduce。2、MapReduce作业的Map阶段和Reduce阶段执行过程中需要通过磁盘的存取操作进行，效率低下。 ​ 3、调度方法远未达到优化资源利用率的效果 2.0版本的不同​ 新增YARN模块，将1.0中的resource management部分拿出来作为YARN的内容单独（把资源管理功能单独划分出来）。 ​ 支持更多的计算模型，包括流数据处理、图数据处理、批处理、交互式处理","categories":[{"name":"数据科学概论","slug":"数据科学概论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"begin","slug":"begin","date":"2021-01-02T09:18:22.000Z","updated":"2021-04-01T01:01:49.284Z","comments":true,"path":"2021/01/02/begin/","link":"","permalink":"http://example.com/2021/01/02/begin/","excerpt":"","text":"这是我在上次丢失文件后再次创建的个人博客，也没有啥说的吧就算是个新的开始吧；然后博客还没搞好，先凑合一下吧","categories":[],"tags":[{"name":"闲话","slug":"闲话","permalink":"http://example.com/tags/%E9%97%B2%E8%AF%9D/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-02T07:20:48.704Z","updated":"2021-01-02T07:20:48.705Z","comments":true,"path":"2021/01/02/hello-world/","link":"","permalink":"http://example.com/2021/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"OS","slug":"OS","permalink":"http://example.com/categories/OS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"马克思主义原理","slug":"马克思主义原理","permalink":"http://example.com/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"},{"name":"数据科学概论","slug":"数据科学概论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA/"}],"tags":[{"name":"操作系统算法","slug":"操作系统算法","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"},{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"闲话","slug":"闲话","permalink":"http://example.com/tags/%E9%97%B2%E8%AF%9D/"}]}