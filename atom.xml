<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whks-blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-09T13:03:24.959Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>whk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS算法</title>
    <link href="http://example.com/2021/05/09/OS%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/05/09/OS%E7%AE%97%E6%B3%95/</id>
    <published>2021-05-09T12:42:49.000Z</published>
    <updated>2021-05-09T13:03:24.959Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../blog/images/begin-1617238888146.jpg" alt="begin"></p><h1 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>​    先来先服务的调度算法：最简单的调度算法，既可以用于作业调度 ，也可以用于程序调度，当作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，优先从后备队列中，选择一个或多个位于队列头部的作业，把他们调入内存，分配所需资源、创建进程，然后放入“就绪队列”,直到该进程运行到完成或发生某事件堵塞后，进程调度程序才将处理机分配给其他进程。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shuru</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name; <span class="comment">//进程名</span></span><br><span class="line">    time arrve; <span class="comment">//到达就绪时间</span></span><br><span class="line">    <span class="keyword">int</span>  zx;<span class="comment">//执行时间</span></span><br><span class="line">    <span class="keyword">int</span> grad;</span><br><span class="line">    time start;<span class="comment">//开始时间</span></span><br><span class="line">    time  end;<span class="comment">//完成时间</span></span><br><span class="line">    <span class="keyword">int</span> zz;  <span class="comment">//周转时间=完成时间-到达时间</span></span><br><span class="line">    <span class="keyword">double</span> zzxs; <span class="comment">//周转系数 =周转时间/执行时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">time</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> mintes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FCFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortByTime</span><span class="params">(Shuru shuru[])</span> </span>&#123;<span class="comment">//比较到达时间</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=shuru.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; shuru.length; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (shuru[j].arrve.hour*<span class="number">60</span>+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*<span class="number">60</span>+shuru[i].arrve.mintes) &#123;</span><br><span class="line">                                        Shuru t = shuru[i];</span><br><span class="line">                                        shuru[i] = shuru[j];</span><br><span class="line">                                        shuru[j] = t;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortBygrade</span><span class="params">(Shuru shuru[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=shuru.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; shuru.length; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (shuru[j].grad &lt; shuru[i].grad) &#123;</span><br><span class="line">                                        Shuru t = shuru[i];</span><br><span class="line">                                        shuru[i] = shuru[j];</span><br><span class="line">                                        shuru[j] = t;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fcfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      </span></span><br><span class="line">                Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                Shuru shuru[] = <span class="keyword">new</span> Shuru[n];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;进程&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;信息输入：&quot;</span>);</span><br><span class="line">                        shuru[i] = <span class="keyword">new</span> Shuru();</span><br><span class="line">                        shuru[i].start = <span class="keyword">new</span> time();</span><br><span class="line">                        shuru[i].arrve = <span class="keyword">new</span> time();</span><br><span class="line">                        shuru[i].end = <span class="keyword">new</span> time();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;进程id\t进程名\t优先级\t进程到达时间\t进程执行时间&quot;</span>);</span><br><span class="line">                        String s = scan.nextLine();</span><br><span class="line">                        String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        shuru[i].id = Integer.parseInt(sa[<span class="number">0</span>]);</span><br><span class="line">                        shuru[i].name = sa[<span class="number">1</span>];</span><br><span class="line">                        shuru[i].grad = Integer.parseInt(sa[<span class="number">2</span>]);</span><br><span class="line">                        String[] time = sa[<span class="number">3</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                        shuru[i].arrve.hour = Integer.parseInt(time[<span class="number">0</span>]);</span><br><span class="line">                        shuru[i].arrve.mintes = Integer.parseInt(time[<span class="number">1</span>]);</span><br><span class="line">                        shuru[i].zx = Integer.parseInt(sa[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        shuru[i].start.hour = shuru[i].start.mintes = <span class="number">0</span>;</span><br><span class="line">                        shuru[i].end.hour = shuru[i].end.mintes = <span class="number">0</span>;</span><br><span class="line">                        shuru[i].zz = <span class="number">0</span>;</span><br><span class="line">                        shuru[i].zzxs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;**********************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">                SortByTime(shuru);</span><br><span class="line">                calculate(shuru,n);</span><br><span class="line">                SortBygrade(shuru);</span><br><span class="line">                calculate(shuru,n);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(Shuru shuru[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">                <span class="comment">/*第一个执行的程序*/</span></span><br><span class="line">                shuru[<span class="number">0</span>].start.hour = shuru[<span class="number">0</span>].arrve.hour;</span><br><span class="line">                shuru[<span class="number">0</span>].start.mintes = shuru[<span class="number">0</span>].arrve.mintes;</span><br><span class="line">                <span class="comment">//计算结束时间</span></span><br><span class="line">                <span class="keyword">if</span> ((shuru[<span class="number">0</span>].start.mintes + shuru[<span class="number">0</span>].zx) &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                        shuru[<span class="number">0</span>].end.hour = shuru[<span class="number">0</span>].start.hour + <span class="number">1</span>;</span><br><span class="line">                        shuru[<span class="number">0</span>].end.mintes = (shuru[<span class="number">0</span>].start.mintes + shuru[<span class="number">0</span>].zx - <span class="number">60</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shuru[<span class="number">0</span>].end.hour = shuru[<span class="number">0</span>].start.hour;</span><br><span class="line">                        shuru[<span class="number">0</span>].end.mintes = (shuru[<span class="number">0</span>].start.mintes + shuru[<span class="number">0</span>].zx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算周转时间</span></span><br><span class="line">                <span class="keyword">if</span> (shuru[<span class="number">0</span>].end.hour == shuru[<span class="number">0</span>].start.hour) &#123;</span><br><span class="line">                        shuru[<span class="number">0</span>].zz = (shuru[<span class="number">0</span>].end.mintes - shuru[<span class="number">0</span>].arrve.mintes);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shuru[<span class="number">0</span>].zz = ((shuru[<span class="number">0</span>].end.hour - shuru[<span class="number">0</span>].arrve.hour)*<span class="number">60</span> + shuru[<span class="number">0</span>].end.mintes - shuru[<span class="number">0</span>].arrve.mintes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算周转系数</span></span><br><span class="line">                shuru[<span class="number">0</span>].zzxs = (<span class="keyword">float</span>)shuru[<span class="number">0</span>].zz/shuru[<span class="number">0</span>].zx;</span><br><span class="line">                <span class="comment">/*计算除去第一个进程外的其他进程*/</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">                        shuru[i].start.hour = shuru[i - <span class="number">1</span>].end.hour;</span><br><span class="line">                        shuru[i].start.mintes = shuru[i - <span class="number">1</span>].end.mintes;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//计算结束时间</span></span><br><span class="line">                        <span class="keyword">if</span> ((shuru[i].start.mintes + shuru[i].zx) &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                                shuru[i].end.hour = (shuru[i].start.hour + <span class="number">1</span>);</span><br><span class="line">                                shuru[i].end.mintes = (shuru[i].zx + shuru[i].start.mintes - <span class="number">60</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                shuru[i].end.hour = shuru[i].start.hour;</span><br><span class="line">                                shuru[i].end.mintes = shuru[i].start.mintes + shuru[i].zx;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//计算周转时间</span></span><br><span class="line">                        <span class="keyword">if</span> (shuru[i].end.hour == shuru[i].arrve.hour) &#123;</span><br><span class="line">                                shuru[i].zz = shuru[i].end.mintes - shuru[i].arrve.mintes;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                shuru[i].zz = (shuru[i].end.hour - shuru[i].arrve.hour) * <span class="number">60</span> + shuru[i].end.mintes - shuru[i].arrve.mintes;</span><br><span class="line">                        &#125;</span><br><span class="line">                        shuru[i].zzxs = (<span class="keyword">float</span>)shuru[i].zz / shuru[i].zx;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;进程id\t进程名\t优先级\t执行时间\t\t到达时间\t\t开始时间\t\t结束时间\t\t周转时间\t\t带权周转系数&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> sumzz=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">float</span> sumzzxs=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                        show(shuru[i]);</span><br><span class="line"></span><br><span class="line">                        sumzz += shuru[i].zz;</span><br><span class="line">                        sumzzxs += shuru[i].zzxs;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;系统平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,(<span class="keyword">float</span>)sumzz/n);</span><br><span class="line">                System.out.printf(<span class="string">&quot;带权平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,sumzzxs/n);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(Shuru shuru)</span></span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t%s\t\t%d\t\t%d（分钟）\t%02d:%02d\t\t%02d:%02d\t\t%02d:%02d\t\t%d（分钟）\t\t%.2f\n&quot;</span>,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                FCFS j = <span class="keyword">new</span> FCFS();</span><br><span class="line">                Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入进程数目：\n&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> n = s.nextInt();</span><br><span class="line">                j.fcfs(n);</span><br><span class="line">                System.out.println(<span class="string">&quot;所有进程执行完毕！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实验数据</span></span><br><span class="line"><span class="comment">5001 p1 1 9:40 20</span></span><br><span class="line"><span class="comment">5004 p4 4 10:10 10</span></span><br><span class="line"><span class="comment">5005 p5 3 10:05 30</span></span><br><span class="line"><span class="comment">5002 p2 3 9:55 15</span></span><br><span class="line"><span class="comment">5003 p3 2 9:45 25</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>同先来先服务算法一样的功能，与之不同的是，短作业优先算法，是以作业运行时间长短排序；</p><p>1、在已到达的作业中，选择作业时间最短的进程</p><p>2、当前进程结束后，再在已到达的进程中选择运行时间最短的进程进入CPU进行执行</p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>与FCFS数结构一样</p><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SJF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortByTime</span><span class="params">(Shuru shuru[])</span> </span>&#123;<span class="comment">//比较到达时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=shuru.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; shuru.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shuru[j].arrve.hour*<span class="number">60</span>+shuru[j].arrve.mintes &lt; shuru[i].arrve.hour*<span class="number">60</span>+shuru[i].arrve.mintes) &#123;</span><br><span class="line"></span><br><span class="line">                    Shuru t = shuru[i];</span><br><span class="line">                    shuru[i] = shuru[j];</span><br><span class="line">                    shuru[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortBygrade</span><span class="params">(Shuru shuru[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=shuru.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; shuru.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(shuru[j].grad &gt; shuru[i].grad)&#123;</span><br><span class="line"></span><br><span class="line">                    Shuru temp = shuru[i];</span><br><span class="line">                    shuru[i] = shuru[j];</span><br><span class="line">                    shuru[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Shuru shuru[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shuru.length;i++)&#123;</span><br><span class="line">            shuru[i] = <span class="keyword">new</span> Shuru();</span><br><span class="line">            shuru[i].start = <span class="keyword">new</span> time();</span><br><span class="line">            shuru[i].arrve = <span class="keyword">new</span> time();</span><br><span class="line">            shuru[i].end = <span class="keyword">new</span> time();</span><br><span class="line">            shuru[i].id = <span class="number">0</span>;</span><br><span class="line">            shuru[i].name = <span class="string">&quot;nothing&quot;</span>;</span><br><span class="line">            shuru[i].grad = <span class="number">0</span>;</span><br><span class="line">            shuru[i].zx = <span class="number">0</span>;</span><br><span class="line">            shuru[i].zz = <span class="number">0</span>;</span><br><span class="line">            shuru[i].zzxs = <span class="number">0</span>;</span><br><span class="line">            shuru[i].start.hour = <span class="number">0</span>;</span><br><span class="line">            shuru[i].start.mintes = <span class="number">0</span>;</span><br><span class="line">            shuru[i].end.hour = <span class="number">0</span>;</span><br><span class="line">            shuru[i].end.mintes = <span class="number">0</span>;</span><br><span class="line">            shuru[i].arrve.hour = <span class="number">0</span>;</span><br><span class="line">            shuru[i].arrve.mintes = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Shuru shuru[],Shuru shuru1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shuru.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(shuru[i].id == shuru1.id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sjf</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Shuru shuru[] = <span class="keyword">new</span> Shuru[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进程&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;信息输入：&quot;</span>);</span><br><span class="line">            shuru[i] = <span class="keyword">new</span> Shuru();</span><br><span class="line">            shuru[i].start = <span class="keyword">new</span> time();</span><br><span class="line">            shuru[i].arrve = <span class="keyword">new</span> time();</span><br><span class="line">            shuru[i].end = <span class="keyword">new</span> time();</span><br><span class="line">            System.out.println(<span class="string">&quot;进程id\t进程名\t优先级\t进程到达时间:\t进程执行时间&quot;</span>);</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            shuru[i].id = Integer.parseInt(sa[<span class="number">0</span>]);</span><br><span class="line">            shuru[i].name = sa[<span class="number">1</span>];</span><br><span class="line">            shuru[i].grad = Integer.parseInt(sa[<span class="number">2</span>]);</span><br><span class="line">            String[] time = sa[<span class="number">3</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            shuru[i].arrve.hour = Integer.parseInt(time[<span class="number">0</span>]);</span><br><span class="line">            shuru[i].arrve.mintes = Integer.parseInt(time[<span class="number">1</span>]);</span><br><span class="line">            shuru[i].zx = Integer.parseInt(sa[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            shuru[i].start.hour = shuru[i].start.mintes = <span class="number">0</span>;</span><br><span class="line">            shuru[i].end.hour = shuru[i].end.mintes = <span class="number">0</span>;</span><br><span class="line">            shuru[i].zz = <span class="number">0</span>;</span><br><span class="line">            shuru[i].zzxs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Shuru shuruans[] = <span class="keyword">new</span> Shuru[n];</span><br><span class="line">        init(shuruans);</span><br><span class="line">        Shuru shurutemp[] = <span class="keyword">new</span> Shuru[n];</span><br><span class="line">        init(shurutemp);</span><br><span class="line">        <span class="comment">//先时间排序</span></span><br><span class="line">        SortByTime(shuru);</span><br><span class="line">        <span class="comment">//按优先级进行执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进程id\t进程名\t优先级\t执行时间\t\t到达时间\t\t开始时间\t\t结束时间\t\t周转时间\t\t带权周转系数&quot;</span>);</span><br><span class="line">        calculate(shuru[<span class="number">0</span>],shuru[<span class="number">0</span>].arrve.hour,shuru[<span class="number">0</span>].arrve.mintes);</span><br><span class="line">        <span class="comment">//执行第一个到达的进程</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        shuruans[count] = shuru[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n-<span class="number">1</span>;k++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            从第一次执行完成后，每次执行时，</span></span><br><span class="line"><span class="comment">            先从已经到达的进程中选择优先级最高的进程进行执行；</span></span><br><span class="line"><span class="comment">            执行完后再次选择，直到所有进程都执行完毕。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            init(shurutemp);<span class="comment">//作为中间变量，储存筛选出来的进程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shuru.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shuru[i].arrve.hour*<span class="number">60</span>+shuru[i].arrve.mintes &lt;= shuruans[count].end.hour*<span class="number">60</span>+shuruans[count].end.mintes &amp;&amp; !find(shuruans,shuru[i])  ) &#123;</span><br><span class="line">                    shurutemp[i] = shuru[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==shuru.length-<span class="number">1</span> &amp;&amp; shurutemp[<span class="number">0</span>].id==<span class="number">0</span>)&#123;</span><br><span class="line">                    shurutemp[<span class="number">0</span>] = shuru[count+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SortBygrade(shurutemp);<span class="comment">//按优先级排序</span></span><br><span class="line">            <span class="keyword">if</span>(count&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(shurutemp[<span class="number">0</span>].arrve.hour*<span class="number">60</span>+shurutemp[<span class="number">0</span>].arrve.mintes &lt;= shuruans[count].end.hour*<span class="number">60</span>+shuruans[count].end.mintes) &#123;</span><br><span class="line">                    calculate(shurutemp[<span class="number">0</span>], shuruans[count].end.hour, shuruans[count].end.mintes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    calculate(shurutemp[<span class="number">0</span>],shurutemp[<span class="number">0</span>].arrve.hour,shurutemp[<span class="number">0</span>].arrve.mintes);</span><br><span class="line">                &#125;</span><br><span class="line">                count+=<span class="number">1</span>;</span><br><span class="line">                shuruans[count] = shurutemp[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            show(shuru[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;------------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="comment">//计算带权平均与输出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            show(shuruans[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;系统平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,(<span class="keyword">float</span>)sumzz/n);</span><br><span class="line">        System.out.printf(<span class="string">&quot;带权平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,sumzzxs/n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(Shuru shuru,<span class="keyword">int</span> TimeHour,<span class="keyword">int</span> TimeMinte)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            shuru.start.hour = TimeHour;</span><br><span class="line">            shuru.start.mintes = TimeMinte;</span><br><span class="line">            <span class="comment">//计算结束时间</span></span><br><span class="line">            <span class="keyword">if</span> ((shuru.start.mintes + shuru.zx) &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                shuru.end.hour = (shuru.start.hour + <span class="number">1</span>);</span><br><span class="line">                shuru.end.mintes = (shuru.zx + shuru.start.mintes - <span class="number">60</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                shuru.end.hour = shuru.start.hour;</span><br><span class="line">                shuru.end.mintes = shuru.start.mintes + shuru.zx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算周转时间</span></span><br><span class="line">            <span class="keyword">if</span> (shuru.end.hour == shuru.arrve.hour) &#123;</span><br><span class="line">                shuru.zz = shuru.end.mintes - shuru.arrve.mintes;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                shuru.zz = (shuru.end.hour - shuru.arrve.hour) * <span class="number">60</span> + shuru.end.mintes - shuru.arrve.mintes;</span><br><span class="line">            &#125;</span><br><span class="line">            shuru.zzxs = (<span class="keyword">float</span>)shuru.zz / shuru.zx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(Shuru shuru)</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\t%s\t\t%d\t\t%d（分钟）\t%02d:%02d\t\t%02d:%02d\t\t%02d:%02d\t\t%d（分钟）\t\t%.2f\n&quot;</span>,shuru.id, shuru.name,shuru.grad,shuru.zx,shuru.arrve.hour,shuru.arrve.mintes, shuru.start.hour,shuru.start.mintes,shuru.end.hour,shuru.end.mintes,shuru.zz,shuru.zzxs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        SJF j = <span class="keyword">new</span> SJF();</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入进程数目：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = s.nextInt();</span><br><span class="line">        j.sjf(n);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有进程执行完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5001 p1 1 9:40 20</span></span><br><span class="line"><span class="comment">5004 p4 4 10:10 10</span></span><br><span class="line"><span class="comment">5005 p5 3 10:05 30</span></span><br><span class="line"><span class="comment">5002 p2 3 9:55 15</span></span><br><span class="line"><span class="comment">5003 p3 2 9:45 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1001 p1 1 10:00 20</span></span><br><span class="line"><span class="comment">1002 p2 2 9:20 65</span></span><br><span class="line"><span class="comment">1003 p3 2 10:25 50</span></span><br><span class="line"><span class="comment">1004 p4 3 8:10 10</span></span><br><span class="line"><span class="comment">1005 p5 2 7:40 20</span></span><br><span class="line"><span class="comment">1006 p6 1 11:20 100</span></span><br><span class="line"><span class="comment">1007 p7 1 10:30 120</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure><h1 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h1><h2 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h2><p>设置时间片段，每次进入CPU的进程，只允许运行时间片段长度的时间，时间片用完后，解除CPU占用，进入当前就绪队列的最后；</p><p>CPU再选入就绪队列中最前面的进程调入CPU运行；如此反复，直到所有进程都运行完毕。</p><h2 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">int</span> mintes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timePlus</span><span class="params">(Time begin, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        begin.hour = (begin.hour + (<span class="keyword">int</span>) (begin.mintes + time) / <span class="number">60</span>);</span><br><span class="line">        begin.mintes = ((begin.mintes + time) % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timesub</span><span class="params">(Time begin,Time end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (end.hour*<span class="number">60</span>+end.mintes - begin.hour*<span class="number">60</span>+begin.mintes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name; <span class="comment">//进程名</span></span><br><span class="line">    <span class="keyword">int</span>  zx;<span class="comment">//执行时间</span></span><br><span class="line">    Time arrive; <span class="comment">//到达就绪时间</span></span><br><span class="line">    Time start;<span class="comment">//每轮开始开始时间</span></span><br><span class="line">    Time first;<span class="comment">//首次执行时间</span></span><br><span class="line">    <span class="keyword">int</span> have_finished;<span class="comment">//已完成时间</span></span><br><span class="line">    Time arr;<span class="comment">//每轮到达时间</span></span><br><span class="line">    Time  end;<span class="comment">//完成时间</span></span><br><span class="line">    <span class="keyword">int</span> zz;  <span class="comment">//周转时间=完成时间-到达时间</span></span><br><span class="line">    <span class="keyword">double</span> zzxs; <span class="comment">//周转系数 =周转时间/执行时间</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortByTime</span><span class="params">(Process shuru[])</span> </span>&#123;<span class="comment">//比较到达时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=shuru.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; shuru.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shuru[j].arrive.hour*<span class="number">60</span>+shuru[j].arrive.mintes &lt; shuru[i].arrive.hour*<span class="number">60</span>+shuru[i].arrive.mintes) &#123;</span><br><span class="line"></span><br><span class="line">                    Process t = shuru[i];</span><br><span class="line">                    shuru[i] = shuru[j];</span><br><span class="line">                    shuru[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Process a[],Process b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        Process temp;</span><br><span class="line">        temp = b;</span><br><span class="line">        <span class="keyword">if</span>(find(b,a)) remove(a,b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j].name == <span class="string">&quot;nothing&quot;</span> || j==n-<span class="number">1</span>)&#123;</span><br><span class="line">                a[j] = temp;<span class="comment">//新增</span></span><br><span class="line">                a[j].start.hour = <span class="number">0</span>;</span><br><span class="line">                a[j].start.mintes = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Process A[],Process a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i].id==a.id)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                    A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (A[len-1].id==A[len-2].id)&#123;</span></span><br><span class="line"><span class="comment">//            A[len - 1].id = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].name = &quot;nothing&quot;;</span></span><br><span class="line"><span class="comment">//            A[len - 1].zx = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].arrive.hour = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].arrive.mintes = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].start.hour = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].start.mintes = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].have_finished = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].arr.hour = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].arr.mintes = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].end.hour = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].end.mintes = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].zz = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].zzxs = 0;</span></span><br><span class="line"><span class="comment">//            A[len - 1].flag = -1;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Process input[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">            input[i] = <span class="keyword">new</span> Process();</span><br><span class="line">            input[i].id = <span class="number">0</span>;</span><br><span class="line">            input[i].name = <span class="string">&quot;nothing&quot;</span>;</span><br><span class="line">            input[i].zx = <span class="number">0</span>;</span><br><span class="line">            input[i].arrive = <span class="keyword">new</span> Time();</span><br><span class="line">            input[i].arrive.hour = <span class="number">0</span>;</span><br><span class="line">            input[i].arrive.mintes = <span class="number">0</span>;</span><br><span class="line">            input[i].start = <span class="keyword">new</span> Time();</span><br><span class="line">            input[i].start.hour = <span class="number">0</span>;</span><br><span class="line">            input[i].start.mintes = <span class="number">0</span>;</span><br><span class="line">            input[i].first  = <span class="keyword">new</span> Time();</span><br><span class="line"></span><br><span class="line">            input[i].have_finished = <span class="number">0</span>;</span><br><span class="line">            input[i].arr = <span class="keyword">new</span> Time();</span><br><span class="line">            input[i].arr.hour = <span class="number">0</span>;</span><br><span class="line">            input[i].arr.mintes = <span class="number">0</span>;</span><br><span class="line">            input[i].end = <span class="keyword">new</span> Time();</span><br><span class="line">            input[i].end.hour = <span class="number">0</span>;</span><br><span class="line">            input[i].end.mintes = <span class="number">0</span>;</span><br><span class="line">            input[i].zz = <span class="number">0</span>;</span><br><span class="line">            input[i].zzxs = <span class="number">0</span>;</span><br><span class="line">            input[i].flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(Process process[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumzz=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sumzzxs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = process.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;进程id\t进程名\t到达时间\t执行时间\t\t首次开始时间\t结束时间\t\t周转时间\t\t带权周转系数&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            process[i].zz = ((process[i].end.hour*<span class="number">60</span>+process[i].end.mintes)-(process[i].arrive.hour*<span class="number">60</span>+process[i].arrive.mintes));</span><br><span class="line">            process[i].zzxs = (<span class="keyword">float</span>)process[i].zz/process[i].zx;</span><br><span class="line">            sumzz += process[i].zz;</span><br><span class="line">            sumzzxs += process[i].zzxs;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%s\t\t%02d:%02d\t%d(分钟)\t\t%02d:%02d\t\t%02d:%02d\t\t%d（分钟）\t\t%.2f\n&quot;</span>,</span><br><span class="line">                    process[i].id, process[i].name,</span><br><span class="line">                    process[i].arrive.hour, process[i].arrive.mintes, process[i].zx,</span><br><span class="line">                    process[i].first.hour, process[i].first.mintes,</span><br><span class="line">                    process[i].end.hour, process[i].end.mintes,</span><br><span class="line">                    process[i].zz, process[i].zzxs);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;系统平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,(<span class="keyword">float</span>)sumzz/n);</span><br><span class="line">        System.out.printf(<span class="string">&quot;带权平均周转时间\t\t\t\t\t%10.2f（分钟）\n&quot;</span>,sumzzxs/n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showRun</span><span class="params">(Process process[], <span class="keyword">int</span> n, Time now)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+n+<span class="string">&quot;执行和就绪队列&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;当前时间: %02d :%02d\n&quot;</span>,now.hour,now.mintes);</span><br><span class="line">        System.out.println(<span class="string">&quot;ID号\t名字\t到达时间\t总执行时间(分钟)\t当前开始时间\t已完成时间\t剩余时间(分钟)&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;process.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process[i].id!=<span class="number">0</span> &amp;&amp; process[i].name!=<span class="string">&quot;nothing&quot;</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t%s\t%02d:%02d\t%d（分钟）\t\t\t%02d:%02d\t%d(分钟)\t\t%d（分钟）\n&quot;</span>,</span><br><span class="line">                        process[i].id, process[i].name,</span><br><span class="line">                        process[i].arrive.hour, process[i].arrive.mintes, process[i].zx,</span><br><span class="line">                        process[i].start.hour, process[i].start.mintes, process[i].have_finished,</span><br><span class="line">                        (process[i].zx - process[i].have_finished));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sure</span><span class="params">(Process input[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=input.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (input[j].flag!=<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Process process,Process A[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process.id==A[i].id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(Process A[],Time now,<span class="keyword">int</span> time,Process B[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> less;</span><br><span class="line">            A[<span class="number">0</span>].start.hour = now.hour;</span><br><span class="line">            A[<span class="number">0</span>].start.mintes = now.mintes;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不可直接A.start = now,这只是建立索引，start与now会一同变化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            less = A[<span class="number">0</span>].zx - A[<span class="number">0</span>].have_finished;</span><br><span class="line">            <span class="comment">//第一次执行进程</span></span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>].have_finished == <span class="number">0</span>) &#123;</span><br><span class="line">                A[<span class="number">0</span>].first.hour = now.hour;</span><br><span class="line">                A[<span class="number">0</span>].first.mintes = now.mintes;</span><br><span class="line">                <span class="keyword">if</span> (less &gt; time) &#123;  <span class="comment">//剩余未做完&gt;大于时间片</span></span><br><span class="line">                    A[<span class="number">0</span>].start.hour = now.hour;</span><br><span class="line">                    A[<span class="number">0</span>].start.mintes = now.mintes;</span><br><span class="line">                    A[<span class="number">0</span>].have_finished += time;</span><br><span class="line">                    Time.timePlus(now, time);</span><br><span class="line">                    time = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    A[<span class="number">0</span>].have_finished = A[<span class="number">0</span>].zx;</span><br><span class="line">                    A[<span class="number">0</span>].flag = <span class="number">1</span>; <span class="comment">//表示做完了</span></span><br><span class="line">                    A[<span class="number">0</span>].end.hour = (now.hour + (<span class="keyword">int</span>) (now.mintes + less) / <span class="number">60</span>);</span><br><span class="line">                    A[<span class="number">0</span>].end.mintes = ((now.mintes + less) % <span class="number">60</span>);</span><br><span class="line">                    Time.timePlus(now, (time - less));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (less &gt; time) &#123;</span><br><span class="line">                    A[<span class="number">0</span>].start.hour = now.hour;</span><br><span class="line">                    A[<span class="number">0</span>].start.mintes = now.mintes;</span><br><span class="line">                    A[<span class="number">0</span>].have_finished += time;</span><br><span class="line">                    Time.timePlus(now, time);</span><br><span class="line">                    time = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    A[<span class="number">0</span>].have_finished = A[<span class="number">0</span>].zx;</span><br><span class="line">                    A[<span class="number">0</span>].flag = <span class="number">1</span>; <span class="comment">//表示做完了</span></span><br><span class="line">                    A[<span class="number">0</span>].end.hour = (now.hour + (<span class="keyword">int</span>) (now.mintes + less) / <span class="number">60</span>);</span><br><span class="line">                    A[<span class="number">0</span>].end.mintes = ((now.mintes + less) % <span class="number">60</span>);</span><br><span class="line">                    Time.timePlus(now, (time - less));</span><br><span class="line"><span class="comment">//                    calculate(A, now, time,B);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rr</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> Timeslice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Process input[] = <span class="keyword">new</span> Process[n];</span><br><span class="line">        Process temp[] = <span class="keyword">new</span> Process[n];</span><br><span class="line">        Process ans[] = <span class="keyword">new</span> Process[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        init(input);</span><br><span class="line">        init(ans);</span><br><span class="line">        init(temp);</span><br><span class="line">        <span class="comment">//输入进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进程&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;信息输入：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;进程id\t进程名\t优先级\t进程到达时间:\t进程执行时间&quot;</span>);</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            input[i].id = Integer.parseInt(sa[<span class="number">0</span>]);</span><br><span class="line">            input[i].name = sa[<span class="number">1</span>];</span><br><span class="line">            String[] time = sa[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            input[i].arrive.hour = Integer.parseInt(time[<span class="number">0</span>]);</span><br><span class="line">            input[i].arrive.mintes = Integer.parseInt(time[<span class="number">1</span>]);</span><br><span class="line">            input[i].zx = Integer.parseInt(sa[<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        SortByTime(input);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>,count_num=<span class="number">0</span>,timeset;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        count用于计算已经完成了多少个进程</span></span><br><span class="line"><span class="comment">        count_num 第几轮执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Time now = <span class="keyword">new</span> Time();</span><br><span class="line">        now.hour = input[<span class="number">0</span>].arrive.hour;</span><br><span class="line">        now.mintes = input[<span class="number">0</span>].arrive.mintes;</span><br><span class="line">        insert(temp,input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(sure(ans))&#123;</span><br><span class="line"><span class="comment">//        while(count_num&lt;20)&#123;</span></span><br><span class="line">            count_num++;</span><br><span class="line">            calculate(temp, now, Timeslice,ans);</span><br><span class="line">            showRun(temp, count_num, now);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[j].flag==<span class="number">1</span> &amp;&amp; count&lt;<span class="number">5</span> &amp;&amp; !find(temp[j],ans))&#123;</span><br><span class="line">                        ans[count++] = temp[j];</span><br><span class="line">                        remove(temp,temp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//查找已经到达的程序</span></span><br><span class="line">                <span class="keyword">if</span> (now.hour * <span class="number">60</span> + now.mintes &gt; input[i].arrive.hour * <span class="number">60</span> + input[i].arrive.mintes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!find(input[i], temp) &amp;&amp; !find(input[i],ans)) &#123;</span><br><span class="line">                        insert(temp, input[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            insert(temp, temp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        show(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        RoundRobin j = <span class="keyword">new</span> RoundRobin();</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入进程数目：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = s.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入时间片时间：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> TimeSlice = s.nextInt();</span><br><span class="line">        j.rr(n, TimeSlice);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有进程执行完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5001 p1 9:40 20</span></span><br><span class="line"><span class="comment">5004 p4 10:10 10</span></span><br><span class="line"><span class="comment">5005 p5 10:05 30</span></span><br><span class="line"><span class="comment">5002 p2 9:55 15</span></span><br><span class="line"><span class="comment">5003 p3 9:45 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2021/5/9 21:00</p><p>今天就写到这，下次补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../blog/images/begin-1617238888146.jpg&quot; alt=&quot;begin&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;FCFS&quot;&gt;&lt;a href=&quot;#FCFS&quot; class=&quot;headerlink&quot; title=&quot;FCFS&quot;&gt;&lt;/a&gt;FCFS</summary>
      
    
    
    
    
    <category term="操作系统算法" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2021/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-17T08:38:33.000Z</published>
    <updated>2021-04-17T10:00:53.981Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../blog/images/jsjwl.jfif" alt="begin"></p><p>这里是计算机网络知识点</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><h3 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h3><p>​                    <strong>计算机网络</strong>（简称<strong>网络</strong>）由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。网络中的结点可以是计算机、集线器、交换机或路由器等\n</p><p>​                    多个网络通过路由器互联起来成为互连网；互连网是网络的网络\n</p><p>​                    <strong>网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与互联网相连的计算机常称为主机**</strong>\n</p><h3 id="互联网的基础结构发展三个阶段"><a href="#互联网的基础结构发展三个阶段" class="headerlink" title="互联网的基础结构发展三个阶段"></a>互联网的基础结构发展三个阶段</h3><h4 id="第一阶段：ARPANET向互连网发展的过程-n"><a href="#第一阶段：ARPANET向互连网发展的过程-n" class="headerlink" title="第一阶段：ARPANET向互连网发展的过程\n"></a>第一阶段：<strong>ARPANET</strong>向互连网发展的过程\n</h4><p>​                                <strong>internet(互连网)是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络</strong>。网络之间的通信协议可以任意选择\n</p><p>​                                <strong>Internet(互联网，或因特网)则是一个专用名词，它只电器那全球最大的、开放的、由众多网络相互连接而成的特定互联网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET</strong>\n</p><h4 id="第二阶段：-特点是建成了三级结构的互联网"><a href="#第二阶段：-特点是建成了三级结构的互联网" class="headerlink" title="第二阶段：    特点是建成了三级结构的互联网"></a>第二阶段：    特点是建成了<strong>三级结构的互联网</strong></h4><p>​                                分为 <strong>主干网</strong>、<strong>地区网</strong>和 <strong>校园网</strong>（或 <strong>企业网</strong>）</p><p>​                                <strong>www</strong>万维网</p><h4 id="第三阶段：-特点是逐渐形成了多层次IPS结构的互联网"><a href="#第三阶段：-特点是逐渐形成了多层次IPS结构的互联网" class="headerlink" title="第三阶段： 特点是逐渐形成了多层次IPS结构的互联网"></a>第三阶段： 特点是逐渐形成了多层次IPS结构的互联网</h4><h3 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h3><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>​            <strong>边缘部分</strong> 由所以连接在互联网上的主机组成。这部分是 <strong>用户直接使用的</strong>,用来进行通信（传输数据、音频或视频）和资源共享</p><p>​            <strong>核心部分</strong> 由大量网络和连接这些网络的路由器组成。这部分是 <strong>为边缘部分提供服务的</strong> （提供连通性和交换）</p><h3 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h3><p>​                    处在互联网边缘的部分就是连接在互联网上的所有主机。这些主机由称为 <strong>端系统</strong>\n</p><p>​                    <strong>主机A的某个进程和主机B上的某一个进程进行通信</strong> 简称为 “<strong>计算机之间的通信</strong>”\n</p><p>​                    <strong>通信的方式可分为两大类：\</strong>n</p><h4 id="1-客户-服务器方式"><a href="#1-客户-服务器方式" class="headerlink" title="1.客户-服务器方式"></a>1.客户-服务器方式</h4><p>​                                <strong>客户</strong>和<strong>服务器</strong>都是只通信中所涉及的两个应用进程</p><p>​                                <strong>客户是服务请求方，服务器是服务提供方</strong></p><h4 id="2-对等连接方式"><a href="#2-对等连接方式" class="headerlink" title="2.对等连接方式"></a>2.对等连接方式</h4><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../blog/images/jsjwl.jfif&quot; alt=&quot;begin&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里是计算机网络知识点&lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第</summary>
      
    
    
    
    
    <category term="期末复习" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2021/03/06/MySQL/"/>
    <id>http://example.com/2021/03/06/MySQL/</id>
    <published>2021-03-06T07:19:18.000Z</published>
    <updated>2021-03-06T07:19:18.466Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-16</title>
    <link href="http://example.com/2021/01/16/leetcode-train-day-16/"/>
    <id>http://example.com/2021/01/16/leetcode-train-day-16/</id>
    <published>2021-01-16T10:17:46.000Z</published>
    <updated>2021-01-16T10:17:46.260Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-15</title>
    <link href="http://example.com/2021/01/15/leetcode-train-day-15/"/>
    <id>http://example.com/2021/01/15/leetcode-train-day-15/</id>
    <published>2021-01-15T09:39:46.000Z</published>
    <updated>2021-01-15T10:02:03.393Z</updated>
    
    <content type="html"><![CDATA[<p>今天的又是一道并查集的题目<br>好像总是并查集</p><hr><p>n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。</p><p> </p><p>示例 1：</p><p>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]<br>输出：5<br>解释：一种移除 5 块石头的方法如下所示：</p><ol><li>移除石头 [2,2] ，因为它和 [2,1] 同行。</li><li>移除石头 [2,1] ，因为它和 [0,1] 同列。</li><li>移除石头 [1,2] ，因为它和 [1,0] 同行。</li><li>移除石头 [1,0] ，因为它和 [0,0] 同列。</li><li>移除石头 [0,1] ，因为它和 [0,0] 同行。<br>石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。<br>示例 2：</li></ol><p>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]<br>输出：3<br>解释：一种移除 3 块石头的方法如下所示：</p><ol><li>移除石头 [2,2] ，因为它和 [2,0] 同行。</li><li>移除石头 [2,0] ，因为它和 [0,0] 同列。</li><li>移除石头 [0,2] ，因为它和 [0,0] 同行。<br>石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。<br>示例 3：</li></ol><p>输入：stones = [[0,0]]<br>输出：0<br>解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>python解法</p><pre><code>class UnionFind:def __init__(self):    self.parent = &#123;&#125;def add(self,x):    if x not in self.parent:        self.parent[x] = Nonedef find(self,x):    root = x    while self.parent[root]:        root = self.parent[root]    while x!=root:        self.parent[x],x= root,self.parent[x]    return rootdef union(self,x,y):    root_x, root_y = self.find(x),self.find(y)    if root_x!=root_y:        self.parent[root_x]=root_ydef get_union(self):    return sum([1 for k,v in self.parent.items() if v is None])</code></pre><p>class Solution:<br>    def removeStones(self, stones: List[List[int]]) -&gt; int:<br>        uf = UnionFind()<br>        for x,y in stones:<br>            uf.add(x)<br>            uf.add(y+10000)<br>            uf.union(x,y+10000)<br>        return len(stones)-uf.get_union()</p><hr><p>就这样，以后可能不每天写了吧，不过leetcode 每天还是打卡的，哈哈哈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的又是一道并查集的题目&lt;br&gt;好像总是并查集&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。&lt;/p&gt;
&lt;p&gt;如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。&lt;/p&gt;
&lt;p&gt;给你一个长度为 n</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-14</title>
    <link href="http://example.com/2021/01/14/leetcode-train-day-14/"/>
    <id>http://example.com/2021/01/14/leetcode-train-day-14/</id>
    <published>2021-01-14T12:23:43.000Z</published>
    <updated>2021-01-14T12:41:49.501Z</updated>
    
    <content type="html"><![CDATA[<p>今天考了数据结构，然后回来后一直在玩，差点忘记了这件事，还好记起来了</p><hr><p>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。</p><p> </p><p>示例 1：</p><p>输入：[0,1,1]<br>输出：[true,false,false]<br>解释：<br>输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5">https://leetcode-cn.com/problems/binary-prefix-divisible-by-5</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>今天的题比较简单，哈哈哈哈</p><p>ps：终于不是并查集了！！！</p><hr><p>python 解法</p><pre><code>class Solution:def prefixesDivBy5(self, A: List[int]) -&gt; List[bool]:    sum_=0    for i,num in enumerate(A):        sum_=(sum_*2+num)%5        A[i]=(sum_%5==0)    return A</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天考了数据结构，然后回来后一直在玩，差点忘记了这件事，还好记起来了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。&lt;/p&gt;
&lt;p&gt;返回布尔值</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-13</title>
    <link href="http://example.com/2021/01/13/leetcode-train-day-13/"/>
    <id>http://example.com/2021/01/13/leetcode-train-day-13/</id>
    <published>2021-01-13T11:39:45.000Z</published>
    <updated>2021-01-13T12:24:33.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一连好几天都是并查集，诶呀"><a href="#一连好几天都是并查集，诶呀" class="headerlink" title="一连好几天都是并查集，诶呀"></a>一连好几天都是并查集，诶呀</h2><ol start="684"><li>冗余连接<br>在本问题中, 树指的是一个连通且无环的无向图。</li></ol><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / <br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3<br>注意:</p><p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。</p><hr><p>class Solution:<br>    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:</p><pre><code>    def find(x):        if x != uf[x]:            uf[x] = find(uf[x])        return uf[x]    uf = [i for i in range(len(edges)+1)]    res = [0, 0]    for x, y in edges:        # 如果这两个点还不连通，就将它两连通        if find(x) != find(y):            uf[find(x)] = find(y)        # 如果这两个点已经连通了，说明新加入这条边是冗余的。        else:            res = [x, y]    return res </code></pre><hr><p>今天认真恶补了并查集，这下好多了</p><p>没时间了，不写c的写法了。唉。数据结构明天就考了，复习复习</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一连好几天都是并查集，诶呀&quot;&gt;&lt;a href=&quot;#一连好几天都是并查集，诶呀&quot; class=&quot;headerlink&quot; title=&quot;一连好几天都是并查集，诶呀&quot;&gt;&lt;/a&gt;一连好几天都是并查集，诶呀&lt;/h2&gt;&lt;ol start=&quot;684&quot;&gt;
&lt;li&gt;冗余连接&lt;br&gt;</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-12</title>
    <link href="http://example.com/2021/01/12/leetcode-train-day-12/"/>
    <id>http://example.com/2021/01/12/leetcode-train-day-12/</id>
    <published>2021-01-12T07:25:42.000Z</published>
    <updated>2021-01-12T08:35:22.775Z</updated>
    
    <content type="html"><![CDATA[<p>开始</p><hr><p>公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。</p><p>group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。</p><p> </p><p>示例 1：</p><p>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]<br>输出：[6,3,4,1,5,2,0,7]<br>示例 2：</p><p>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]<br>输出：[]<br>解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies">https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>这道题的难度是困难，我不会写。。。。</p><p>这个学期正好学了数据结构，然后看到这个我就想到了关键路径，拓扑排序；但是我还是不怎么会写(っ °Д °;)っ</p><p>求助评论区</p><pre><code>class Solution:def TopSort(self,items,indegree,neighbors):    #建立队列和访问顺序，并初始化队列    queue = collections.deque()    res = []    for i in items:        if not indegree[i]:            queue.append(i)    if not queue: return []    #广度遍历    while queue:        cur = queue.popleft()        res.append(cur)        for neighbor in neighbors[cur]:            indegree[neighbor] -= 1            if not indegree[neighbor]:                queue.append(neighbor)    return resdef sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:    max_id = m    for task in range(n):        if group[task] == -1:            group[task] = max_id            max_id += 1    task_indegree = [0] * n    group_indegree = [0]*max_id    task_neighbors = [[] for _ in range(n)]    group_neighbors = [[] for _ in range(max_id)]    group_to_tasks =[[] for _ in range(max_id)]      for task in range(n):        group_to_tasks[group[task]].append(task)        for prerequisite in beforeItems[task]:            #判断相关联的两个项目是否属于同一组            if group[prerequisite] != group[task]:  #不同组，建立图                group_indegree[group[task]] += 1                group_neighbors[group[prerequisite]].append(group[task])            else:  #同组，组内建立图                task_indegree[task] += 1                task_neighbors[prerequisite].append(task)    res = []    group_queue = self.TopSort([i for i in range(max_id)],group_indegree,group_neighbors)    if len(group_queue) != max_id: return []    for group_id in group_queue:        # 得到每组项目的访问顺序        task_queue = self.TopSort(group_to_tasks[group_id],task_indegree,task_neighbors)        if len(task_queue) != len(group_to_tasks[group_id]):            return []        res += task_queue    return res</code></pre><hr><p>python的写法，里面这里涉及到一个python队列的问题</p><p>附上解释的链接<br><a href="https://www.cnblogs.com/lincappu/p/12890765.html">https://www.cnblogs.com/lincappu/p/12890765.html</a></p><hr><p>c语言的写法就更不会了，唉。按着书上的改，还不会改，妥妥的菜鸡。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开始&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。&lt;/p&gt;
&lt;p&gt;group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-11</title>
    <link href="http://example.com/2021/01/11/leetcode-train-day-11/"/>
    <id>http://example.com/2021/01/11/leetcode-train-day-11/</id>
    <published>2021-01-11T12:18:36.000Z</published>
    <updated>2021-01-11T13:16:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>今天差点忘了</p><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p><p> </p><p>示例 1:</p><p>输入：s = “dcab”, pairs = [[0,3],[1,2]]<br>输出：”bacd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[1] 和 s[2], s = “bacd”<br>示例 2：</p><p>输入：s = “dcab”, pairs = [[0,3],[1,2],[0,2]]<br>输出：”abcd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[0] 和 s[2], s = “acbd”<br>交换 s[1] 和 s[2], s = “abcd”<br>示例 3：</p><p>输入：s = “cba”, pairs = [[0,1],[1,2]]<br>输出：”abc”<br>解释：<br>交换 s[0] 和 s[1], s = “bca”<br>交换 s[1] 和 s[2], s = “bac”<br>交换 s[0] 和 s[1], s = “abc”</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps">https://leetcode-cn.com/problems/smallest-string-with-swaps</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>今天的难度中等，又是一道运用并查集的题目，是这个月第三道吧，但是我感觉我还是不怎么会写并查集的题目</p><hr><p>python 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span>(<span class="params">self, s: <span class="built_in">str</span>, pairs: List[List[<span class="built_in">int</span>]]</span>) -&gt; str:</span></span><br><span class="line">        length=<span class="built_in">len</span>(s)</span><br><span class="line">        parent=&#123;i:i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)&#125;</span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x!=parent[x]:</span><br><span class="line">                parent[x]=find(parent[x])</span><br><span class="line">            <span class="keyword">return</span> parent[x]</span><br><span class="line">        <span class="comment"># 查找根节点</span></span><br><span class="line">        <span class="keyword">for</span> a,b <span class="keyword">in</span> pairs:</span><br><span class="line">            c,d = find(a),find(b)</span><br><span class="line">            <span class="keyword">if</span> c!=d:</span><br><span class="line">                parent[d] = c</span><br><span class="line">        <span class="comment"># 获取根节点对应的连通块集合</span></span><br><span class="line">        dic=collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            root=find(i)</span><br><span class="line">            dic[root].append(i)</span><br><span class="line">        <span class="comment"># 对每个连通块中元素排序</span></span><br><span class="line">        res=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">            arr=[s[i] <span class="keyword">for</span> i <span class="keyword">in</span> v]</span><br><span class="line">            arr.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v)):</span><br><span class="line">                res[v[i]]=arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天差点忘了&lt;/p&gt;
&lt;p&gt;给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。&lt;/p&gt;
&lt;p&gt;你可以 任意多次交换 在 pairs 中任意一对索引处的字符。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-10</title>
    <link href="http://example.com/2021/01/10/leetcode-train-day-10/"/>
    <id>http://example.com/2021/01/10/leetcode-train-day-10/</id>
    <published>2021-01-10T03:40:08.000Z</published>
    <updated>2021-01-10T04:29:04.943Z</updated>
    
    <content type="html"><![CDATA[<p>直接开始</p><hr><p>题目：</p><p>给定一个无重复元素的有序整数数组 nums 。</p><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p><p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p><p>“a-&gt;b” ，如果 a != b<br>“a” ，如果 a == b</p><p>示例 1：</p><p>输入：nums = [0,1,2,4,5,7]<br>输出：[“0-&gt;2”,”4-&gt;5”,”7”]<br>解释：区间范围是：<br>[0,2] –&gt; “0-&gt;2”<br>[4,5] –&gt; “4-&gt;5”<br>[7,7] –&gt; “7”<br>示例 2：</p><p>输入：nums = [0,2,3,4,6,8,9]<br>输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]<br>解释：区间范围是：<br>[0,0] –&gt; “0”<br>[2,4] –&gt; “2-&gt;4”<br>[6,6] –&gt; “6”<br>[8,9] –&gt; “8-&gt;9”<br>示例 3：</p><p>输入：nums = []<br>输出：[]<br>示例 4：</p><p>输入：nums = [-1]<br>输出：[“-1”]<br>示例 5：</p><p>输入：nums = [0]<br>输出：[“0”]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/summary-ranges">https://leetcode-cn.com/problems/summary-ranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>今天的题比较简单</p><p>我的思路是：<br>先按防御式编程，在最后加一个，数字（一开始是这么想的，后面我发现，出现了一个错误，就是加的数字在nums[i]的范围内，虽然（-1）这么能过，于是干脆就直接加一个None,这下可以了，不知道有没有错）</p><p>然后循环，如果nums[i+1] != nums[i]+1 就直接加入答案列表，如果相同的，记录此时位置，继续往后走，直到不相等。然后将这段区间加入答案列表</p><p>过程要注意的问题就是，注意越界，每次循环，判断的时候都要判断是否越界了。</p><hr><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">    nums = nums + [<span class="literal">None</span>]</span><br><span class="line">    ans = []</span><br><span class="line">    i= <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] != nums[i]+<span class="number">1</span>):</span><br><span class="line">            ans.append(<span class="built_in">str</span>(nums[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] == nums[i]+<span class="number">1</span>):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = <span class="built_in">str</span>(nums[j]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(nums[i])</span><br><span class="line">                ans.append(temp)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>不过我的解法，效率低下，时间复杂度和空间复杂度高，一开始用-1的还快些，用None的就慢了不少</p><hr><p>c语言解法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> ** <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> **res = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)*numsSize);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">res[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">30</span>);</span><br><span class="line"><span class="built_in">memset</span>(res[i],<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">30</span>);</span><br><span class="line"><span class="comment">//C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">left = i;</span><br><span class="line"><span class="keyword">while</span>(i &lt; numsSize<span class="number">-1</span> &amp;&amp; (nums[i]+<span class="number">1</span>) == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可能会出现多位数</span></span><br><span class="line"><span class="keyword">if</span>(left == i)&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(res[index++], <span class="string">&quot;%d&quot;</span>,nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(res[index++],<span class="string">&quot;%d-&gt;%d&quot;</span>,nums[left],nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> *returnSize = index;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;直接开始&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;给定一个无重复元素的有序整数数组 nums 。&lt;/p&gt;
&lt;p&gt;返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-9</title>
    <link href="http://example.com/2021/01/09/leetcode-train-day-9/"/>
    <id>http://example.com/2021/01/09/leetcode-train-day-9/</id>
    <published>2021-01-09T05:14:11.000Z</published>
    <updated>2021-01-09T05:34:54.600Z</updated>
    
    <content type="html"><![CDATA[<p>直接开始</p><hr><p>以下是题目</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> </p><p>示例 1:</p><p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<br>示例 2：</p><p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  <br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  <br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3：</p><p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br>示例 4：</p><p>输入：prices = [1]<br>输出：0</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>这道题，官方给的难度是困难，但是我觉得比昨天的简单，可能是我对动态规划的题目更会吧</p><p>解题思路就是动态规划</p><p>每一天结束后总共有五种状态</p><p>没有买卖，利润为0<br>买入了<br>卖出了（即，完成了一次交易）<br>完成了一次交易后又买入了<br>完成了两次交易</p><hr><p>python解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    length = <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    buy_1 = buy_2 = -prices[<span class="number">0</span>]</span><br><span class="line">    sell_1 = sell_2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">        buy_1 = <span class="built_in">max</span>(buy_1,-prices[i])</span><br><span class="line">        sell_1 = <span class="built_in">max</span>(sell_1,buy_1+prices[i])</span><br><span class="line">        buy_2 = <span class="built_in">max</span>(buy_2,sell_1-prices[i])</span><br><span class="line">        sell_2 = <span class="built_in">max</span>(sell_2,buy_2+prices[i])</span><br><span class="line">    <span class="keyword">return</span> sell_2</span><br></pre></td></tr></table></figure><hr><p>c 语言解法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> buy_1,buy_2,sell_1,sell_2,i;</span><br><span class="line">buy_1 = buy_2 = -prices[<span class="number">0</span>];</span><br><span class="line">sell_1 = sell_2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pricesSize&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">    buy_1 = max(buy_1,-prices[i]);</span><br><span class="line">    sell_1 = max(sell_1,buy_1+prices[i]);</span><br><span class="line">    buy_2 = max(buy_2,sell_1-prices[i]);</span><br><span class="line">    sell_2 = max(sell_2,buy_2+prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sell_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>就这样(●ˇ∀ˇ●)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;直接开始&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以下是题目&lt;/p&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>马克思主义原理概论知识点总结</title>
    <link href="http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-08T13:07:31.000Z</published>
    <updated>2021-01-12T08:43:19.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="◆-绪论"><a href="#◆-绪论" class="headerlink" title="◆ 绪论"></a>◆ 绪论</h1><h2 id="一：马克思主义来源与创新"><a href="#一：马克思主义来源与创新" class="headerlink" title="一：马克思主义来源与创新"></a>一：马克思主义来源与创新</h2><p>　　来源：德国古典哲学，英国古典政治经济学，英法空想社会主义<br>　　创新：马克思恩格斯批判地继承了前人的成果，创立了唯物史观和剩余价值学说，实现了人类思想史上的伟大革命。他们在这一时期创立的马克思主义，对人类先进思想已经提出的种种问题作了分析批判，对资本主义时代发展提出的理论课题作了科学的论述。马克思主义哲学为认识历史和时代问题提供了一种崭新的世界观和方法论原则。马克思主义政治经济学通过对资本主义生产方式的内在矛盾、运行机制和发展规律的深刻分析，揭示了资本主义剥削的秘密和它被社会主义必然代替的历史命运。科学社会主义在唯物史观和剩余价值论两大发现的基础上，阐明了由资本主义社会转变为社会主义、共产主义社会的客观规律，阐明了无产阶级获得彻底解放的历史条件和无产阶级的历史使命，使社会主义由空想成为科学。</p><h2 id="二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征）"><a href="#二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征）" class="headerlink" title="二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征）"></a>二：马克思主义最根本的世界观和方法论是什么（马克思主义最根本的理论特征）</h2><p>　　辩证唯物主义与历史唯物主义是马克思主义最根本的世界观和方法论</p><h2 id="三：马克思主义最鲜明的政治立场是什么"><a href="#三：马克思主义最鲜明的政治立场是什么" class="headerlink" title="三：马克思主义最鲜明的政治立场是什么"></a>三：马克思主义最鲜明的政治立场是什么</h2><p>　　马克思政党的一切理论和奋斗都应致力于实现以劳动人民为主体的最广大人民的根本利益，这是马克思主义最鲜明的政治立场</p><h2 id="四：马克思主义最重要的理论品质"><a href="#四：马克思主义最重要的理论品质" class="headerlink" title="四：马克思主义最重要的理论品质"></a>四：马克思主义最重要的理论品质</h2><p>　　坚持一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理，是马克思主义最重要的理论品质</p><h2 id="五：马克思主义最崇高的社会理想"><a href="#五：马克思主义最崇高的社会理想" class="headerlink" title="五：马克思主义最崇高的社会理想"></a>五：马克思主义最崇高的社会理想</h2><p>　　实现物质财富极大丰富、人民精神境界极大提高、每个人自由而全面发展的共产主义社会，是马克思主义最崇高的社会理想</p><h2 id="六：对待马克思主义的态度"><a href="#六：对待马克思主义的态度" class="headerlink" title="六：对待马克思主义的态度"></a>六：对待马克思主义的态度</h2><p>　　必须坚持马克思主义不动摇，这是就马克思主义的基本原理、基本观点和基本方法而言的。随着时代的发展和历史条件的变化，要求我们在坚持马克思主义基本原理的基础上，不断地在实践中丰富和发展马克思主义。我们一定要适应实践的发展，以实践来检验一切，用发展着的马克思主义指导新的实践。我们必须坚持解放思想、实事求是、与时俱进，从理论和实践的结合上不断研究新情况、解决新问题，做到自觉地把思想认识从那些不合时宜的观念、做法和体制的束缚中解放出来，从对马克思主义的错误的和教条式的理解中解放出来，从主观主义和形而上学的桎梏中解放出来，不断有所发现、有所创造、有所前进。</p><h1 id="◆-第一章"><a href="#◆-第一章" class="headerlink" title="◆ 第一章"></a>◆ 第一章</h1><h2 id="一：近代哲学的基本问题"><a href="#一：近代哲学的基本问题" class="headerlink" title="一：近代哲学的基本问题"></a>一：近代哲学的基本问题</h2><p>　　全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题</p><h2 id="二：马克思主义物质的定义"><a href="#二：马克思主义物质的定义" class="headerlink" title="二：马克思主义物质的定义"></a>二：马克思主义物质的定义</h2><p>　　物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映——列宁</p><h2 id="三：马克思主义物质观理论意义"><a href="#三：马克思主义物质观理论意义" class="headerlink" title="三：马克思主义物质观理论意义"></a>三：马克思主义物质观理论意义</h2><p>　　第一：坚持了物质的客观实在性原则，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。第二：坚持了能动的反映论和可知论，有力的批判了不可知论。第三：体现了唯物论和辩证法的统一。第四：体现了唯物主义自然观与唯物主义历史论的统一，为彻底的唯物主义奠定了理论基础。</p><h2 id="四：联系特征"><a href="#四：联系特征" class="headerlink" title="四：联系特征"></a>四：联系特征</h2><p>　　首先，联系具有客观性。其次，联系具有普遍性。最后，联系具有多样性。</p><h2 id="五：发展的知识点"><a href="#五：发展的知识点" class="headerlink" title="五：发展的知识点"></a>五：发展的知识点</h2><p>　　实质：是新事物的产生和旧事物的灭亡。<br>　　新旧事物：新事物是指合乎历史前进方向、具有远大前途的东西；<br>　　旧事物是指丧失历史必然性，日趋灭亡的东西<br>　　为什么新事物是不可战胜的？<br>　　①新事物符合事物发展的必然趋势，具有强大的生命力和远大的发展前途，而旧事物丧失了存在的必然性，失去了生命力和发展前途，因而必然被新事物所代替。② 新事物优越于旧事物。新事物否定了旧事物中腐朽过时的东西，吸收并发展了旧事物中积极的因素，添加了旧事物中不能容纳的新的内容。③ 在社会领域中，新事物符合广大人民群众的根本利益和要求，因而得到广大人民群众的拥护和支持，它必然战胜旧事物。</p><h2 id="六：矛盾的同一性，斗争性"><a href="#六：矛盾的同一性，斗争性" class="headerlink" title="六：矛盾的同一性，斗争性"></a>六：矛盾的同一性，斗争性</h2><p>　　矛盾的同一性：是指矛盾者双方相互依存、相互贯通的性质和趋势。<br>　　矛盾的斗争性：是矛盾者的对立面之间相互排斥、相互分离的性质和趋势。</p><h2 id="七：矛盾的普遍性，特殊性"><a href="#七：矛盾的普遍性，特殊性" class="headerlink" title="七：矛盾的普遍性，特殊性"></a>七：矛盾的普遍性，特殊性</h2><p>　　矛盾的普遍性：矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。<br>　　矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有不同特点；三是构成事物的诸多矛盾以及每一矛盾的不同方向各有不同的性质。</p><h2 id="八：量变，质变"><a href="#八：量变，质变" class="headerlink" title="八：量变，质变"></a>八：量变，质变</h2><p>　　量变：事物数量的增减和次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物渐进过程的连续性。<br>　　质变：事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物渐进过程和连续性的中断。<br>　　量变和质变的辩证关系：1）量变是质变的必要准备<br>　　2）质变是量变的必然结果<br>　　3）量变和质变是相互渗透的</p><h2 id="九：肯定，否定"><a href="#九：肯定，否定" class="headerlink" title="九：肯定，否定"></a>九：肯定，否定</h2><p>　　肯定：维持现成事物存在的因素 否定：促成现成事物灭亡的因素</p><h2 id="十：意识的作用"><a href="#十：意识的作用" class="headerlink" title="十：意识的作用"></a>十：意识的作用</h2><p>　　第一，意识是能动的，具有目的性和计划性。第二，意识活动具有创造性。第三，意识具有指导实践改造客观世界的作用。第四，意识还具有指导、控制人的行为和生理活动的作用。</p><h2 id="十一：主观能动性与客观规律的辩证统一"><a href="#十一：主观能动性与客观规律的辩证统一" class="headerlink" title="十一：主观能动性与客观规律的辩证统一"></a>十一：主观能动性与客观规律的辩证统一</h2><p>　　首先，必须尊重客观规律。其次，在尊重客观规律的基础上，要充分发挥主观能动性。</p><h1 id="◆-第二章"><a href="#◆-第二章" class="headerlink" title="◆ 第二章"></a>◆ 第二章</h1><h2 id="一：实践在认识中的决定作用"><a href="#一：实践在认识中的决定作用" class="headerlink" title="一：实践在认识中的决定作用"></a>一：实践在认识中的决定作用</h2><p>　　第一，实践产生了认识的需要。第二，实践为认识提供了可能。第三，实践使认识得以产生和发展。第四，实践是检验认识的真理性的唯一标准。</p><h2 id="二：马克思主义认识的本质是什么"><a href="#二：马克思主义认识的本质是什么" class="headerlink" title="二：马克思主义认识的本质是什么"></a>二：马克思主义认识的本质是什么</h2><p>　　认识是主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。</p><h2 id="三：运动的基本规律"><a href="#三：运动的基本规律" class="headerlink" title="三：运动的基本规律"></a>三：运动的基本规律</h2><p>　　运动是一个辩证发展过程：从实践到认识；从认识到实践；实践、认识、再实践、再认识，认识运动不断反复和无限发展。</p><h2 id="四：感性认识理性认识辩证关系"><a href="#四：感性认识理性认识辩证关系" class="headerlink" title="四：感性认识理性认识辩证关系"></a>四：感性认识理性认识辩证关系</h2><p>　　首先，理性认识依赖于感性认识，理性认识必须以感性认识为基础。坚持理性认识对感性认识的依赖关系，就是坚持了认识论的唯物论。其次，感性认识有待于发展和深化为理论认识。只有使感性认识上升到到理性认识，才能把握事物的本质，满足实践的需要。坚持了这一点，就是坚持了认识论的辩证法。最后，感性认识和理性认识相互渗透，相互包含，二者的区分是相对的，人们不应当也不可能把它们截然分开。</p><h2 id="五：认识发展的总过程"><a href="#五：认识发展的总过程" class="headerlink" title="五：认识发展的总过程"></a>五：认识发展的总过程</h2><p>　　从实践到认识，再从认识到实践如此实践、认识、再实践、再认识，循环往复以至无穷，一步步地深化和提高，这就是认识发展的总过程。</p><h2 id="六：真理的客观性、绝对性和相对性"><a href="#六：真理的客观性、绝对性和相对性" class="headerlink" title="六：真理的客观性、绝对性和相对性"></a>六：真理的客观性、绝对性和相对性</h2><p>　　客观性：真理具有客观性，凡真理都是客观真理。首先，真理的内容是客观的。其次，检验真理的标准也是客观的<br>　　绝对性：即具有绝对性的真理，是指真理的无条件性，无限性。<br>　　相对性：即具有相对性的真理，是指真理的有条件性，有限性。</p><h2 id="七：实践作为检验认识真理性的标准的确定性和不确定性"><a href="#七：实践作为检验认识真理性的标准的确定性和不确定性" class="headerlink" title="七：实践作为检验认识真理性的标准的确定性和不确定性"></a>七：实践作为检验认识真理性的标准的确定性和不确定性</h2><p>　　实践作为检验认识真理性的标准的确定性即绝对性，是指实践作为检验认识真理性的标准的唯一性，即离开了实践，再也没有另外的标准。<br>　　实践作为检验认识真理性的标准的不确定性即相对性，是指实践对认识真理性的检验的条件性。即任何实践都受到一定具体条件的制约，因而都具有一定的局限。</p><h1 id="◆-第三章"><a href="#◆-第三章" class="headerlink" title="◆ 第三章"></a>◆ 第三章</h1><h2 id="一：社会存在与社会意识及其辨证关系"><a href="#一：社会存在与社会意识及其辨证关系" class="headerlink" title="一：社会存在与社会意识及其辨证关系"></a>一：社会存在与社会意识及其辨证关系</h2><p>　　社会存在:也称社会物质生活条件，是社会生活的物质方面，主要是指物质生活资料的生产及生产方式，也包括地理环境和人口因素。<br>　　社会意识：社会生活的精神方面，是社会存在的反映。<br>　　辨证关系：社会存在和社会意识是辨证统一的。①社会存在决定社会意识，社会存在的性质决定社会意识的性质，社会存在的变化决定社会意识的变化。②社会意识是社会存在的反映，并反作用于社会存在，错误的社会意识会阻碍社会存在的发展，正确的社会意识会促进社会存在的发展。</p><h2 id="二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律）"><a href="#二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律）" class="headerlink" title="二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律）"></a>二：生产力与生产关系矛盾运动的规律（生产关系一定要适应生产力状况规律）</h2><p>　　①生产力决定生产关系，生产力的状况决定生产关系的性质，生产力的发展决定生产关系的变革。②第二，生产关系对生产力具有能动的反作用。即当生产关系适合生产力发展时，它对生产力发展起推动作用；当生产关系不适合生产力发展时，它会阻碍生产力的发展。</p><h2 id="三：经济基础与上层建筑的矛盾运动规律"><a href="#三：经济基础与上层建筑的矛盾运动规律" class="headerlink" title="三：经济基础与上层建筑的矛盾运动规律"></a>三：经济基础与上层建筑的矛盾运动规律</h2><p>　　经济基础与上层建筑是辨证统一的：①经济基础决定上层建筑。②上层建筑对经济基础具有反作用。当上层建筑适合经济基础状况时，它会促进经济基础的巩固和完善;当上层建筑不适合经济基础状况时，它会阻碍经济基础的发展和变革。</p><h2 id="四：人民群众在创造历史过程中的决定性作用"><a href="#四：人民群众在创造历史过程中的决定性作用" class="headerlink" title="四：人民群众在创造历史过程中的决定性作用"></a>四：人民群众在创造历史过程中的决定性作用</h2><p>　　⑴人民群众从质上说是指一切对社会历史发展起推动作用的人们，从量上说是指社会人口的绝大多数。人民群众的最稳定的主体部分始终是从事物质资料生产的劳动群众及其知识分子。<br>　　⑵在社会历史发展过程中，人民群众起着决定性的作用。<br>　　①人民群众是历史的主体，是历史的创造者。②人民群众的社会物质财富的创造者。③人民群众是社会精神财富的创造者。④人民群众是社会变革的决定力量</p><h1 id="◆-第四章"><a href="#◆-第四章" class="headerlink" title="◆ 第四章"></a>◆ 第四章</h1><h2 id="一：资本的原始积累"><a href="#一：资本的原始积累" class="headerlink" title="一：资本的原始积累"></a>一：资本的原始积累</h2><p>　　⑴所谓资本原始积累，就是生产者与生产资料相分离，货币资本迅速集中于少数人手中的历史过程。<br>　　⑵资本原始积累主要是通过两个途径进行的：一是用暴力手段剥夺农民的土地；二是用暴力手段掠夺货币财富。</p><h2 id="二：商品的二因素和生产商品的劳动二重性"><a href="#二：商品的二因素和生产商品的劳动二重性" class="headerlink" title="二：商品的二因素和生产商品的劳动二重性"></a>二：商品的二因素和生产商品的劳动二重性</h2><p>　　⑴商品是用来交换的能满足人们某种需要的劳动产品，具有使用价值和价值两个因素，是使用价值和价值的矛盾统一体。<br>　　⑵ 商品是劳动产品，生产商品的劳动可区分为具体劳动和抽象劳动。</p><h2 id="三：价值量与价值规律"><a href="#三：价值量与价值规律" class="headerlink" title="三：价值量与价值规律"></a>三：价值量与价值规律</h2><p>　　⑴ 价值量是由生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量。决定商品价值量的，不是生产商品的个别劳动时间，而只能是社会必要劳动时间。“社会必要劳动时间是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。”<br>　　⑵ 商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行，形成价值规律。<br>　　⑶ 价值规律的表现形式是，商品的价格围绕商品的价值自发波动。<br>　　⑷ 价值规律的作用表现在：第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。第二，自发地刺激社会生产力的发展。第三，自发地调节社会收入的分配。</p><h2 id="四：私有制基础上商品经济的基本矛盾"><a href="#四：私有制基础上商品经济的基本矛盾" class="headerlink" title="四：私有制基础上商品经济的基本矛盾"></a>四：私有制基础上商品经济的基本矛盾</h2><p>　　⑴ 在私有制为基础的商品经济中，商品生产者的劳动具有两重性：既是具有社会性质的社会劳动，又是具有私人性质的私人劳动。<br>　　⑵ 私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾。</p><h2 id="五：劳动力成为商品的基本条件"><a href="#五：劳动力成为商品的基本条件" class="headerlink" title="五：劳动力成为商品的基本条件"></a>五：劳动力成为商品的基本条件</h2><p>　　劳动力成为商品，要具备两个基本条件：第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；第二，劳动者没有别的商品可以出卖，自由得一无所有，没有任何实现自己的劳动力所必需的物质条件。</p><h2 id="六：劳动力商品的特点"><a href="#六：劳动力商品的特点" class="headerlink" title="六：劳动力商品的特点"></a>六：劳动力商品的特点</h2><p>　　劳动力商品在使用价值上有一个很大的特点，就是它的使用价值是价值的源泉，它在消费过程中能够创造新的价值，而且这个新的价值比劳动力本身的价值更大。</p><h2 id="七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用"><a href="#七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用" class="headerlink" title="七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用"></a>七：剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用</h2><p>　　⑴ 雇佣工人的劳动分为两部分：一部分是必要劳动，用于再生产劳动力的价值；另一部分是剩余劳动，用于无偿地为资本家生产剩余价值。因此，剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值，它是雇佣工人剩余劳动的凝结，体现了资本家与雇佣工人之间剥削与被剥削的关系。<br>　　⑵ 不变资本是以生产资料形态存在的资本。可变资本是用来购买劳动力的那部分资本。</p><h2 id="八：生产剩余价值的两种基本方法"><a href="#八：生产剩余价值的两种基本方法" class="headerlink" title="八：生产剩余价值的两种基本方法"></a>八：生产剩余价值的两种基本方法</h2><p>　　资本家提高对工人的剥削程度的方法是多种多样的，最基本的方法有两种，即绝对剩余价值的生产和相对剩余价值的生产。绝对剩余价值是指在必要劳动时间不变的条件下，由于延长劳动日的长度而生产的剩余价值。相对剩余价值是指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。</p><h2 id="九：资本积累"><a href="#九：资本积累" class="headerlink" title="九：资本积累"></a>九：资本积累</h2><p>　　⑴ 把剩余价值转化为资本，或者说，剩余价值的资本化，就是资本积累。<br>　　⑵ 由资本的技术构成决定并反映技术构成变化的资本价值构成，叫做资本的有机构成。通常用c∶v来表示。<br>　　⑶ 所谓相对过剩人口，就是劳动力供给超过了资本对它的需要。</p><h2 id="十：资本的循环周转与再生产"><a href="#十：资本的循环周转与再生产" class="headerlink" title="十：资本的循环周转与再生产"></a>十：资本的循环周转与再生产</h2><p>　　⑴ 资本循环是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。<br>　　⑵ 产业资本在循环过程中要经历三个不同的阶段：第一个阶段是购买阶段，即生产资料与劳动力的购买阶段。在这一阶段，产业资本执行的是货币资本的职能。第二个阶段是生产阶段，即生产资料与劳动力按比例结合在一起从事资本主义生产的阶段。执行的是生产资本的职能。第三个阶段是售卖阶段，即商品资本向货币资本的转化阶段。在此阶段产业资本所执行的是商品资本的职能。<br>　　⑶ 社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题。<br>　　⑷ 在现实的资本主义经济生活中，资本家并不是把剩余价值看作可变资本的产物，而是把它看作全部垫付资本的产物或增加额，剩余价值便取得了利润的形态。</p><h2 id="十一：资本主义基本矛盾"><a href="#十一：资本主义基本矛盾" class="headerlink" title="十一：资本主义基本矛盾"></a>十一：资本主义基本矛盾</h2><p>　　生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾。</p><h2 id="十二：经济危机"><a href="#十二：经济危机" class="headerlink" title="十二：经济危机"></a>十二：经济危机</h2><p>　　实质：经济危机的实质或本质是旧的生产力产能过剩与供给过剩，有效需求饱和与不足<br>　　根源：资本主义经济危机爆发的根本原因是资本主义的基本矛盾<br>　　周期性：资本主义经济危机具有周期性，这是由资本主义基本矛盾运动的阶段性决定的。当资本主义基本矛盾达到尖锐化程度时，社会生产结构严重失调，引发了经济危机。</p><h2 id="十三：资本主义政治制度及其本质"><a href="#十三：资本主义政治制度及其本质" class="headerlink" title="十三：资本主义政治制度及其本质"></a>十三：资本主义政治制度及其本质</h2><p>　　本质：作为资产阶级政治统治工具的阶级本质</p><h1 id="◆-第五章"><a href="#◆-第五章" class="headerlink" title="◆ 第五章"></a>◆ 第五章</h1><h2 id="一：垄断"><a href="#一：垄断" class="headerlink" title="一：垄断"></a>一：垄断</h2><p>　　⑴ 所谓垄断，是指少数资本主义大企业，为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格，进行操纵和控制。<br>　　⑵ 垄断的产生有以下原因：第一，当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以获得高额利润。第二，企业规模巨大，形成对竞争的限制，也会产生垄断。第三，激烈的竞争给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协，联合起来，实行垄断。<br>　　⑶垄断条件下竞争的特点<br>　　第一，垄断没有消除产生竞争的经济条件。第二，垄断必须通过竞争来维持。第三，社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产都包下来。</p><h2 id="二：金融资本与金融寡头"><a href="#二：金融资本与金融寡头" class="headerlink" title="二：金融资本与金融寡头"></a>二：金融资本与金融寡头</h2><p>　　金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。<br>　　金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。</p><h2 id="三：国家垄断资本主义的形成及作用"><a href="#三：国家垄断资本主义的形成及作用" class="headerlink" title="三：国家垄断资本主义的形成及作用"></a>三：国家垄断资本主义的形成及作用</h2><p>　　⑴ 国家垄断资本主义是垄断资本主义的新发展，它对资本主义经济的发展产生了积极的作用。首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展。再次，通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高。最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通讯及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了这些国家国民经济的现代化进程。<br>　　⑵ 国家垄断资本主义在本质上是资产阶级国家力量同垄断组织力量结合在一起的垄断资本主义。</p><h2 id="四：垄断资本主义的实质"><a href="#四：垄断资本主义的实质" class="headerlink" title="四：垄断资本主义的实质"></a>四：垄断资本主义的实质</h2><p>　　帝国主义的实质，即垄断资本凭借垄断地位，获取高额垄断利润。</p><h2 id="五：经济全球化"><a href="#五：经济全球化" class="headerlink" title="五：经济全球化"></a>五：经济全球化</h2><p>　　⑴ 表现：一是生产的全球化。二是贸易的全球化。三是金融的全球化。四是企业经营的全球化。<br>　　⑵ 后果：经济全球化是一个充满矛盾的进程，它在产生积极效应的同时，也会产生消极的后果。主要表现是：其一，发达国家与发展中国家之间的差距扩大。其二，在经济增长中忽视社会进步，环境恶化与经济全球化有可能同时发生。其三，各国特别是相对落后国家原有的体制、政府领导能力、社会设施、政策体系、价值观念和文化都面临着全球化的冲击，国家内部和国际社会都出现不同程度的治理危机。其四，经济全球化使各国的产业结构调整变成一种全球行为，它既为一国经济竞争力的提高提供了条件，同时也存在着对别国形成依赖的危险。</p><h2 id="六：当代资本主义新变化的实质"><a href="#六：当代资本主义新变化的实质" class="headerlink" title="六：当代资本主义新变化的实质"></a>六：当代资本主义新变化的实质</h2><p>　　首先，当代资本主义发生的变化从根本上说是人类社会发展一般规律和资本主义经济规律作用的结果。其次，当代资本主义发生的变化是在资本主义制度基本框架内的变化，并不意味着资本主义生产关系的根本性质发生了变化。<br>　　七：资本主义的历史地位———过渡的资本主义<br>　　八：资本主义为社会主义所代替的历史必然性<br>　　（一）资本主义的内在矛盾决定了资本主义必然被社会主义所代替<br>　　（二）从资本主义向社会主义过渡是一个长期的历史过程</p><h1 id="◆-第六章"><a href="#◆-第六章" class="headerlink" title="◆ 第六章"></a>◆ 第六章</h1><h2 id="一：无产阶级革命"><a href="#一：无产阶级革命" class="headerlink" title="一：无产阶级革命"></a>一：无产阶级革命</h2><p>　　⑴ 性质：无产阶级革命是迄今人类历史上最广泛、最彻底、最深刻的革命，是不同于以往一切革命的最新类型的革命。这是因为：第一，无产阶级革命是彻底消灭一切私有制、代之以生产资料公有制的革命。第二，无产阶级革命是要彻底消灭一切阶级和阶级统治的革命。第三，无产阶级革命是为绝大多数人谋利益的运动。<br>　　⑵ 从理论上说，无产阶级革命有暴力的与和平的两种形式。</p><h2 id="二：东欧剧变、苏联解体教训"><a href="#二：东欧剧变、苏联解体教训" class="headerlink" title="二：东欧剧变、苏联解体教训"></a>二：东欧剧变、苏联解体教训</h2><p>　　最深刻的教训是：放弃了社会主义道路，放弃了无产阶级专政，放弃了*<strong>的领导地位，放弃了马克思列宁主义，结果使得已经相当严重的经济、政治、社会、**</strong>进一步激化，最终酿成了制度剧变、国家解体的历史悲剧。</p><h2 id="三：社会主义的本质"><a href="#三：社会主义的本质" class="headerlink" title="三：社会主义的本质"></a>三：社会主义的本质</h2><p>　　社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</p><h2 id="四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性"><a href="#四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性" class="headerlink" title="四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性"></a>四：必须充分认识经济文化相对落后的国家社会主义建设的艰巨性和长期性</h2><p>　　第一，生产力发展状况的制约。第二，经济基础和上层建筑发展状况的制约。第三，国际环境的严峻挑战。第四，马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的艰苦的过程。</p><h2 id="五：社会主义在曲折中前进的客观性"><a href="#五：社会主义在曲折中前进的客观性" class="headerlink" title="五：社会主义在曲折中前进的客观性"></a>五：社会主义在曲折中前进的客观性</h2><p>　　第一，社会主义作为新生事物，其成长不会一帆风顺。社会主义的产生和成长，意味着对资本主义旧社会的否定，这就必然要遭到资本主义势力的拼死反抗。社会主义新社会在开始的时候总是比较弱小的，而且在一个相当长的时期里，社会主义和资本主义的矛盾和斗争是不会停止的，时起时伏，有时甚至相当激烈，资本主义还可能会复辟，这就注定社会主义战胜资本主义的过程是一个曲折的发展过程。第二，社会主义社会的基本矛盾推动社会发展，是作为一个过程而展开的，人们对它的认识也有一个逐渐发展的过程。社会主义的基本矛盾推动社会发展，体现了生产关系一定要适合生产力状况的规律、上层建筑一定要适合经济基础状况的规律。由于受主观和客观条件的限制，对社会主义社会基本矛盾运动的规律和社会主义建设规律的认识有一个过程。只有尊重社会主义发展的客观规律，在实践中自觉地运用规律，及时研究新情况、有效地解决前进中出现的矛盾和问题时，社会主义事业才能够顺利地向前发展。</p><h1 id="◆-第七章"><a href="#◆-第七章" class="headerlink" title="◆ 第七章"></a>◆ 第七章</h1><h2 id="一：共产主义社会的基本特征"><a href="#一：共产主义社会的基本特征" class="headerlink" title="一：共产主义社会的基本特征"></a>一：共产主义社会的基本特征</h2><p>　　（一）物质财富极大丰富，消费资料按需分配<br>　　（二）社会关系高度和谐，人们精神境界极大提高<br>　　（三）每个人自由而全面的发展，人类从必然王国向自由王国的飞跃</p><h2 id="二：确理解“两个必然”和“两个决不会”的关系"><a href="#二：确理解“两个必然”和“两个决不会”的关系" class="headerlink" title="二：确理解“两个必然”和“两个决不会”的关系"></a>二：确理解“两个必然”和“两个决不会”的关系</h2><p>　　马克思恩格斯在《***宣言》中提出：“资产阶级的灭亡和无产阶级的胜利是同样不可避免的。”这就是我们常说的资本主义必然灭亡和社会主义必然胜利的“两个必然”（或“两个不可避免”）。后来，马克思在《〈政治经济学批判〉序言》中又提出了“两个决不会”，即：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。” “两个必然”和“两个决不会”有着内在的联系，应该结合起来加以理解。<br>　　“两个必然”和“两个决不会”是对资本主义灭亡和共产主义胜利必然性以及这种必然性实现的时间和条件的全面论述。前者讲的是资本主义灭亡和共产主义胜利的客观必然性，是根本的方面；而后者讲的是这种必然性实现的时间和条件，它告诫我们，“两个必然”的实现需要相应的客观条件，而在这个条件具备之前决不会成为现实。<br>　　全面准确地学习和把握“两个必然”和“两个决不会”，既有利于人们坚定资本主义必然灭亡、共产主义必然胜利的信心，同时也有利于人们坚持科学态度，充分尊重客观规律，在当前艰苦的实践中坚定地为共产主义的实现而奋斗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;◆-绪论&quot;&gt;&lt;a href=&quot;#◆-绪论&quot; class=&quot;headerlink&quot; title=&quot;◆ 绪论&quot;&gt;&lt;/a&gt;◆ 绪论&lt;/h1&gt;&lt;h2 id=&quot;一：马克思主义来源与创新&quot;&gt;&lt;a href=&quot;#一：马克思主义来源与创新&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="马克思主义原理" scheme="http://example.com/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="期末复习" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>马克思主义原理期末考试重点</title>
    <link href="http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/"/>
    <id>http://example.com/2021/01/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</id>
    <published>2021-01-08T12:48:18.000Z</published>
    <updated>2021-01-08T12:57:34.642Z</updated>
    
    <content type="html"><![CDATA[<p>《马克思主义基本原理概论》考试重点</p><p>1、三次起义运动(P6)<br>  1831年、1834年法国里昂工人起义;1836年英国宪章运动;1844年德国西里西亚纺织工人起义。</p><p>2、马克思主义批判地继承、吸收(扬弃)德国古典哲学(主要代表人物:黑格尔、费尔巴哈)、英国古典政治经济学(主要代表人物:威廉·配第、亚当·斯密、大卫·李嘉图)和法国、英国空想社会主义(主要代表人物:昂利·圣西门、沙尔·傅立叶、罗伯特·欧文)。(P8~P9)</p><p>3、两大理论成果(P13)<br>  毛泽东思想和中国特色社会主义理论体系(包括邓小平理论、“三个代表”重要思想、科学发展观)</p><p>4、哲学的基本问题(P29)<br>  ①意识和物质、思维和存在，究竟谁是世界的本原，即物质和精神何者第一性、何者第二性的问题;②思维能否认识或正确认识存在的问题。</p><p>5、哲学的分类(P29)<br>  ①根据哲学基本问题第一方面的回答划分为唯物主义和唯心主义。唯物主义把世界的本原归结为物质，主张物质第一性，意识第二性，意识是物质的产物;唯心主义把世界的本原归结为精神，主张意识第一性，物质第二性，物质是意识的产物。②根据哲学基本问题第二方面的回答划分为可知论和不可知论。可知论认为世界是可以被认识的;不可知论认为世界是不能被人所认识或不能被完全认识的，否定思维和存在的统一。</p><p>6、旧唯物主义哲学(P30)<br>  包括古代朴素唯物主义和形而上学唯物主义。</p><p>7、意识的发展阶段(P31)<br>  一切物质所具有的反应特性→低等生物的刺激感应性→高等动物的感觉和心理→人类的意识。</p><p>8、马克思指出“观念的东西不外是移入人的头脑并在人的头脑中改造过的物质的东西而已。”这表明，物质决定意识，意识依赖于物质并反作用于物质。(P31)</p><p>9、时间和空间(P33)<br>  时间和空间是物质运动的存在形式，物质运动与时间和空间的不可分割证明了时间和空间的客观性。时间是指物质运动的持续性、顺序性，特点是一维性，即一去不复返;空间是指物质运动的广延性、伸张性，特点是三维性。</p><p>10、马克思主义以前的旧唯物主义都是“半截子”唯物主义。因为它们在自然观上是唯物主义，一到社会历史领域，就陷入了唯心主义。(P33)</p><p>11、实践的基本特征及构成实践活动的要素(P35)<br>  基本特征:物质性、自觉能动性、社会历史性。要素:实践主体(人)、实践对象(客体)、实践手段(工具等)。</p><p>12、实践的基本形式(P36)<br>  物质生产实践(人类最基本的实践活动)、社会政治实践、科学文化实践。</p><p>13、为什么说实践是人的存在方式？(P37)<br>  人类的产生、生存和活动，是以实践为基本方式和标志的。①实践是人所独有的活动。②实践集中表现了人的本质的社会性。③实践对物质世界的改造是对象性的活动。</p><p>14、社会生活的实践性主要体现在哪几方面？(P39)<br>  ①实践是社会关系形成的基础。②实践形成了社会生活的基本领域。③实践构成了社会发展的动力。</p><p>15、意识的能动作用及主要表现的方面(P41)<br>  意识能动作用是人的意识所特有的积极反映世界与改造世界的能力和活动。主要表现在:①意识活动具有目的性和计划性。②意识活动具有创造性。③意识具有指导实践改造客观世界的作用。④意识具有指导、控制人的行为和生理活动的作用。</p><p>16、主观能动性与客观规律性的辩证统一(P42)<br>  ①尊重客观规律是发挥主观能动性的前提。②在尊重客观规律的基础上充分发挥主观能动性。人们通过自觉活动能够认识规律和利用规律。自觉能动性是人与动物的重要区别。③尊重事物发展的规律与发挥人的主观能动性是辩证统一的。④实践是客观规律性与主观能动性统一的基础。</p><p>17、如何正确发挥主观能动作用？(P43)<br>  ①从实际出发，努力认识和把握事物的发展规律。②实践是发挥人的主观能动作用的基本途径。③主观能动作用的发挥，还依赖于一定的物质条件和物质手段。</p><p>18、联系的特点(P44)<br>  ①客观性。事物的联系是事物本身所固有的，不是主观臆想的。世界上没有孤立存在的事物，每一种事物都是和其他事物联系而存在的，这是一切事物的客观本性。②普遍性。a.任何事物内部的不同部分和要素都是相互联系的，也就是说，任何事物都具有内在的结构。b.任何事物都不能孤立存在，都同其他事物处于一定的相互联系之中。c.整个世界是相互联系的统一整体。③多样性。直接联系与间接联系，内部联系与外部联系，本质联系与非本质联系，必然联系与偶然联系等。</p><p>19、新生事物不可战胜的原因(P46)<br>  ①就新生事物与环境的关系而言，新事物之所以新，是因为有新的结构和功能，它适应已经变化了的环境和条件;旧事物之所以旧，是因为它的各种要素和功能已不适应环境和客观条件的变化，走向灭亡就成为不可避免的。②就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、仍然适合新的条件的因素，并添加了旧事物所不能容纳的新内容。</p><p>20、对立统一规律是唯物辩证法体系的实质和核心的原因(P47)<br>  ①对立统一规律揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题；②对立统一规律是贯穿质量互变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解这些规律和范畴“钥匙”；③对立统一规律提供了人们认识世界和改造世界的根本方法——矛盾分析法。</p><p>21、矛盾的同一性与斗争性的辩证统一关系(P48)<br>  矛盾同一性与斗争性之间是对立统一的辩证关系。①矛盾的同一性和斗争性之间是相互联结、相辅相成、相互制约的。一方面，同一性依赖于斗争性，同一是包含着差别、对立的同一，没有斗争性就没有同一性；另一方面，斗争性寓于同一性之中，斗争是是同一中的斗争，没有同一性，斗争性也不能成立。②同一性与斗争性之间是相对与绝对的关系。斗争性是绝对的、无条件的，同一性是相对的、有条件的，斗争性最终导致同一性的分解，有条件的同一性和无条件的斗争性相结合，推动着事物发展。</p><p>22、矛盾的普遍性和特殊性及其相互关系(P49~P50)<br>  矛盾的普遍性: 矛盾无处不在，无时不有。矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。矛盾的特殊性：一是不同事物的矛盾各有其特点；二是同一事物的矛盾在不同发展过程和发展阶段各有特点；三是构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质、地位和作用。<br>  矛盾的普遍性和特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。矛盾的共性是无条件的、绝对的，矛盾的个性是有条件的、相对的。任何现实存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键，不懂得它，就不能真正掌握唯物辩证法。矛盾的共性和个性相统一的关系，既是客观事物固有的辩证法，也是科学的认识方法。人的认识的一般规律就是由认识个别上升到认识一般，再由一般到个别的辩证发展过程。</p><p>23、量变和质变的辩证关系(P51)<br>  ①量变是质变的必要准备。任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。②质变是量变的必然结果。单纯的量变不会永远持续下去的，量变达到一定程度必然引起质变。③量变和质变是相互渗透的。一方面，在总的两边过程中有阶段性和局部性的部分质变。另一方面，在质变的过程中也有旧质在量上的收缩和新质在量上的扩张。<br>  量变和质变是相互依存、相互贯通的，量变引起质变，在新质的基础上，事物又开始新的量变，如此交替循环，形成事物质量互变的规律性。质量互变规律体现了事物发展的渐进性和飞跃性的统一。</p><p>24、辩证否定观的主要内容(P52)<br>  ①否定是事物的自我否定，是事物内部矛盾运动的结果。②否定是事物发展的环节。它是旧事物向新事物的转变，是从旧质到新质的飞跃。只有经过否定，旧事物才能向新事物转变。③否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物通过否定环节联系起来的。④辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。</p><p>25、必然性与偶然性的关系(P54)<br>  ①必然性和偶然性是对立的。必然性是事物发展过程中确定不移的趋势，是由事物的根本矛盾决定的，体现事物发展的本质联系和发展前途;偶然性是事物发展过程中不确定的趋势，是由事物的非根本矛盾和外部条件引起的，对事物的发展起加速或延缓作用。②必然性和偶然性又是统一的。a.必然性总是通过大量的偶然现象表现出来，由此为自己开辟道路，没有脱离偶然性的纯粹必然性。b.偶然性是必然性的表现形式和必要补充，偶然性背后隐藏着必然性并受到其制约，没有脱离必然性的纯粹偶然性。c.必然性和偶然性在一定条件下可以相互转化。</p><p>26、主体和客体相互作用的过程(P64)<br>  ①确立实践目的和实践方案。②实践主体按照实践目的和实践方案实际地作用于实践客体，通过一定的实践手段把实践方案变成实践的实践活动。③通过反馈和调节，使实践目的、手段和结果按一定方向运行。</p><p>27、实践在认识中的决定作用(P65)<br>  实践是认识的基础，对实践具有决定作用。①实践产生了认识的需要。②实践为认识提供了可能。③实践使认识得以产生和发展。④实践是检验认识的真理性的唯一标准。</p><p>28、两条根本对立的认识路线(P67)<br>  ①坚持从物到感觉和思想的唯物主义路线。②坚持从思想和感觉到物的唯心主义路线。</p><p>29、主观唯心主义和客观唯心主义(P67)<br>  主观唯心主义认为人的认识是主观自生的，是“内心反省”的结果，是心灵的自由创造物。客观唯心主义认为人的认识是上帝的启示或绝对精神的产物。</p><p>30、辩证唯物主义认识论和旧唯物主义认识论(P67、P68)<br>  ①旧唯物主义的认识论即形而上学唯物主义认识论，把人的认识看成是消极地、被动地反映和接受外界对象。有两个严重缺陷:a.离开实践考察认识问题，因而不了解实践对认识的决定作用。b.不了解认识的辩证性质，离开辩证法来考察认识问题，不能把认识看作是一个不断发展的过程，而认为认识是一次性完成的。②辩证唯物主义认识论认为，认识是主体对客体的能动反映。这种能动反映具有摹写性和创造性。</p><p>31、感性认识和理性认识及其辩证关系(P69、P70)<br>  感性认识：人们在实践基础上，由感觉器官直接感受到的关于事物的现象、事物的外部联系、事物各方面的认识，包括感觉、知觉和表象三种形式。理性认识：指人们借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物的本质、全体、内部联系和事物自身规律性的认识。理性认识包括概念、判断、推理三种形式。辩证关系:①理性认识依赖于感性认识。理性认识必须以感性认识为基础，坚持理性认识对感性认识的依赖关系就是坚持了认识论的唯物论。②感性认识有待于发展和深化为理性认识。只有使感性认识上升到理性认识才能把握住事物的本质，满足实践的需要，坚持这一点就是坚持了认识论的辩证法。③感性认识和理性认识相互渗透、相互包含。感性认识和理性认识是辩证统一的，统一的基础是实践。</p><p>32、从感性认识过渡到理性认识所具备的条件(P70)<br>  ①勇于实践，深入调查，获取十分丰富和合乎实际的感性材料，这是正确实现由感性认识上升到理性认识的基础。②必须经过理性思考的作用，将丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的制作加工，才能将感性认识上升到理性认识。也就是说，必须运用辩证思维的科学方法，才能获得真正的认识。</p><p>33、造成认识过程反复性和无限性的原因(P72)<br>  ①人们对事物的认识，由于主客观条件的限制，往往不是一次完成的。从主观方面说，人们总是受到自己认识能力和实践活动范围的限制。从客观方面说，会受到科学技术条件的限制，以及客观过程的发展和表现程度的限制。②从人们具体的认识过程看，当某一思想、理论、计划、方案等，经过多次反复，在实践中达到预想结果，就算完成了。</p><p>34、实用主义所鼓吹的“有用就是真理”这句话是错误的。这是主观真理论的一个典型，实用主义者把“有用”和“真理”完全等同，从根本上否认了客观真理的存在。(P74)</p><p>35、真理的绝对性和相对性及其关系(P75)<br>  真理的绝对性即具有绝对性的真理，是指真理的无条件性、无限性。真理的相对性即具有相对性的真理，是指真理的有条件性、有限性。任何真理都只能是主管对客观事物近似正确即相对正确的反映。关系:真理的绝对性和相对性是辩证统一的。①具有绝对性的真理和具有相对性的真理是相互渗透和相互包含的。②具有相对性的真理向具有绝对性的真理转化。</p><p>36、价值的特性(P81)<br>  ①客观性。价值关系的各个环节都是客观的。a.人的需要具有客观性。b.用来满足人的需要的对象也具有客观性。c.满足人的需要的过程和结果也具有客观性。②主体性。③社会历史性。④多维性。</p><p>37、价值评价及其特点(P82、P83)<br>  价值评价是一种关于价值现象的认识活动。特点:①评价是以主客体的价值关系为认识对象的。②评价结果与评价主体有直接关系，是依主体的特点而转移的。③评价结果的正确与否依赖于相关的知识性认识。</p><p>38、党的十八大“三个倡导”(P85)<br>  倡导富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善，积极培育和践行社会主义核心价值观。</p><p>39、两种根本对立的历史观(P95、P98)<br>  ①唯物史观。认为:社会历史发展具有自身固有的客观规律；社会存在决定社会意识，社会意识又反作用于社会存在；生产力和生产关系之间的矛盾，经济基础和上层建筑之间的矛盾是推动社会发展的基本矛盾。②唯心史观。认为:社会意识决定社会存在，人们的思想动机是社会发展的根本原因，否认社会发展的客观规律。</p><p>40、社会存在与社会意识及其辩证关系(P96)<br>  社会存在:也称社会物质生活条件，是社会生活的物质方面，它包括地理环境和人口因素和物质资料的生产方式，其中物质资料的生产方式是社会存在的主要方面。社会意识:社会意识是社会生活的精神方面，是社会存在的反映。辩证关系:社会存在决定社会意识，社会意识是对社会存在的反映。社会存在和社会意识是辩证统一的。社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。①社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。②社会意识是人们社会物质交往的产物。③随着社会存在的发展，社会意识也相应地或迟或早地发生变化和发展。</p><p>41、社会意识的分类(P96)<br>  社会意识具有复杂的结构。按照社会意识主体的不同，可以区分为个人意识和群体意识；按照社会意识反映层次的高低，可以区分为社会心理和社会意识形式；按照同经济基础关系的不同，可以区分为作为上层建筑的意识形式（社会意识形态）和非上层建筑的意识形式。上层建筑的意识形式（或者说社会意识形态）包括政治法律思想、道德、艺术、宗教、哲学和大部分的社会科学（例如：经济学、政治学、法学、社会学等等）；它们从各自不同方面发挥独特的作用。而非上层建筑的意识形式主要是指自然科学，也包括一部分社会科学和思维科学（例如：语言学、修辞学、逻辑学等等）。在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级的意识形态，因而具有鲜明的阶级属性。</p><p>42、社会意识相对独立性的主要表现(P99)<br>  ①社会意识与社会存在发展的不完全同步性和不平衡性。②社会意识的发展具有历史继承性。③社会意识各种内部形式之间的相互影响、相互作用。④社会意识对社会存在的能动的反作用，这是社会意识相对独立性的突出表现。</p><p>43、生产力的基本要素(P101)<br>  ①劳动资料(也称劳动手段)。②劳动对象。③劳动者。</p><p>44、生产力与生产关系的相互关系(P104)<br>  生产力决定生产关系，生产关系对生产力有反作用。①生产力决定生产关系:a.生产力状况决定生产关系的性质，有什么样的生产力，就会产生什么样的生产关系；b.生产力的发展决定生产关系的发展和变革。②生产关系对生产力具有能动的反作用:a.当生产关系与生产力的发展要求相适合时，它会有力地推动生产力的发展；b.当生产关系与生产力的发展要求不相适合时，它会阻碍甚至破坏生产力的发展。</p><p>45、经济基础和上层建筑的矛盾运动(P108)<br>  经济基础与上层建筑是辩证统一的。①经济基础决定上层建筑。经济基础是上层建筑赖以产生、存在和发展的物质基础，上层建筑是经济基础得以确立统治地位并巩固和发展不可缺少的政治、思想条件。任何上层建筑的产生、存在和发展，都能直接或间接地从社会的经济结构中得到说明。经济基础的性质决定上层建筑的性质，有什么样的经济基础就有什么样的上层建筑。经济基础的变更必然引起上层建筑的变革，并决定着其变革的方向。②上层建筑对经济基础具有反作用。集中表现在:为自己的经济基础的形成和巩固服务，确立或维护其在社会中的统治地位。上层建筑这种反作用的后果可能有两种:当它为适合生产力发展要求的经济基础服务时，就成为推动社会发展的进步力量;反之，就会成为阻碍社会发展的消极力量。</p><p>46、社会形态的分类(P110)<br>  ①经济形态(基础)。②政治形态。③意识形态。</p><p>47、社会历史发展的动力(P113)<br>  ①根本动力:社会基本矛盾(生产力和生产关系、经济基础和上层建筑的矛盾)。②直接动力:阶级斗争。③重要动力:革命、改革、科学技术。</p><p>48、群众观点与群众路线(P133)<br>  群众观点:人民群众至上。坚信人民群众自己解放自己;全心全意为人民服务;一切向人民群众负责;虚心向群众学习。 群众路线:一切为了群众，一切依靠群众，从群众中来，到群众中去。</p><p>49、试用物质和意识的辩证关系原理，说明我国的现代化建设必须走自己的路，建设中国特色的社会主义。<br>  答:①物质和意识的辩证关系是：物质第一性，意识第二性，先有物质，后有意识。物质决定意识，意识是物质的反应，意识对物质具有能动的反作用，正确的意识对事物的发展起足进作用，错误的意识对事物的发展起阻碍作用。这一原理要求我们在实际工作要坚持一切从实际出发，实事求是。②我国的社会主义现代化建设，必须从中国的客观实际出发，从中国的国情，国力和基本特点出发。我国当前乃至今后相当长一段时期处于社会主义初级阶段是我国的基本国情，是我国当前的最大实际，是我们党制定路线，方针和政策的客观依据。我国的现代化建设必须从这一基本国情出发，把马克思主义的基本原理同中国的实际紧密结合起来。建设中国特色的这会注义。③在现代化建设过程中，必须会遇到需多新情况、新问题。这就要求我们从实际出发，尊重客观规律，不断开创现代化建设的新局面。必须反对从主观愿望和书本教条出发，反对照搬照抄他人的检验和模式。</p><p>50、试用矛盾的普遍性和特殊性的辩证关系原理，说明坚持中国特色社会主义道路的重要性。<br>  答:①矛盾的普遍性是指矛盾存在于一切事物的发展过程中，存在于一切事物发展过程的始终。矛盾的特殊性是指具体事物的矛盾及每一矛盾的各个方面都有其特点。②矛盾的普遍性和特殊性是辩证的统一。第一，矛盾的普遍性和特殊性是相互联结的。普遍性存在于特殊性之中，特殊性中包含着普遍性。第二，矛盾的普遍性和特殊性在一定条件下可能相互转化。③矛盾的普遍性和特殊性辩证统一的原理，是把马克思主义普遍真理与中国的具体实际相结合，走建设有中国特色社会主义道路的重要理论依据。④我们既要坚持社会主义的根本制度和基本原则，又必须注意中国的特点，从中国正处于并将长期处于社会主义初级阶段这一实际出发，走自己的路。只有这样，才能把建设有中国特色社会主义事业推向前进。</p><p>51、用认识和实践的关系原理，说明科学发展观对中国特色社会主义建设的重要意义。<br>  答:①认识是实践的基础，实践对认识起决定作用。实践是认识的来源、动力、检验标准和目的。理论一经形成对实践有能动作用，主要表现在:正确的认识和理论可以指导实践指向适当的对象，采取正确的方法，从而取得成功。错误的认识和理论，会引导实践指向不适当的对象，采取错误的方法，从而导致失败。②科学发展观是马克思主义关于发展世界观和方法论的集中体现，是我国经济社会发展的重要指导方针。它进一步正确地回答了实现什么样的发展、怎样发展的问题，体现了我们党对执政规律、社会主义建设规律和人类社会发展规律认识的进一步深化。③科学发展观能够指导我国经济社会实现又快又好的发展，解决发展中的不平衡、不协调问题，为我国经济社会发展指明了正确的方向。④认真学习全面领会科学发展观，才能真正坚持贯彻科学发展观。</p><p>52、用真理的绝对性和相对性的辩证关系原理，说明对待马克思主义的正确态度。<br>  答:①真理的绝对性和相对性的关系:首先，两者相互对立、相互区别;绝对真理是指真理的内容是客观的，人类的认识按其本性是能够正确反映无限发展着的物质世界。相对真理是指真理只是对客观事物一定范围的正确反映，是对事物一定程度、一定层次的近似正确的反映。其次，两者相互依存、相互渗透。相对真理中包含着绝对真理的成分，绝对真理是由无数相对真理构成的。再次，人类的认识永远处在从相对真理向绝对真理的转化过程中。②马克思主义作为科学真理，是绝对性和相对性的统一。马克思主义是关于自然、社会和思维发展的普遍规律的科学，它的基本原理经过实践的反复检验、证明，对各国的革命和建设具有普遍的指导意义，这是无条件的、绝对的。马克思主义没有穷尽一切真理，必将随着科技的进步和实践的发展而前进，这又是其相对性。对待马克思主义的科学态度关键在于正确处理好坚持和发展马克思主义的关系，即既要坚持，又要发展，在坚持中发展，在发展中坚持。③割裂真理的绝对性和相对性的关系会导致真理问题上的绝对主义或相对主义。在实际工作中要反对片面夸大马克思主义的绝对性、否认其相对性的教条主义、本本主义的错误，又要反对片面夸大其相对性、否认其绝对性的所谓马克思主义“过时论”、“无用论”的错误。</p><p>53、试述社会意识相对独立的原理并用以说明加强社会主义精神文明建设的重要性。<br>  答:(1)社会存在决定社会意识，社会意识是社会存在的反映，因此，它没有绝对独立性，只具有相对独立性。社会意识相对独立性的表现：①社会意识对社会存在有巨大的能动的反作用：先进的社会意识对社会存在的发展起着促进和推动的作用，落后反动的社会意识阻碍社会存在的发展。②社会意识和社会存在变化和发展的不完全同步性：社会意识的变化有时落后于社会存在的变化；先进的社会意识在不同程度上预见社会存在变化发展的趋势和未来。③社会意识同社会经济发展水平的不平衡性：经济上先进的国家，意识形态的发展却可能落后；经济上落后的国家，意识形态发展可能先进。④社会意识各种形式之间能互相作用，其中政治思想居于主导地位，对其他意识形式有巨大影响。⑤社会意识具有历史继承性，后人总要继承前人的思想材料，并加以改造和发展。(2)重要性：①社会主义精神文明建设，是实现社会主义现代化的战略任务，它能推动社会主义社会存在的发展。它为社会主义生产方式、经济制度的发展提供了精神动力和智力支持及思想保证，也是改革开放和实现社会主义现代化的根本保证。②社会主义精神文明建设又是抵制封建主义、资产阶级腐朽思想的重要武器，是反对资产阶级自由化的重要武器。③社会主义精神文明建设不仅关系到我国社会主义方向和道路，而且是关系到我国整个社会生活的精神面貌的大问题。因此，搞好它是极为重要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《马克思主义基本原理概论》考试重点&lt;/p&gt;
&lt;p&gt;1、三次起义运动(P6)&lt;br&gt;  1831年、1834年法国里昂工人起义;1836年英国宪章运动;1844年德国西里西亚纺织工人起义。&lt;/p&gt;
&lt;p&gt;2、马克思主义批判地继承、吸收(扬弃)德国古典哲学(主要代表人物:黑格尔</summary>
      
    
    
    
    <category term="马克思主义原理" scheme="http://example.com/categories/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="期末复习" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-8</title>
    <link href="http://example.com/2021/01/08/leetcode-train-day-8/"/>
    <id>http://example.com/2021/01/08/leetcode-train-day-8/</id>
    <published>2021-01-08T06:23:57.000Z</published>
    <updated>2021-01-08T09:08:19.845Z</updated>
    
    <content type="html"><![CDATA[<p>直接开始</p><hr><p>今日题目</p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>对于python的解法，我第一时间想到的就是python的切片解法，并且运用的就是python的解法<br>以下是我的解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   length = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">   nums[:] = nums[length-k:] + nums[:length-k]</span><br></pre></td></tr></table></figure><p>最后虽然过了，但是我看了解法区别人的说法，说是切片操作其实，是不符合要求的感觉，切片似乎还是要另外的储存空间，因此时间复杂的O(1)的要求是不符合的。</p><p>然后评论里面找了一个解答是三次反转，发现真是妙啊</p><p>思路是先0-length-k位置的数组反转；再是k-最后的反转；再最后整体反转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n=<span class="built_in">len</span>(nums)</span><br><span class="line">    k=k%n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">l,r</span>):</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r):</span><br><span class="line">            nums[l],nums[r]=nums[r],nums[l]</span><br><span class="line">            l=l+<span class="number">1</span></span><br><span class="line">            r=r-<span class="number">1</span></span><br><span class="line">    swap(<span class="number">0</span>,n-k-<span class="number">1</span>)</span><br><span class="line">    swap(n-k,n-<span class="number">1</span>)</span><br><span class="line">    swap(<span class="number">0</span>,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>真是好奇妙啊</p><p>此外还有插入法等其他方法；python的法就这样吧</p><hr><p>然后就是c语言的方法</p><p>采用的就是三次反转的思路</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp,i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(end-begin+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    temp = nums[begin+i];</span><br><span class="line">    nums[begin+i] = nums[end-i];</span><br><span class="line">    nums[end-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!nums || numsSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">k %= numsSize;</span><br><span class="line">reverse(nums,<span class="number">0</span>,numsSize-k<span class="number">-1</span>);</span><br><span class="line">reverse(nums,nums-k,numsSize<span class="number">-1</span>);</span><br><span class="line">reverse(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中途有个错误，就是，定义函数的入口参数，一开始写的是nums与系统给的一样，也不知道怎么回事，就是会显示内存溢出了，所以后面改成num;以后要注意这个问题，入口参数的定义尽量不要同名</p><hr><p>嗯，就这样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;直接开始&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今日题目&lt;/p&gt;
&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,2,3,4,5,6,7] 和 k = 3&lt;br&gt;输出: [5,6,7,1,2,3,4]&lt;b</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-7</title>
    <link href="http://example.com/2021/01/07/leetcode-train-day-7/"/>
    <id>http://example.com/2021/01/07/leetcode-train-day-7/</id>
    <published>2021-01-07T06:15:14.000Z</published>
    <updated>2021-01-08T09:08:38.539Z</updated>
    
    <content type="html"><![CDATA[<p>今天的也是一个中等难度的的题目</p><hr><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p> </p><p>示例 1：</p><p>输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-provinces">https://leetcode-cn.com/problems/number-of-provinces</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>第一个感觉就是图有关的题目，然后。转换过来就是求根节点的个数，通过遍历图来求</p><p>以下是解法：</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">isConnected,i,length</span>):</span></span><br><span class="line">        visit[i] = <span class="literal">True</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        row = isConnected[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&lt;length):</span><br><span class="line">            <span class="keyword">if</span>(row[j]==<span class="number">1</span> <span class="keyword">and</span> visit[j] == <span class="literal">False</span>):</span><br><span class="line">                dfs(isConnected,j,length)</span><br><span class="line">            j  += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">len</span>(isConnected[<span class="number">0</span>])  <span class="comment">#节点个数</span></span><br><span class="line">    visit = [<span class="literal">False</span>]*length <span class="comment">#初始化节点，全部标为未访问</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span> <span class="comment">#省份数量</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;length):</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="literal">False</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            dfs(isConnected,i,length)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>主要思路就是深度遍历图，统计根节点的个数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的也是一个中等难度的的题目&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。&lt;/p&gt;
&lt;p&gt;省份 是一组直接或间接相连的城市，组内不含其他</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-6</title>
    <link href="http://example.com/2021/01/06/leetcode-train-day-6/"/>
    <id>http://example.com/2021/01/06/leetcode-train-day-6/</id>
    <published>2021-01-06T15:03:32.000Z</published>
    <updated>2021-01-08T09:09:10.617Z</updated>
    
    <content type="html"><![CDATA[<hr><p>今天差点忘记了写这个。。。</p><hr><p>今天的题目，压根不会，看了答案后，知道是数据结构图的应用.方法是并查集。还涉及到路径压缩问题</p><p>是一道除法求值题</p><hr><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>示例 1：</p><p>输入：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br>输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]<br>解释：<br>条件：a / b = 2.0, b / c = 3.0<br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]<br>示例 2：</p><p>输入：equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br>输出：[3.75000,0.40000,5.00000,0.20000]<br>示例 3：</p><p>输入：equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br>输出：[0.50000,2.00000,-1.00000,-1.00000]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-division">https://leetcode-cn.com/problems/evaluate-division</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>这道题着实是不会，所以我直接看的题解；然后通过看官方的视频明白了并查集的操作。</p><p>但由于官方给的解题视频讲解的是java的代码，还是有一定的区别，所以，我有看了下面的大佬的解题思路</p><p>这个答主先给出了个并查集模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    记录每个节点的父节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.father = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    路径压缩</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> x != root:</span><br><span class="line">        original_father = self.father[x]</span><br><span class="line">        self.father[x] = root</span><br><span class="line">        x = original_father</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        self.father[root_x] = root_y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断两节点是否相连</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    添加新节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">        self.father[x] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>作者：MiloMusiala<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-division/solution/pythonbing-cha-ji-fu-mo-ban-by-milomusia-kfsu/">https://leetcode-cn.com/problems/evaluate-division/solution/pythonbing-cha-ji-fu-mo-ban-by-milomusia-kfsu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>以下是python的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#记录每个节点的父节点,记录每个节点到根节点的权重</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">        self.value = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="comment">#查找根节点，路径压缩，以及压缩路径后权重的更新（每次查找时，通识带了路径压缩）</span></span><br><span class="line">        </span><br><span class="line">        root = x</span><br><span class="line">        <span class="comment"># 节点更新权重的时候要放大的倍数</span></span><br><span class="line">        base = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">            root = self.father[root]</span><br><span class="line">            base *= self.value[root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            original_father = self.father[x]</span><br><span class="line">            <span class="comment">##### 离根节点越远，放大的倍数越高</span></span><br><span class="line">            self.value[x] *= base</span><br><span class="line">            base /= self.value[original_father]</span><br><span class="line">            <span class="comment">#####</span></span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = original_father</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#合并两个节点</span></span><br><span class="line">        </span><br><span class="line">        root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.father[root_x] = root_y2021/<span class="number">1</span>/<span class="number">6</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">51</span> </span><br><span class="line">            <span class="comment">##### 四边形法则更新根节点的权重</span></span><br><span class="line">            self.value[root_x] = self.value[y] * val / self.value[x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">#两节点是否相连</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.value <span class="keyword">and</span> y <span class="keyword">in</span> self.value <span class="keyword">and</span> self.find(x) == self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#添加新节点，初始化权重为1.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line">            self.value[x] = <span class="number">1.0</span></span><br><span class="line">            </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span>(<span class="params">self, equations: List[List[<span class="built_in">str</span>]], values: List[<span class="built_in">float</span>], queries: List[List[<span class="built_in">str</span>]]</span>) -&gt; List[float]:</span></span><br><span class="line">        uf = UnionFind()</span><br><span class="line">        <span class="keyword">for</span> (a,b),val <span class="keyword">in</span> <span class="built_in">zip</span>(equations,values):</span><br><span class="line">            uf.add(a)</span><br><span class="line">            uf.add(b)</span><br><span class="line">            uf.merge(a,b,val)</span><br><span class="line">    </span><br><span class="line">        res = [-<span class="number">1.0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,(a,b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(a,b):</span><br><span class="line">                res[i] = uf.value[a] / uf.value[b]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2021/1/6 23:48:56 </p><p>不写了，好晚了，室友也要睡觉了不好打扰他们。明天再回来看看这道题吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;今天差点忘记了写这个。。。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今天的题目，压根不会，看了答案后，知道是数据结构图的应用.方法是并查集。还涉及到路径压缩问题&lt;/p&gt;
&lt;p&gt;是一道除法求值题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;给你一个变量对数组 equations 和一个实数值数组 va</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-5</title>
    <link href="http://example.com/2021/01/05/leetcode-train-day-5/"/>
    <id>http://example.com/2021/01/05/leetcode-train-day-5/</id>
    <published>2021-01-05T06:09:32.000Z</published>
    <updated>2021-01-08T09:10:30.368Z</updated>
    
    <content type="html"><![CDATA[<hr><p>每日一题</p><hr><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p><p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p><p> </p><p>示例 1：</p><p>输入：s = “abbxxxxzzy”<br>输出：[[3,6]]<br>解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。<br>示例 2：</p><p>输入：s = “abc”<br>输出：[]<br>解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。<br>示例 3：</p><p>输入：s = “abcdddeeeeaabbbcd”<br>输出：[[3,5],[6,9],[12,14]]<br>解释：较大分组为 “ddd”, “eeee” 和 “bbb”<br>示例 4：</p><p>输入：s = “aba”<br>输出：[]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/positions-of-large-groups">https://leetcode-cn.com/problems/positions-of-large-groups</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>python解法</p><p>首先是我自己的思路<br>直接遍历，从头开始，统计相邻的字符最多有多少个相同，如果其长度大》=3就将其开始位置和结束位置加入到列表中，继续从结束位置的下一个位置开始遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    </span><br><span class="line">    n =<span class="built_in">len</span>(s)</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;n):</span><br><span class="line">        temp = s[i]</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>((i &lt; n) <span class="keyword">and</span> (s[i]==temp)):</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(length&gt;=<span class="number">3</span>):</span><br><span class="line">            start = i -length</span><br><span class="line">            end = i-<span class="number">1</span></span><br><span class="line">            ans.append([start,end])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>第二种是 看别人的解法，有好多的是双指针，不是很懂什么双指针；对于c的针更熟悉；但是感觉和我的想法是差不多的，不过是循环的变量用了两个，</p><p>使用i,j指针，i指针记录起始下标；j指针判断是s[j]与s[i]是否相同：相同继续向后移，不相同则中止while循环，此时一定要注意的是这个时候的j指向的字母不同于s[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">    res=[]</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    length=<span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">while</span> i&lt;length:</span><br><span class="line">        j=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;length <span class="keyword">and</span> s[j]==s[i]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#此时的j指向了一个不同的字母</span></span><br><span class="line">        <span class="keyword">if</span> j-<span class="number">1</span>-i&gt;=<span class="number">2</span>:</span><br><span class="line">            res.append([i,j-<span class="number">1</span>])</span><br><span class="line">        i=j</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>作者：stone-115<br>链接：<a href="https://leetcode-cn.com/problems/positions-of-large-groups/solution/pythonshuang-zhi-zhen-jie-fa-tong-su-yi-7t4ey/">https://leetcode-cn.com/problems/positions-of-large-groups/solution/pythonshuang-zhi-zhen-jie-fa-tong-su-yi-7t4ey/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>第三种是正则表达式的的解法，这个着实不是很懂，正则表达式学的不够好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    data=[i+j <span class="keyword">for</span> i,j <span class="keyword">in</span> re.findall(<span class="string">r&#x27;([a-z])(\1*)&#x27;</span>,S)]</span><br><span class="line">    res,idx=[],<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(k)&gt;=<span class="number">3</span>:</span><br><span class="line">            res.append([idx,idx+<span class="built_in">len</span>(k)-<span class="number">1</span>])</span><br><span class="line">        idx+=<span class="built_in">len</span>(k)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>作者：2558260433<br>链接：<a href="https://leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-biao-da-shi-by-2558260433/">https://leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-biao-da-shi-by-2558260433/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>这个的方法，没有写思路，感觉上来讲，好像式直接条用re库里的函数，然后，通过这个函数可以得到一个切片后的字符串组，每个字符串只包含一个一种字符，再通过对该字符数组的遍历，找出符合条件的，将其开始和结束位置，加入输出答案中。</p><hr><p>然后是c语言的写法，开始我想用，python的写法，不过没有成功。主要是不会建立一个空的列表（尴尬）;看了别人的解题方式后，老老实实的去用指针了</p><p>一下是代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment">  * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment">  * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>** <span class="title">largeGroupPositions</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span>** ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (l / <span class="number">3</span>));</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (l / <span class="number">3</span>) );</span><br><span class="line">    *returnSize=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;l)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[start]==s[end])&#123;</span><br><span class="line">            end++;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            tmp[<span class="number">0</span>] = start, tmp[<span class="number">1</span>] = end<span class="number">-1</span>;</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            ret[(*returnSize)++]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        start=end;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>不过还是不是很懂这道题语言解法的思路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;每日一题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;p&gt;例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据科学概论考试知识点</title>
    <link href="http://example.com/2021/01/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA%E8%80%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2021/01/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA%E8%80%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-01-04T07:55:11.000Z</published>
    <updated>2021-01-08T08:34:25.077Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a><strong><strong>第一章</strong></strong></h3><p><em>数据科学定义</em></p><p>定义：数据科学是关于对与数据进行分析、抽取信息和知识的过程提供指导合作支持的基本原则方法科学</p><p>​            数据科学的核心任务是从数据中从获取信息、发现知识。数据科学包含一组概念、原则、过程、技能/方法以及工具，为其核心任务为服务</p><p>​            简而言之，数据科学是以各类数据作为研究对象的，建立在在应对分析挑战的众多关键技术基础上的通识意义上的科学</p><p>大数据的三个主要特点： 数据量大、数据类型多、数据生成快、价值密度低</p><p><em>数据科学的基本原则：</em></p><p>​    1、数据分析可以划分成一系列的明确阶段</p><p>​    2、描述性与预测分析</p><p>​    3、实体的相似度</p><p>​    4、模型泛化能力</p><p>​    5、分析结果的评估与特定的应用场景有关</p><p>​    6、相关性不同于因果关系</p><p>​    7、通过并行处理提高数据处理（分析）速度</p><p>数据处理的流程：</p><p>1、数据采集<br>2、数据表示和储存<br>3、数据清洗<br>4、数据集成<br>5、数据分析<br>6、数据可视化<br>7、基于数据的决策</p><hr><p>​    </p><h3 id="第二章-OLTP与数据服务"><a href="#第二章-OLTP与数据服务" class="headerlink" title="第二章    OLTP与数据服务"></a>第二章    OLTP与数据服务</h3><p>数据服务是指面向操作型业务，提供数据的增加、删除、修改以及简单的查询功能（增删改查）</p><p>联机事务处理（OLTP）指的是用户的业务请求转化成数据库的操作，传送到后台数据库管理系统，数据库管理系统在很短的时间内，把用户的相关数据操作当作一个事务来处理，对用户的请求进行响应</p><p>联机事务处理的两个特点：一个是用户请求作为一个事务进行处理，另一个是响应时间短</p><h4 id="ACID事务特性："><a href="#ACID事务特性：" class="headerlink" title="ACID事务特性："></a><em>ACID事务特性</em>：</h4><p>A：原子性，指的是事务的所有操作，要么全部执行，要么都没有执行</p><p>​    C：一致性，值的是事务把数据库状态，从一个有效状态转化为另一个新的有效状态</p><p>​    I：隔离性，是指在一个并发的事务处理系统中和其他事务是相互隔离的，事务的各个操作步骤可以交替执行，但必须和保        证某个未提交的事务和其他事务时相互隔离的，目的是保证未提交的数据，别的事物不能看到</p><p>​    D：指的时提交的数据的必须保存起来，当系统失败和重启，数据能够恢复到最近的正确后状态</p><p>数据安全性保证的主要技术手段： 用户认证和授权、审计和数据加密等</p><p>关系模型的完整性包括实体完整性、参照完整性、用户自定义完整性</p><h4 id="NoSQL数据"><a href="#NoSQL数据" class="headerlink" title="NoSQL数据"></a><em>NoSQL数据</em></h4><p>​    Not only SQL ,是某一类数据库的统称</p><p>​    主要特点：采用和关系模型不同的数据模型，采取了一些新的设计原则，目的是利用大型计算机集群实现大数据的有效处                        理</p><p>​                        新原则：1、采用横向扩展方式应对大数据挑战；2、放弃严格的ACID一致性约束，允许数据暂时出现不一致，接受最终一致性；</p><p>​                                        3、对数据的储存进行容错处理，一般对数据块进行适当的备份</p><h4 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h4><p>在大型分布式数据库中，一致性、系统可用性、网络分区容忍性这三个目标中，只可以获得其中两个，追求其中两个将损害另外一个的目标</p><p>​    </p><p>NoSQL的四种数据库类型<br>| 四种类型            | 代表                |<br>| ——————- | ——————- |<br>| Key-Value数据库     | Dynamo数据库、Redis |<br>| Column Family数据库 | Big Table、HBase、  |<br>| Document数据库      | MongoDB             |<br>| Graph数据库         | Neo4J               |</p><p>NewSQL没怎讲，不搞了</p><h4 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h4><p>   定义：所谓分布式数据库，它运行在多台计算机上，这些计算机通过网络互联。每台计算机可以放在一个地方，每台计算机安装独立的RDBMS系统，拥有数据的完整拷贝，或者部分拷贝。这些计算机系统共同组成一个完整的、逻辑上集中、但是物理上分布的大型数据库。</p><hr><h3 id="第三章-OLAP-与结构化数据"><a href="#第三章-OLAP-与结构化数据" class="headerlink" title="第三章   OLAP 与结构化数据"></a>第三章   OLAP 与结构化数据</h3><p>联机分析处理（OLAP）：是在以星型模型（或雪花模型）建立的数据仓库上进行多维分析</p><p>结构化数据分析： 是一个更为广泛的概念，它运行在结构化数据上，分析可以表达成一个SQL聚集查询</p><p>数据仓库与星型模型，BILL Inmon认为数据仓库是面向主题的、集成的、非易失的和时变的数据集合，用以支持管理决策</p><p>数据仓库一般不对应到某个厂商的具体产品，而是指一种面向对象的数据分析储存方案</p><p>联机分析处理的主要操作：下钻、上卷、切片、切块、旋转等</p><p>​                                            下钻和上卷是改变维的层次；切片和切块是选定一部风维度值，然后查看度量数据剩余维度上的分布情况；旋转操作时改变维的方向</p><p>三种类型的OLAP系统：多维OLAP（MOLAP)、关系OLAP(ROLAP)、混合OLAP(HOLAP)；</p><p>​                                        MOLAP优点性能高，缺点是占用大量的空间保存汇总数据</p><p>​                                        ROLAP优点利用关系数据库保存原始明细数据，占用空间有限，但性能有限</p><p>​                                        HOLAP是两者的集合，HOLAP的查询效率比ROLAP高，比MOLAP低</p><p>高性能OALP系统的三种实现技术</p><p>​    列储存技术<br>​            </p><p>​    位图索引技术</p><p>​    内存数据库技术</p><hr><h3 id="第四章-数据清洗与数据集成"><a href="#第四章-数据清洗与数据集成" class="headerlink" title="第四章  数据清洗与数据集成"></a>第四章  数据清洗与数据集成</h3><p>ETL (Extract、Tansform and Load) : 数据抽取，转换和装载</p><p>数据集成是从多个数据源建立统一的数据视图的一种技术</p><p>数据清洗是一种消除数据里面错误、去掉重复数据的技术</p><h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><p>​    数据清洗的意义：剔除数据中的错误，以便获得高质量的数据，基于高质量的数据分析才能获得可信的分析结果，进而做出正确的决策</p><p>​    数据异常的不同类型：</p><p>​        1、语法类异常：词法错误、值域格式错误、不规则的取值</p><p>​        2、语意类异常：违反完整性约束规则、数据中出现矛盾、数据重复</p><p>​        3、覆盖类异常：值缺失、元组缺失</p><h4 id="数据质量："><a href="#数据质量：" class="headerlink" title="数据质量："></a>数据质量：</h4><p>​            数据质量的评价标准：完整的评价标准是子评价标准的综合加权评分</p><p>​                                1、正确性：完整性、一致性（可继续划分为模式符合性和统一性）、密度</p><p>​                                2、唯一性</p><p>​            数据清洗的任务和过程</p><p>​                                任务：剔除数据里的异常，使得数据集成为现实世界的准确、没有重复的表示过程</p><p>​                                            主要操作：1、对元组及其各个属性的格式进行调整。<br>2、完整性约束条件的检查和实施。3、从已知值中导出缺失值。4、检测离群值</p><p>​                                过程：</p><p>​                                            数据审计—&gt;选择合适的方法—&gt;执行方法—&gt;后序处理和控制</p><p>​            数据清洗的具体方法：</p><p>​                            1、数据解析<br>数据解析的目的是检测语法错误</p><p>​                            2、数据转换<br>数据转换的目的是把数据从一个格式映射到另外一种格式，以适应程序的需要。在实例层面一般采取标准化和规范化方法，提出数据的不规则性</p><p>​                            3、实施完整性约束条件</p><p>​                            4、重复数据消除</p><p>​                            5、一些统计方法</p><h4 id="数据集成："><a href="#数据集成：" class="headerlink" title="数据集成："></a>数据集成：</h4><p>​            数据集成是指把数据从多个数据源整合在一起，提供一个观察这些数据统一视图的过程、</p><p>​            数据集成分为物理式数据集成、虚拟式数据集成两类</p><p>​            数据集成需要解决的问题——异构性：管理系统的异构性、通信协议异构性、数据模式异构性、数据类型异构性、</p><p>​            数据集成的三种模式：建立数据仓库、联邦数据库模式、中介者模式</p><hr><h3 id="第五章-数据的深度分析（数据挖掘、机器学习）"><a href="#第五章-数据的深度分析（数据挖掘、机器学习）" class="headerlink" title="第五章  数据的深度分析（数据挖掘、机器学习）"></a>第五章  数据的深度分析（数据挖掘、机器学习）</h3><p>广义上而言，机器学习是一种能够赋予机器学习的能力，让它完成直接编程无法完成的功能的方法。</p><p>机器学习的目的是：是预测（包括分类和回归）</p><p>特征选择算法（书上出现的）：</p><p>互信息、文档频率、信息增益、卡方检验</p><p>机器学习的基本过程是利用训练数据（包含输入数据和预期输出的分类或者数值）训练一个模型，利用这个模型，就可以对新的实例数据进行分类和计算一个预测</p><p>机器学习的方法可以分为：监督学习、无监督学习、半监督学习</p><p>​        监督学习：是机器学习的一种类别，训练数据由输入特征（Feature）和预期的输出构成，输出可以是一个连续的值，或者是一个分类的标签。</p><p>​        无监督学习：与监督学习的区别就是没有训练样本，直接对数据建模。</p><p>​        半监督学习：是监督学习和无监督学习的结合，它研究利用少量的标注样本和大量未标注的样本进行训练和预测问题。半监督学习分为半监督分类，半监督回                                归，半监督聚类，半监督降维算法</p><h4 id="主流机器学习算法"><a href="#主流机器学习算法" class="headerlink" title="主流机器学习算法"></a>主流机器学习算法</h4><p>决策树、<strong>聚类算法K-means</strong>、SVM、关联规则分析Apriori算法、EM算法、协同过滤推荐算法、<strong>朴素贝叶斯算法</strong></p><hr><h3 id="第六章-流数据处理"><a href="#第六章-流数据处理" class="headerlink" title="第六章  流数据处理"></a>第六章  流数据处理</h3><h4 id="流数据处理应用"><a href="#流数据处理应用" class="headerlink" title="流数据处理应用"></a>流数据处理应用</h4><p>​                网络监控、电信数据管理、工业制造、传感器网络、电子商务、量化交易等</p><h4 id="流式处理和批处理的区别"><a href="#流式处理和批处理的区别" class="headerlink" title="流式处理和批处理的区别"></a>流式处理和批处理的区别</h4><p>​                流式处理时针对批处理来讲的</p><p>流式处理（Stream Processing） 是针对 批处理（Batch Processing）来讲的，即它们是两种截然不同的数据处理模式，具有不同的特点，适用于不同的应用场合。不能简单地认为其中一种数据处理模式优于另一种数据处理模式。</p><p>对于批处理来讲，首先数据被不断地采集，保存到数据库中，然后进行分析处理（包括SQL查询）。批处理适用于对大量数据（High Volume）进行处理的场合。人们需要等到整个分析处理任务完成，才能获得最终结果。由于需要处理的数据集大小以及计算机系统的计算能力的差异，整个过程有时需要耗费相当长的时间，即获得最终分析处理结果的延迟较大。批处理是最通用的数据处理模式。传统的关系数据库系统、Hadoop以及Spark大数据处理平台等，都采用了这样的数据处理模式，或者以该处理模式为主。由于需要完整地保存整个数据集，并且在上面进行分析处理，比起流式数据处理系统，人们需要投入更多的硬件资源。</p><p>批处理系统可以存取已经入库的所有数据，人们可以对数据进行复杂深入的分析，分析处理的延迟以分钟或者小时计。批处理作业（Job）一旦提交，则一直运行，直到获得最终结果或者失败退出，无需用户人工干预。这些作业在整个数据集或者某个子集上执行一系列的分析，产生分析结果。在性能方面，批处理系统主要考虑系统的吞吐能力，而不是单个分析处理任务的处理延迟（Latency）。</p><p>在流式数据处理模式里，数据持续到达，系统及时处理新到达的数据，并不断产生输出。处理过的数据一般丢弃掉，当然也可以保存起来。流式数据处理模式强调数据处理的速度（Velocity）。部分原因是数据产生的速度很快，需要及时进行处理。由于流式数据处理系统能够对新到达的数据进行及时的处理，所以它能够给决策者提供最新的事物发展变化的趋势，以便对突发事件进行及时响应，调整应对措施。</p><h4 id="查询处理的基础算法"><a href="#查询处理的基础算法" class="headerlink" title="查询处理的基础算法"></a>查询处理的基础算法</h4><p>​    随机采样、梗概技术、直方图、小波分析、布隆过滤器、计数最小梗概</p><p>流数据处理系统     Storm</p><hr><h3 id="第七章-文本分析"><a href="#第七章-文本分析" class="headerlink" title="第七章 文本分析"></a>第七章 文本分析</h3><h4 id="文本分析的意义："><a href="#文本分析的意义：" class="headerlink" title="文本分析的意义："></a>文本分析的意义：</h4><p>深入了解非结构化数据，帮助企业或个人对产品和服务做出改进</p><h4 id="文本分析的过程"><a href="#文本分析的过程" class="headerlink" title="文本分析的过程"></a>文本分析的过程</h4><p>1、采集文本数据。2、运用文本分析方法分析文本。3、对分析结果进行可视化以及解释和评估分析结果等。</p><h4 id="文本分析的任务和方法"><a href="#文本分析的任务和方法" class="headerlink" title="文本分析的任务和方法"></a>文本分析的任务和方法</h4><p>句子切分、分词、词性标注、语法分析</p><p>​        切分和分词 ，对于文本进行分析需要将文本切分为一个一个的句子，完成该功能的软件是语句切分器</p><p>​        词性标注</p><p>​        语法树  1、概率型上下文无关语法分析激素。2、位移归约语法分析技术。3、基于神经网络的语法分析技术</p><h4 id="文本聚类的几种方法"><a href="#文本聚类的几种方法" class="headerlink" title="文本聚类的几种方法"></a>文本聚类的几种方法</h4><p>1、基于距离的聚类算法。2、基于单词或者短语的聚类算法。3、基于话题建模技术的概率聚类算法。</p><hr><h3 id="第十章-数据可视化、可视分析与探索十数据分析"><a href="#第十章-数据可视化、可视分析与探索十数据分析" class="headerlink" title="第十章 数据可视化、可视分析与探索十数据分析"></a>第十章 数据可视化、可视分析与探索十数据分析</h3><h4 id="什么是什么可视化"><a href="#什么是什么可视化" class="headerlink" title="什么是什么可视化"></a>什么是什么可视化</h4><p>可视化是一种数据的可视表现形式以及交互技术的总称。它通过图形化的方式把数据表现出来，方便用户进行观察和理解，并且帮助用户对数据进行探索，发现数据里隐藏的模式，获得对大量数据的理解和洞察力</p><h4 id="可视化分析技术"><a href="#可视化分析技术" class="headerlink" title="可视化分析技术"></a>可视化分析技术</h4><p>1、数据：数据是所有可视化分析的基础</p><p>2、模型：可以是某个方面的属性的统计值，也可以是复杂的数据挖掘和机器学习算法</p><p>3、可视化：结果一般依据模型的分析结果进行绘制</p><p>4、探索回路：描述的是分析者如何和可视分析系统进行交互，目的是生成新的可视化结果或者调整模型；它涉及两个方面，即动作和发现</p><p>5、验证回路 ：（1）假设 （2）理解和洞察力，洞察里定义为分析者对于上述的法相如何进行解释。在解释过程中，需要用到领域的先验知识</p><p>6、产生知识回路</p><hr><h3 id="第十一章-云计算平台"><a href="#第十一章-云计算平台" class="headerlink" title="第十一章 云计算平台"></a>第十一章 云计算平台</h3><h4 id="云计算的概念与特点"><a href="#云计算的概念与特点" class="headerlink" title="云计算的概念与特点"></a>云计算的概念与特点</h4><p>​    概念：云计算也称为按需计算，它是对可配置的共享的计算资源池提供安迅存取的一种计算模型，这里的资源包括计算、储存、网络等硬件资源</p><p>​    特点：虚拟化、弹性、成本低廉、高度容错性和高度可靠性</p><p>​    云计算与并行计算、分布式计算、集群计算、网格计算的区别于联系：</p><p>​            并行计算是相对串行计算而言，可以分为时间上和空间上的并行。</p><p>​            分布式计算通过把整个计算任务分解成一些列的小任务，分布到各个结点上计算分别执行，最后汇总结果。获得最终结果。</p><p>​            集群计算通过高速网络把一组本来松散联系的结点（计算机）通过软件紧密联系在一起，协作完成计算工作</p><p>​            网格计算在本章中算作集群计算的一种</p><p>​            云计算是上述技术的发展新阶段，器底层的核心技术是虚拟化，即把计算、储存、网络等硬件都进行虚拟化。</p><p>​            云计算强调子要你的利用率</p><h4 id="虚拟化技术与数据中心"><a href="#虚拟化技术与数据中心" class="headerlink" title="虚拟化技术与数据中心"></a>虚拟化技术与数据中心</h4><p>虚拟化技术包括服务器虚拟化，储存虚拟化和网络虚拟化等重要内容</p><h5 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h5><p>​    指把一台物理服务器虚拟成若干独立的逻辑服务器，各个逻辑夫妻拥有自己的CPU,内存以及I/O设备。</p><p>​    储存虚拟化分为两种：寄居虚拟化以及裸机虚拟化（通俗而言，前者就是，在一个已经安装了操作系统的机器上安装VMM，后者则是直接在未安装操作系统的    机器上安装VMM，后者为轻量级）</p><p>​    </p><h5 id="储存虚拟化"><a href="#储存虚拟化" class="headerlink" title="储存虚拟化"></a>储存虚拟化</h5><p>​    目的是把分散的、异构的储存设备，想办法映射成一个统一的、连续编址的逻辑储存空间，也叫虚拟存储池</p><p>​    三种实现方式：基于主机的存储虚拟化，基于储存设备的虚拟化、基于网络的储存虚拟化</p><h5 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h5><p>​    网络虚拟化在不改变数据中心网络的物理拓扑和布线情况下，可以虚拟出各层网络，并实现互联，形成统一的交换架构。</p><p>​    网络虚拟化包括核心层、接入层以及虚拟机网络化三个层次</p><h5 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h5><p>​    数据中心主要特点和优势：通过服务器虚拟化、储存虚拟化、网络虚拟化、应用虚拟化技术，把各种硬件资源整合，对外提供服务，提高设备利用率。</p><p>​    数据中心一般采用冗余、容错、容灾设计</p><hr><h3 id="第十二章-Hadoop"><a href="#第十二章-Hadoop" class="headerlink" title="第十二章 Hadoop"></a>第十二章 Hadoop</h3><h4 id="两个版本之间的区别与联系"><a href="#两个版本之间的区别与联系" class="headerlink" title="两个版本之间的区别与联系"></a>两个版本之间的区别与联系</h4><h5 id="1-0版本的优势与局限："><a href="#1-0版本的优势与局限：" class="headerlink" title="1.0版本的优势与局限："></a>1.0版本的优势与局限：</h5><p>​        优势是它的可拓展性。</p><p>​        局限是：1、仅支持一种计算模型，即MapReduce。2、MapReduce作业的Map阶段和Reduce阶段执行过程中需要通过磁盘的存取操作进行，效率低下。</p><p>​                        3、调度方法远未达到优化资源利用率的效果</p><h5 id="2-0版本的不同"><a href="#2-0版本的不同" class="headerlink" title="2.0版本的不同"></a>2.0版本的不同</h5><p>​        新增YARN模块，将1.0中的resource management部分拿出来作为YARN的内容单独（把资源管理功能单独划分出来）。</p><p>​        支持更多的计算模型，包括流数据处理、图数据处理、批处理、交互式处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;strong&gt;第一章&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;em&gt;数据科学定义&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定义：数据科学是关</summary>
      
    
    
    
    <category term="数据科学概论" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA/"/>
    
    
    <category term="期末复习" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-4</title>
    <link href="http://example.com/2021/01/04/leetcode-train-day-4/"/>
    <id>http://example.com/2021/01/04/leetcode-train-day-4/</id>
    <published>2021-01-04T06:31:32.000Z</published>
    <updated>2021-01-08T08:27:37.643Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，就这样，每日一题</p><hr><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p> </p><p>示例 1：</p><p>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1<br>示例 2：</p><p>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2<br>示例 3：</p><p>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fibonacci-number">https://leetcode-cn.com/problems/fibonacci-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>从今天开始，我觉得，不仅要做python的，也要做c语言的</p><p>然后今天的题目特别简单，是一道特别简单的题目；我首先想到的就是递归的写法</p><hr><p>c语言解法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>python解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>): </span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> self.fib(n-<span class="number">2</span>) + self.fib(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><p>然后看了评论，递归</p><p>递归的写法似乎算法不是特别好，特别是用python的时候，时间复杂度和空间复杂度都比较大；然后官方给的方法是动态规划、矩阵快速幂、通项公式。并没有递归的方法；看来递归并不是这道题的最优解。</p><p>官方的动态规划理解的了，然后矩阵的不是很懂。再看看吧</p><hr><p>要加油呀whk</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嗯，就这样，每日一题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;p&gt;F(0) = 0，F(1) = 1&lt;br&gt;F(n) = F(n - 1</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-train-day-2</title>
    <link href="http://example.com/2021/01/03/leetcode-train-day-3/"/>
    <id>http://example.com/2021/01/03/leetcode-train-day-3/</id>
    <published>2021-01-03T05:59:10.000Z</published>
    <updated>2021-01-08T08:35:13.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目"><a href="#今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目" class="headerlink" title="今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目"></a>今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目</h2><h1 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h1><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p> </p><p>示例：</p><p>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-list">https://leetcode-cn.com/problems/partition-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>这道题一看就是数据结构的题目，本来我个人的意愿是刷python的习题的，然后这道数据结构的题目我不会用python 写毕竟没学过python的数据结构，不过还是得写的，我写了个c语言的；然后就去评论区看python的以及c语言是否有更好的算法；python的不能算是我自己写的吧，个人感觉更像是copy（唉），照猫画虎写的</p><hr><p>c语言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">partition</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp1</span> =</span> pre;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp2</span> =</span> p;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre-&gt;next = temp2-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> temp1-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">    pre = ListNode(<span class="number">0</span>)</span><br><span class="line">    p = ListNode(<span class="number">0</span>)</span><br><span class="line">    temp1 = pre</span><br><span class="line">    temp2 = p</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span>(head.val &lt; x):</span><br><span class="line">            temp1.<span class="built_in">next</span> = head</span><br><span class="line">            temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp2.<span class="built_in">next</span> = head</span><br><span class="line">            temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    temp1.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">    temp2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> pre.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>然后python的我发现一个问题吧（抄都抄不对(⊙﹏⊙)），最后两个链表合成一个赋值语句顺序反了，导致最后答案与题目要求的答案有一定的出入，修改后没有了</p><hr><p>总结：python的数据结构没有指针，不是很习惯，就酱d=====(￣▽￣*)b。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目&quot;&gt;&lt;a href=&quot;#今天登录进去leetcode里面才发现，原来昨天也没有打到卡，要打卡就要做日历里面的题目，所以今天我点的日历里的题目&quot; cl</summary>
      
    
    
    
    <category term="每日一题" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="leetcode每日一题" scheme="http://example.com/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
